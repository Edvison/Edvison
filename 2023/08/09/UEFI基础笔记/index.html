<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/project/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/project/fontawesome/css/brands.css" rel="stylesheet">
<link href="/project/fontawesome/css/solid.css" rel="stylesheet">
<script src="/project/js/color.global.min.js" ></script>
<script src="/project/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>UEFI基础笔记 | Edvison&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="很久之前整理的UEFI相关笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="UEFI基础笔记">
<meta property="og:url" content="https://edvison.github.io/project/2023/08/09/UEFI%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Edvison&#39;s blog">
<meta property="og:description" content="很久之前整理的UEFI相关笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/3.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/4.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/5.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/6.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/7.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/8.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587708091/UEFI%20Basic/11.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587712795/UEFI%20Basic/12.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587869399/UEFI%20Basic/13.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587870628/UEFI%20Basic/14_2.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587883176/UEFI%20Basic/15.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587883889/UEFI%20Basic/16.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587890272/UEFI%20Basic/19.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891222/UEFI%20Basic/20.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891222/UEFI%20Basic/21.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891222/UEFI%20Basic/22.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891361/UEFI%20Basic/23.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587970012/UEFI%20Basic/26.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587970013/UEFI%20Basic/27.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587978219/UEFI%20Basic/28.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587952601/UEFI%20Basic/24.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/1.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/2.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/9.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/10.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587884581/UEFI%20Basic/17.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587884993/UEFI%20Basic/18.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587967011/UEFI%20Basic/25.png">
<meta property="og:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1588726971/UEFI%20Basic/50_P3X7__PH5J_AJ4ZDW_CK.png">
<meta property="article:published_time" content="2023-08-09T07:11:04.000Z">
<meta property="article:modified_time" content="2023-08-09T07:54:09.861Z">
<meta property="article:author" content="edvison">
<meta property="article:tag" content="UEFI">
<meta property="article:tag" content="原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/3.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Edvison's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/project/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230807175151.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/project/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Edvison's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/project/">Home</a>
    
      <a class="main-nav-link" href="/project/archives">Archives</a>
    
      <a class="main-nav-link" href="/project/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/project/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/project/">Home</a>
    
      <a class="nav-dropdown-link" href="/project/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/project/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/project/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230808155156.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Edvison </div>
      <div class="dot"></div>
      <div class="subtitle">flung out of space </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Edvison" title="github"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://weibo.com/u/6038772011" title="weibo"><i class="fa-brands fa-weibo"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/project/categories/UEFI%E5%8E%9F%E7%90%86/">
                UEFI原理
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/project/categories/UEFI%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/">
                UEFI固件安全
                <div class="category-count">6</div>
            </a>
        
            <a class="category-link" href="/project/categories/MBR%E5%8E%9F%E7%90%86/">
                MBR原理
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">
                翻译
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/Grub2%E5%8E%9F%E7%90%86/">
                Grub2原理
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/IoT%E5%AE%89%E5%85%A8/">
                IoT安全
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/">
                硬件安全
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/VBIOS%E4%BF%AE%E6%94%B9/">
                VBIOS修改
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/CSM/" rel="tag">CSM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/DMA%E6%94%BB%E5%87%BB/" rel="tag">DMA攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/Grub2/" rel="tag">Grub2</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/HID%E6%94%BB%E5%87%BB/" rel="tag">HID攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR/" rel="tag">MBR</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR%E5%90%8E%E9%97%A8/" rel="tag">MBR后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OS-Loader/" rel="tag">OS Loader</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OVMF%E7%BC%96%E8%AF%91/" rel="tag">OVMF编译</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/PCH/" rel="tag">PCH</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM/" rel="tag">SMM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E5%90%8E%E9%97%A8/" rel="tag">SMM后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">SMM漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/VBIOS/" rel="tag">VBIOS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/pcie/" rel="tag">pcie</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4/" rel="tag">写保护</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4%E7%AA%81%E7%A0%B4/" rel="tag">写保护突破</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/" rel="tag">安全启动</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/" rel="tag">开发板</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="tag">树莓派</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/" rel="tag">漏洞扫描</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%94%B5%E6%BA%90%E6%95%85%E9%9A%9C/" rel="tag">电源故障</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/project/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">22 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Lenovo固件中的SMM callout漏洞利用" >
            <div class="recent-link-text">
              Lenovo固件中的SMM callout漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="利用DMA攻击突破UEFI安全机制" >
            <div class="recent-link-text">
              利用DMA攻击突破UEFI安全机制
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="UEFI 引导脚本表漏洞利用" >
            <div class="recent-link-text">
              UEFI 引导脚本表漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/" title="基于UEFI平台的SMM后门构建" >
            <div class="recent-link-text">
              基于UEFI平台的SMM后门构建
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/P4wnP1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="P4wnP1配置与使用" >
            <div class="recent-link-text">
              P4wnP1配置与使用
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-UEFI基础笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        UEFI基础笔记
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-08-09T07:11:04.000Z" itemprop="datePublished">2023-08-09</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/project/categories/UEFI%E5%8E%9F%E7%90%86/">UEFI原理</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            7.8k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>很久之前整理的UEFI相关笔记。</p>
<span id="more"></span>

<h1 id="UEFI基础知识"><a href="#UEFI基础知识" class="headerlink" title="UEFI基础知识"></a>UEFI基础知识</h1><h2 id="UEFI分析"><a href="#UEFI分析" class="headerlink" title="UEFI分析"></a>UEFI分析</h2><p>参考Blackhat的<a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/eu-14/materials/eu-14-Kovah-Analyzing-UEFI-BIOSes-From-Attacker-And-Defender-Viewpoints.pdf">Analyzing UEFI BIOS from Attacker &amp; Defender Viewpoints</a><br>不想看一大堆代码，可以从下面两个部分入手：</p>
<ul>
<li>Beyond BIOS: Developing with the Unified Extensible Firmware Interface 2nd Edition一书</li>
<li><a target="_blank" rel="noopener" href="https://uefi.org/specifications">https://uefi.org/specifications</a></li>
</ul>
<h3 id="UEFI固件"><a href="#UEFI固件" class="headerlink" title="UEFI固件"></a>UEFI固件</h3><p>常用的专业术语：</p>
<ul>
<li>FD，Firmware Device，固件设备，比如SPI flash芯片之类的。</li>
<li>FD，Flash Descriptor</li>
<li>固件卷（FVs，Firmware Volumes）</li>
<li>固件文件系统（FFS，Firmware File System）</li>
</ul>
<p>UEFI存储在SPI Flash芯片中，SPI Flash芯片当前分为5个区域，详情如下图所示：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/3.png" alt="029c048c0e7a1d84f528d6d46e85a546.png"><br>FD（Flash Descriptor）为Region 0，每个分区间的用途和访问控制权限不同。在研究UEFI固件时，需要重点关注UEFI&#x2F;BIOS区域。Firmware Device是一个物理组件，比如Flash芯片就是一个物理组件。但是我们重点关注的部分是逻辑区块，也就是固件卷（FVs，Firmware Volumes）。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/4.png" alt="33c4608523c07465ffe7e4f8f3dadbf9.png"><br>FVs实际上是逻辑固件设备，包含了多个固件分区，**通常可在PEI或DXE代码中提取出固件卷(volumns)**。固件卷通常由一个或多个固件文件系统（FFS, Firmware File System）封装而成，FFS的基础单元是一个文件。FV实际的偏移量不会与FD(Firmware Descriptor)中的BIOS分区的起始位置对齐。固件卷的结构构成如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/5.png" alt="4f3ef8fc6f7f9293c7d2450eaf9dfea2.png"><br>上图中很好地展现了FV-FFS-Section之间的关系，文件数据存放于Section的数据区中，下图右侧的部分就是Section数据区中的文件，右侧绿色的部分是固件文件首部的结构，白色则是文件数据。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/6.png" alt="67f37982c0afcc9be98965aa2398f252.png"><br>固件文件的文件格式是PE（Portable Executable）文件，或者可以说是一个TE（Terse Executable）文件，TE文件可以看作一个极简的PE文件，其首部的数据结构如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/7.png" alt="2d256c9ce5f371830b12fe55f09fbdd8.png"></p>
<h3 id="固件文件系统-FFS-分析工具"><a href="#固件文件系统-FFS-分析工具" class="headerlink" title="固件文件系统(FFS)分析工具"></a>固件文件系统(FFS)分析工具</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/LongSoft/UEFITool">UEFITool</a>，利用UEFIExtract命令行版本能够快速地提取出所有的文件，有图形化界面。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/theopolis/uefi-firmware-parser">UEFI Firmware Parser</a>，当所有的文件可解析时，提取文件的速度非常快，安装python模块即可使用。</li>
</ul>
<h3 id="UEFI启动流程"><a href="#UEFI启动流程" class="headerlink" title="UEFI启动流程"></a>UEFI启动流程</h3><p><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/8.png" alt="UEFI启动流程图"><br>UEFI系统从加电到关机的7个阶段：</p>
<ul>
<li>SEC：安全验证</li>
<li>PEI：EFI前期初始化</li>
<li>DXE：驱动执行环境</li>
<li>BDS：启动设备选择</li>
<li>TSL：操作系统加载前期</li>
<li>RT：Run Time</li>
<li>AL：系统灾难恢复期<br>在SEC、PEI、DXE这三个阶段中，UEFI会进行初始化。DXE阶段结束后UEFI环境已经准备完毕。BDS和TDL是操作系统加载器作为UEFI应用程序运行的阶段，接下来会对上述过程进行详细的分析。</li>
</ul>
<h4 id="Security（SEC）阶段"><a href="#Security（SEC）阶段" class="headerlink" title="Security（SEC）阶段"></a>Security（SEC）阶段</h4><ul>
<li>SEC阶段是平台初始化（PI，Platform Initialization）的第一阶段</li>
<li>存储了CPU首先执行的代码</li>
<li>运行环境基于以下条件：<ul>
<li>Small&#x2F;minimal code typically hand-coded assembly so architecturally dependent and not portable ——小&#x2F;极小代码通常需要手动编译，因此依赖PI架构而且非可执行文件，能够单独运行的可以看作为一个绿色软件，双击<code>.exe</code>文件就可以直接运行了。</li>
<li>直接从flash中运行</li>
<li>代码未经过压缩</li>
</ul>
</li>
<li>在平台初始化的过程中，该阶段应该执行核心安全检测代码，但实际上并没有，攻击者往往会在这个阶段之前破坏系统。</li>
<li>SEC阶段的任务<ul>
<li>SEC阶段会处理所有的系统重置事件（power on, wakeup from sleep等等）<ul>
<li>系统会基于电源的起始状态选择引导（Boot）时代码执行路径<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587708091/UEFI%20Basic/11.png" alt="11.png"><ul>
<li>ACPI知识点补充：睡眠模式（Sleep Mode）<ul>
<li>ACPI(Advanced Configuration and Power Interface, 高级配置与电源接口)</li>
<li>由睡眠模式决定的备用引导（Boot）路径可能会使 BIOS 产生漏洞</li>
<li>从睡眠模式唤醒的系统的引导（Boot）代码执行路径不同，这种不同的代码执行路径，会使系统不能与断电状态下系统引导路径一样可以锁定系统。</li>
<li>比如：当您从关机打开电源时，BIOS可能会锁定，但在从睡眠中醒来时不会锁定。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>初始化临时存储区域<ul>
<li>临时存储区域——使用了CAR技术（Cache as RAM），将CPU缓存作为RAM使用</li>
<li>SEC阶段仅CPU和CPU内部资源被初始化，内存还未进行分配，所有的读写操作都必须在CPU缓存（Cache）上操作。</li>
<li>利用CAR技术初始化栈，为C代码执行准备环境<ul>
<li>CAR: Cache as RAM，当Cache被配置为no-eviction模式时，可以作为内存使用，读命中时返回Cache中的数据，读缺失时不会向贮存发出缺失事件；写命中时将数据写入Cache，写缺失时不会向主存发出缺失事件。</li>
</ul>
</li>
<li>引导启动进程（Boot Strap Processor）的缓存在SEC阶段被使用，该进程于启动时激活。</li>
</ul>
</li>
</ul>
</li>
<li>SEC阶段的进程在实模式下运行，实模式是指程序地址为真是的物理地址，可以访问任意地址空间，这样不同进程可能访问到其他进程程序，造成严重错误。</li>
<li>SEC阶段的段寄存器是相同的<ul>
<li>CS:IP &#x3D; F000:FFF0</li>
<li>CS.BASE &#x3D; FFFF_0000h</li>
</ul>
</li>
<li>SEC阶段的入口vector为JMP指令<ul>
<li>SEC执行分为两大部分：临时RAM生效之前成为Reset Vector阶段，临时RAM生效后调用SEC入口函数从而进入SEC功能区。</li>
<li>在Reset Vector部分，系统还没有RAM，因此不能使用基于栈的程序设计，所有的函数调用都使用JMP指令模拟。</li>
</ul>
</li>
<li>微指令（microcode）是在SEC阶段进行更新的，通过给microcode打补丁可以减少或降低microcode中的错误带来的影响。如果此时刚好microcode打补丁的过程中出现了问题，并且攻击者获取了最新的BIOS&#x2F;UEFI，且可在最新的microcode进行写操作，那就有可能实现攻击。</li>
<li>SEC阶段传递给PEI阶段（PeiCore）的参数说明：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587712795/UEFI%20Basic/12.png" alt="PeiMain函数图"><ul>
<li>SEC Core Data<ul>
<li>SecCoreData指向含有操作系统环境信息的数据结构，数据结构中包含信息如下：<ul>
<li>临时RAM的位置及其大小</li>
<li>临时RAM中栈所在的位置</li>
<li>Boot固件卷（BFV, Boot Firmware）的位置<ul>
<li>根据GUID定位Flash文件系统（Flash File System）位置</li>
<li>GUID： 8C8CE578-8A3D-4F1C-3599-35896185C32DD3</li>
<li>如果未能定位BFV的位置，系统运行中止</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>PPI（PEIM-to-PEIM Interface） List<ul>
<li>PEI Core最初安装时所需的PPI描述符列表</li>
</ul>
</li>
<li>指向vendor-specific data的空指针</li>
<li>PeiMain执行之后不会返回到SEC阶段，直至下一次系统重置</li>
</ul>
</li>
</ul>
<h4 id="PEI-Pre-EFI-阶段"><a href="#PEI-Pre-EFI-阶段" class="headerlink" title="PEI(Pre-EFI)阶段"></a>PEI(Pre-EFI)阶段</h4><ul>
<li>PEI阶段的任务<ul>
<li>初始化内存（可长期使用，非临时存储区域）</li>
<li>在HOB（Hand-off-Blocks）列表中向DXE阶段描述内存信息，HOB列表是PEI要传递到DXE的信息</li>
<li>在HOB中描述固件卷（Firmware Volume）的位置信息</li>
<li>将控制权转交到DXE手中</li>
<li>判断Boot模式，若适用，从睡眠状态恢复<ul>
<li>Boot代码执行路径会基于电源状态（Power State）进行选择</li>
</ul>
</li>
</ul>
</li>
<li>PEI的组成<ul>
<li>Pre-EFI初始化模块（PEIMs，Pre-EFI Initialization Modules）<ul>
<li>存储在FFS文件中的模块化单元，包含了代码和（或）单元</li>
<li>作用：获取内存、FV（Firmware Volume）的信息，创建HOB列表等等</li>
<li>可基于已安装的PPIs（PEIM-to-PEIM Interfaces）运行<ul>
<li>相关依赖项由PEI Dispatcher检查</li>
</ul>
</li>
</ul>
</li>
<li>PEIM-to-PEIM接口（PPI, PEIM-to-PEIM Interface）<ul>
<li>允许PEIMs间通信<ul>
<li>PEIM可与其他PEIM间协作完成任务并实现代码复用</li>
</ul>
</li>
<li>PEIM中包含了数据结构EFI_PEI_PPI_DESCRIPTOR，该数据结构中带有一个GUID和指针</li>
<li>PPI分为两类：Architectural PPI和Additional PPI<ul>
<li>Architectural PPI：依赖PEI内核（PEI Foundation）的PPIs，比如给ReportStatusCode()这个PEI服务提供通信接口的PPI就是这种类型的。</li>
<li>Additional PPI：不依赖PEI内核（PEI Foundation）的PPIs</li>
</ul>
</li>
</ul>
</li>
<li>PEIM调度器（PEIM Dispatcher）：找出系统中所有所需的PEIM,并根据PEIM之间的依赖关系按顺序安装、执行PEIM。</li>
<li>Dependency表达式（DEPEX，Dependency Expression）<ul>
<li>PPI的GUID必须在PEIM加载或执行之前分配好。</li>
</ul>
</li>
<li>固件卷（Firmware Volumes）：用户存储PEIM，在该阶段（PEI阶段）不会被解压，但是在DXE阶段会解压。</li>
<li>PEI Services<ul>
<li>允许所有的PEIM、PPI使用，PEI内核也能使用</li>
<li>提供各种服务，比如InstallPpi()、LocateFv()等。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587869399/UEFI%20Basic/13.png" alt="PEI服务表"></li>
</ul>
</li>
<li>PEI执行流程<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587870628/UEFI%20Basic/14_2.png" alt="PEI执行流程图"><ul>
<li>上图为PEI内核在PEI阶段的执行流程图</li>
<li>PEI内核负责PEI服务表的创建</li>
<li>PEI内核的核心围绕着PEIM调度器，PEIM调度器负责PEIM的定位和执行</li>
<li>最后一个调度的PEIM为DXE IPL(Initial Program Load) PEIM，该PEIM负责过渡到DXE阶段。</li>
</ul>
</li>
<li>PEIM调度器<ul>
<li>PEIM调度器本质是上一个有限状态机（State machine）和PEI阶段的核心<ul>
<li>状态机（State machine）的意思是其输出取决于输入时的状态及输入值。</li>
</ul>
</li>
<li>遍历每一个已遍历过的PEIMs的PPI例表上的Dependency表达式</li>
<li>如果DEPEX检测某个PEIM的返回值为True，就会调用该PEIM，否则就会检测下一个PEIM<ul>
<li>UEFI会避免PEIM A和PEIM B处于死循环的状态中。（X和Y是PPI）<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587883176/UEFI%20Basic/15.png" alt="15.png"></li>
</ul>
</li>
<li>一个PPI是EFI_FIND_FV_PPI可以调用每一个固件卷上的任意一个PEIM</li>
<li>一旦所有的PEIM都已经执行过了，最后一个执行的PEIM是DXE IPL PEIM，该PEIM会传递DXE阶段所需的信息给DXE</li>
</ul>
</li>
<li>DXE所需的Handoff退出的条件<ul>
<li>HOB例表必须包含下述的HOB（Handoff Block）：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587883889/UEFI%20Basic/16.png" alt="16.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="DXE-Driver-Execution-Environment-阶段"><a href="#DXE-Driver-Execution-Environment-阶段" class="headerlink" title="DXE(Driver Execution Environment)阶段"></a>DXE(Driver Execution Environment)阶段</h4><ul>
<li>DXE阶段在足够高的层级上执行代码，该层级不依赖任何架构</li>
<li>与PEI有许多相似之处，比如DXE阶段创建的服务只能用于该阶段，DXE阶段有DXE调度器，调度器负责查找和加载DXE驱动等。<ul>
<li>PEI与DXE相似之处比较<ul>
<li>PEIMs相当于DXE驱动</li>
<li>PEI调度器相当于DXE调度器<ul>
<li>DXE使用一个识别系统（identical system）</li>
<li>PEI加载和调用独立的功能单元需要DEPEXs</li>
</ul>
</li>
<li>PPI相当于Protocol<ul>
<li>DXE驱动寄存器会搜索Protocols</li>
</ul>
</li>
<li>Sec Core Data相当于HOBs<ul>
<li>PEI从SEC阶段获取Sec Core Data</li>
<li>DXE从PEI阶段获取HOBs</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>系统管理模式设置（System Management Mode）、Secure Boot强制和BIOS更新签名检查通常都在此阶段实现。因此该阶段是UEFI启动流程中的安全检查核心步骤。</li>
<li>DXE服务表<ul>
<li><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587890272/UEFI%20Basic/19.png" alt="DXE服务表"></li>
</ul>
</li>
<li>Boot服务表<ul>
<li><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891222/UEFI%20Basic/20.png" alt="表1"></li>
<li><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891222/UEFI%20Basic/21.png" alt="表2"></li>
<li><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891222/UEFI%20Basic/22.png" alt="表3"></li>
</ul>
</li>
<li>Runtime服务表<ul>
<li><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587891361/UEFI%20Basic/23.png" alt="Runtime服务表"></li>
</ul>
</li>
<li>DXE和SMM（System Management Mode）的关系<ul>
<li>DXE加载SMM IPL（Initial Program Loader）</li>
<li>SMM IPL加载SMM Core</li>
<li>SMM Core加载SMM驱动</li>
</ul>
</li>
</ul>
<h4 id="BDS-Boot-Device-Selection-阶段"><a href="#BDS-Boot-Device-Selection-阶段" class="headerlink" title="BDS(Boot Device Selection)阶段"></a>BDS(Boot Device Selection)阶段</h4><ul>
<li>BDS通常会封装到单个文件中，该问文件会由DXE阶段加载</li>
<li>BDS会获取配置信息，这个配置信息决定是引导（Boot）一个操作系统还是进行其他内容</li>
<li>BDS阶段有权限访问DXE阶段设置的整个UEFI Boot服务表<ul>
<li>攻击者能够在DXE阶段获取UEFI Boot服务表的访问权限</li>
</ul>
</li>
<li>与SEC-&gt;PEI、PEI-&gt;DXE的过渡不同，在进入BDS阶段之前不用收集信息并传递</li>
<li>DXE阶段会给BDS及其下一个阶段提供一个指向系统表的指针，该系统表会指向boot服务和DXE服务表。</li>
</ul>
<h4 id="TSL（Transient-System-Load）阶段"><a href="#TSL（Transient-System-Load）阶段" class="headerlink" title="TSL（Transient System Load）阶段"></a>TSL（Transient System Load）阶段</h4><ul>
<li>该阶段会获取固件派生（firmware-derived）代码产生的数据，通常会将这部分数据传递给HD存储（HD-stored）代码</li>
<li>若系统在Secure Boot开启状态下运行，BDS会将这个阶段加载的所有代码在加载之前进行签名校验，未经过签名校验的代码不允许加载</li>
<li>未经签名校验（未开启Secure Boot）的攻击路径<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587970012/UEFI%20Basic/26.png" alt="未经过签名校验的路径"></li>
<li>经过签名校验（开启Secure Boot）攻击失败的路径<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587970013/UEFI%20Basic/27.png" alt="已经过签名校验的路径"><ul>
<li>考虑一下，若强制引导（Boot）一个随机操作系统上不存在的安全应用会发生什么问题？前提：在理想情况下，使用TPM&#x2F;TXT(Trusted Boot)保证该应用的可信度。</li>
</ul>
</li>
</ul>
<h4 id="RT（Runtime）阶段"><a href="#RT（Runtime）阶段" class="headerlink" title="RT（Runtime）阶段"></a>RT（Runtime）阶段</h4><ul>
<li>进入RT阶段后，系统的控制权从UEFI内核转交到OS Loader手中。</li>
<li>通常OS boot loader（操作系统引导加载器）加载完成之后，它会调用UEFI Boot服务表中的ExitBootSevices()该服务会回收UEFI大部分内存，以便OS能够使用这些内存。</li>
<li>UEFI还会保留部分内存，这部分内存由运行时服务（Runtime Services）使用。</li>
<li>随着OS Loader的执行，OS最终取得系统的控制权</li>
</ul>
<h4 id="AL（After-Life）阶段"><a href="#AL（After-Life）阶段" class="headerlink" title="AL（After Life）阶段"></a>AL（After Life）阶段</h4><ul>
<li>这个阶段一般不会作为实施攻击的阶段</li>
<li>该阶段可以在选择正常关闭时做某些操作，比如清除机密。</li>
<li>一般情况下，在RT阶段，如果系统（硬件或软件）遇到灾难性错误，系统固件需要提供错误处理和灾难恢复机制。</li>
</ul>
<h3 id="Secure-Boot"><a href="#Secure-Boot" class="headerlink" title="Secure Boot"></a>Secure Boot</h3><ul>
<li>判定一个可执行文件是否被允许在UEFI&#x2F;BIOS引导（boot）过程中加载&#x2F;执行</li>
<li>当发现一个可执行文件比如Boot加载器或Option ROM，UEFI会进行如下检查：<ul>
<li>可执行文件是否已经过认证密钥签名</li>
<li>可执行文件的密钥、签名或哈希值是否已存储在已经过认证的签名数据库中</li>
</ul>
</li>
<li>UEFI flash上的模块（SEC,PEI,DXECore）没有签名校验<ul>
<li>BIOS的flash镜像在更新过程中会有签名校验（固件签名，Fireware Signing）<ul>
<li>当可以直接对flash芯片直接操作的时候，BIOS不会在每次运行的时候进行签名校验。（可作为一个绕过BIOS签名校验的方法）</li>
</ul>
</li>
</ul>
</li>
<li>UEFI Secure Boot：阻止底层的攻击，比如bootkit之类的<ul>
<li>DXE会对非嵌入式XROM、DXE驱动程序、UEFI应用程序和引导加载程序进行签名认证。</li>
<li>下图为UEFI Secure Boot进程<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587978219/UEFI%20Basic/28.png" alt="UEFI Secure Boot进程"></li>
</ul>
</li>
<li>Windows 8 Secure Boot<ul>
<li>微软Windows 8在Secure Boot的基础上增加了Secure Boot的检测机制。建立了一条认证链：<ul>
<li>UEFI Boot Loader-&gt; OS Loader -&gt; OS Kernel -&gt; OS Drivers</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf">Windows 8 Secure Boot的绕过姿势</a></li>
</ul>
</li>
</ul>
<h3 id="UEFI非易失变量（Non-Volatile-Variables）"><a href="#UEFI非易失变量（Non-Volatile-Variables）" class="headerlink" title="UEFI非易失变量（Non-Volatile Variables）"></a>UEFI非易失变量（Non-Volatile Variables）</h3><ul>
<li>UEFI使用CMOS&#x2F;NVRAM代替BIOS配置机制，使用CMOS&#x2F;NVRAM具有可延展性且更安全<ul>
<li>NVRAM——non-volatile RAM，是EFI用于存储Boot期间需要长期保存的变量，其中大部分的非易失变量（Non-Volatile Variables）是由架构定义的。若给NVRAM设置了无效选项，将使机器无法正常进入Boot流程。</li>
</ul>
</li>
<li>会使用SPI flash芯片存储部分BIOS代码</li>
<li>至少有两个系统的非易失变量处理过程存在漏洞，一旦变量空间被填满，系统就会崩溃。当一个操作系统的Logging机制发生问题的时候就会造成变量空间被填满。</li>
<li>非易失变量（Non-Volatile Variables）会在PEI阶段访问，CapsuleUpdate变量中的VU#552286项就是在这个阶段被访问的。但大部分变量更有可能在DXE阶段或者后面的阶段被访问，访问变量最靠后能到RT阶段。</li>
<li>EFI变量属性：每一个UEFI变量都会通过属性告知固件如何存储和维护该变量对应的数据<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587952601/UEFI%20Basic/24.png" alt="EFI变量属性"><ul>
<li>单个属性介绍<ul>
<li>NON_VOLATILE属性：存储在flash中的变量</li>
<li>BOOTSERVICE_ACCESS属性：可在Boot期间被访问或修改，需要按照Runtime_Access设置的访问顺序给该属性的变量赋值。</li>
<li>Runtime_Access：变量可以被操作系统或应用修改</li>
<li>Hardware_Error_Record：存储在NVRAM（flash）的一部分，用于存储报错记录</li>
<li>Authenticated_Write_Access：变量只能被已经认证私钥签名的应用或当前用户修改<ul>
<li>KEK和DB就是经认证（Authorized）变量</li>
</ul>
</li>
<li>Time_Based_Authenticated_Write_Access：变量需要有时间戳（time-stamp）作为认证凭证</li>
<li>Append_Write：变量可添加数据</li>
</ul>
</li>
<li>多个属性组合介绍<ul>
<li>如果一个变量同时拥有Runtime和Authenticated的属性，那么该变量只能已经过认证的密钥签名的应用修改</li>
<li>如果一个变量具有Runtime属性但是没有Authenticated属性，那么这个变量可以被任何应用修改<ul>
<li>VU#758382项的Setup变量就是这样的一个变量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>认证方式——Key和Key Stores<ul>
<li>UEFI通过四个变量实现认证机制，这四个变量负责存储密钥、签名或hash值<ul>
<li>PK(Plateform Key)<ul>
<li>PK建立起平台所有者和平台固件间的信任关系</li>
<li>PK控制访问其自身和KEK变量</li>
<li>仅有物理意义上的当前用户或者经PK签名的应用才有权限修改PK的值</li>
<li>需要开启Secure Boot，否则系统在设置模式下密钥可以被任意应用修改</li>
</ul>
</li>
<li>KEK(Key Exchange Key)<ul>
<li>KEK建立起操作系统和平台固件间的信任关系</li>
<li>KEK用于更新签名数据库</li>
<li>后缀名的.efi文件经KEK签名后才能正常执行</li>
</ul>
</li>
<li>DB（Signature Database）<ul>
<li>二进制的密钥、签名或哈希值的白名单</li>
</ul>
</li>
<li>DBX（Forbidden Database）<ul>
<li>二进制的密钥、签名或哈希值的黑名单</li>
</ul>
</li>
</ul>
</li>
<li>UEFI变量（Key和Key Store）<ul>
<li>Key和Key Store这部分变量存储于flash的文件系统中<ul>
<li>SPI flash一旦未被正确锁定，这些密钥或哈希值可被攻击者重写</li>
<li>UEFI变量的安全必须且只能依赖SMM，第二道防线的范围保护寄存器不能正常使用</li>
<li>UEFI变量必须保持可写状态，因为有些时候系统需要写入变量</li>
<li>有两个关于阻止SMI(System Management Interrupt)实现将Charizard PoC的bootkit添加到DB白名单的例子<ul>
<li><a target="_blank" rel="noopener" href="https://cansecwest.com/slides/2014/AllYourBoot_csw14-mitre-final.pdf">ALL YOUR BOOT ARE BELONG TO US</a></li>
<li><a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/us-14/materials/us-14-Kallenberg-Extreme-Privilege-Escalation-On-Windows8-UEFI-Systems.pdf">Extreme Privilege Escalation on Windows 8&#x2F;UEFI Systems</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="UEFI攻击面"><a href="#UEFI攻击面" class="headerlink" title="UEFI攻击面"></a>UEFI攻击面</h1><p>下面的图只呈现了UEFI固件的威胁攻击模型，如果有时间也可以了解一下Intel ME和AMT，它们最近也是安全问题频发。而过去，出现漏洞最多的是<a target="_blank" rel="noopener" href="https://www.synacktiv.com/ressources/zeronights_2018_turning_your_bmc_into_a_revolving_door.pdf">BMC</a>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/1.png" alt="UEFI攻击面"><br>攻击面分类如下：</p>
<ul>
<li>Post-Exploitation（加电自检漏洞利用）<ul>
<li>Secure Boot Bypass：绕过Secure Boot机制</li>
<li>SMM Privilege Escalation：SMM(System Management Mode)提权，</li>
<li>UEFI Firmware Implant：UEFI固件后门植入</li>
<li>Persistent Implant：持久后门植入</li>
<li>Non-Persistent Implant：非持久后门植入</li>
</ul>
</li>
<li>Compromised Supply Chain(供应链攻击)<ul>
<li>Misconfigured Protections(防护配置错误)</li>
<li>Non-Secure Root of Trust(不安全的安全信任根)</li>
<li>Malicious Peripheral Devices</li>
<li>Implanted BIOS Updates</li>
<li>Unauthenticated BIOS Update Process</li>
<li>Outdated BIOS with known security issues</li>
</ul>
</li>
</ul>
<h2 id="UEFI攻击流程概述"><a href="#UEFI攻击流程概述" class="headerlink" title="UEFI攻击流程概述"></a>UEFI攻击流程概述</h2><p>这部分内容是参考文章<a target="_blank" rel="noopener" href="https://medium.com/@matrosov/dangerous-update-tools-c246f7299459">What makes OS drivers dangerous for BIOS?</a>的，发现其中有一个图讲得非常详细，描述了UEFI攻击过程：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694977/UEFI%20Basic/2.png" alt="UEFI攻击流程图"></p>
<p>按照上图可以攻击可分为以下四个阶段：</p>
<ol>
<li>用户模式：该阶段实际上是一个利用客户端的漏洞提权的过程，举一个例子，web浏览器远程代码执行(RCE，remote code execution)，在系统上下一个恶意的installer，这个installer再利用其他的漏洞提权，提升到LOCALSYSTEM的权限之后，使用该权限继续执行代码。</li>
<li>内核模式：installer需要先绕过代码签名机制，在内核模式下执行代码。内核模式下运行payload（driver）然后获取SMM的权限</li>
<li>系统管理模式（SMM, System Management Mode）：SMM的Shellcode成功执行之后，实现提权，并且能够关闭SPI flash内存的修改防护机制（一种阻止SPI flash内存被修改的机制）。</li>
<li>SPI Flash：所有的SPI flash的防护机制都被关闭之后，可以实现在flash中任意写入的效果。任意写入之后能够实现rootkit&#x2F;implant(固件层的后门)安装到SPI flash芯片上的固件中。到此，实现了系统中最高级别的持续化后门植入。</li>
</ol>
<h2 id="加电自检漏洞利用-Post-Exploitation"><a href="#加电自检漏洞利用-Post-Exploitation" class="headerlink" title="加电自检漏洞利用(Post-Exploitation)"></a>加电自检漏洞利用(Post-Exploitation)</h2><p>常用的专业术语：</p>
<ul>
<li>加电自检(POST, Power-On Self-Test)：</li>
<li>Rootkit：大多指被作为驱动程序，加载到操作系统内核中的恶意软件。</li>
<li>SMM: 系统管理模式，一共有用户模式、内核模式、系统管理模式、SPI Flash（存放BIOS&#x2F;UEFL的内存芯片）</li>
<li>PI：平台初始化（Platform Initialization，简称PI）</li>
<li>UEFI &#x3D; Unified Extensible Firmware Interface（通用扩展固件接口）</li>
</ul>
<p>这部分内容参考文章<a target="_blank" rel="noopener" href="https://medium.com/@matrosov/uefi-vulnerabilities-classification-4897596e60af">UEFI vulnerabilities classification focused on BIOS implant delivery</a></p>
<h3 id="Secure-Boot绕过-Secure-Boot-Bypass"><a href="#Secure-Boot绕过-Secure-Boot-Bypass" class="headerlink" title="Secure Boot绕过(Secure Boot Bypass)"></a>Secure Boot绕过(Secure Boot Bypass)</h3><p>绕过Secure Boot，其关注的重点是如何破坏安全引导过程（Secure boot process），实现攻击的前提是通过了Root认证（Root of Trust，full compromise）或在OS加载之前的引导过程中选择任意一个阶段实施攻击。Secure boot绕过可发生在引导过程的任一阶段，并且会影响其之后的执行流程，破坏后续流程的认证机制（Trust mechanisms）。</p>
<h3 id="SMM权限提升-SMM-Privilege-Escalation"><a href="#SMM权限提升-SMM-Privilege-Escalation" class="headerlink" title="SMM权限提升(SMM Privilege Escalation)"></a>SMM权限提升(SMM Privilege Escalation)</h3><p>在使用x86架构硬件上，SMM（System Management Mode, 系统管理模式）具有强大的威力，因为大部分SMM提权最终都能够实现代码执行。SMM提权通常是BIOS植入后门的最后一个步骤之一。</p>
<h3 id="UEFI固件后门植入-UEFI-Firmware-Implant"><a href="#UEFI固件后门植入-UEFI-Firmware-Implant" class="headerlink" title="UEFI固件后门植入(UEFI Firmware Implant)"></a>UEFI固件后门植入(UEFI Firmware Implant)</h3><p>UEFI固件后门植入——植入长期存在于BIOS中的后门（持久化后门）的最后一个步骤，该后门可在UEFI固件启动的不同阶段（DXE, PEI）中作为一个已修改过的合法模块或独立驱动被植入。</p>
<h3 id="持久化后门-Persistent-Implant"><a href="#持久化后门-Persistent-Implant" class="headerlink" title="持久化后门(Persistent Implant)"></a>持久化后门(Persistent Implant)</h3><p>持久化BIOS后门能在完整的重启和关机周期中运行，并且，在某些情况下能在加电自检更新过程安装BIOS镜像前对BIOS更新镜像进行修改。</p>
<h3 id="非持久化后门-Non-Persistent-Implant"><a href="#非持久化后门-Non-Persistent-Implant" class="headerlink" title="非持久化后门(Non-Persistent Implant)"></a>非持久化后门(Non-Persistent Implant)</h3><p>非持久化BIOS后门不能在完整的重启和关机周期中运行，在某些情况下可以在睡眠或休眠状态下运行。该后门重点关注提权、有硬件虚拟化保护(比如Intel VT-x)的OS中的代码执行和可信执行(Trust Execution)比如使用MS VBScript。此外，该后门可将恶意代码传到内核模式下或破坏TEE(Trusted execution environment,可信执行环境)内存的隔离性。</p>
<h2 id="供应链攻击-Compromised-Supply-Chain"><a href="#供应链攻击-Compromised-Supply-Chain" class="headerlink" title="供应链攻击(Compromised Supply Chain)"></a>供应链攻击(Compromised Supply Chain)</h2><p>加电自检漏洞利用，需要成功完成其之前的阶段的漏洞利用过程，才能最终将持续化后门或非持续化后门植入BIOS中。供应链攻击会在未来造成严重威胁，该漏洞由BIOS开发团队或OEM硬件产商导致的未知错误引发，或由攻击者特意造成目标软件配置错误引发，该错误配置可让攻击者绕过平台的安全功能。</p>
<h3 id="防护配置错误-Misconfigured-Protections"><a href="#防护配置错误-Misconfigured-Protections" class="headerlink" title="防护配置错误(Misconfigured Protections)"></a>防护配置错误(Misconfigured Protections)</h3><p>在硬件拥有者无法防止硬件被物理接触时（交给海关检查之类的），硬件和固件的错误配置会变成一个重要的攻击向量。可物理接触硬件时，可在这个时候实现BIOS后门植入，配置错误攻击向量有时候被称为“Evil Maid attack”，这个术语可用于任何可以轻易获取的攻击向量上。</p>
<h3 id="不安全的安全信任根-Non-Secure-Root-of-Trust"><a href="#不安全的安全信任根-Non-Secure-Root-of-Trust" class="headerlink" title="不安全的安全信任根(Non-Secure Root of Trust)"></a>不安全的安全信任根(Non-Secure Root of Trust)</h3><p><a target="_blank" rel="noopener" href="https://www.rambus.com/blogs/hardware-root-of-trust/">硬件安全信任根介绍</a></p>
<h3 id="恶意外部设备-Malicious-Peripheral-Devices"><a href="#恶意外部设备-Malicious-Peripheral-Devices" class="headerlink" title="恶意外部设备(Malicious Peripheral Devices)"></a>恶意外部设备(Malicious Peripheral Devices)</h3><h3 id="BIOS更新后门-Implanted-BIOS-Updates"><a href="#BIOS更新后门-Implanted-BIOS-Updates" class="headerlink" title="BIOS更新后门(Implanted BIOS Updates)"></a>BIOS更新后门(Implanted BIOS Updates)</h3><h3 id="未经认证的BIOS更新进程-Unauthenticated-BIOS-Update-Process"><a href="#未经认证的BIOS更新进程-Unauthenticated-BIOS-Update-Process" class="headerlink" title="未经认证的BIOS更新进程(Unauthenticated BIOS Update Process)"></a>未经认证的BIOS更新进程(Unauthenticated BIOS Update Process)</h3><h3 id="有已知安全问题的旧版BIOS-Outdated-BIOS-with-known-security-issues"><a href="#有已知安全问题的旧版BIOS-Outdated-BIOS-with-known-security-issues" class="headerlink" title="有已知安全问题的旧版BIOS(Outdated BIOS with known security issues)"></a>有已知安全问题的旧版BIOS(Outdated BIOS with known security issues)</h3><h3 id="资料收集——供应链破坏"><a href="#资料收集——供应链破坏" class="headerlink" title="资料收集——供应链破坏"></a>资料收集——供应链破坏</h3><p><a target="_blank" rel="noopener" href="https://eclypsium.com/2018/10/04/hardware-supply-chain-threats/">HARDWARE SUPPLY CHAIN THREATS</a><br><a target="_blank" rel="noopener" href="https://eclypsium.com/2019/07/16/vulnerable-firmware-in-the-supply-chain-of-enterprise-servers/">VULNERABLE FIRMWARE IN THE SUPPLY CHAIN OF ENTERPRISE SERVERS</a>——服务器的固件供应链破坏</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="UEFI固件下载及FFS文件获取过程"><a href="#UEFI固件下载及FFS文件获取过程" class="headerlink" title="UEFI固件下载及FFS文件获取过程"></a>UEFI固件下载及FFS文件获取过程</h2><p>从<a target="_blank" rel="noopener" href="https://support.lenovo.com/th/zh/solutions/migr-4jts2t">IBM UEFI固件下载</a>上下载<code>System x3200 M3</code>的UEFI文件</p>
<ol>
<li>下载镜像文件<code>H45078702.iso</code></li>
<li>解压该镜像文件，会获得四个文件，分别是ibm_fw_uefi_gye165a-1.30_anyos_i386.chg、ibm_fw_uefi_gye165a-1.30_windows_32-64.exe、ibm_fw_uefi_gye165a-1.30_windows_32-64.txt和ibm_fw_uefi_gye165a-1.30_windows_32-64.xml。</li>
<li>提取UEFI文件，双击.exe文件，会出现一个图形化的界面，在Action框中选中<code>Extract to Hard Dr</code>将文件解压到你想存放的文件夹下。</li>
<li>在选中的文件夹下找到后缀名为<code>.upd</code>的文件，将其后缀名改为<code>.zip</code>并解压，获得文件<code>gye165a.tar.gz</code>。</li>
<li>解压文件<code>gye165a.tar.gz</code>，获得FFS的文件。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/9.png" alt="f7712efdde1a09e002e8c5605c81dc34.png"></li>
</ol>
<p>心路历程，实际上在获得<code>.upd</code>文件之后我不知道应该怎么处理，用<code>010 Editor</code>查看了文件内容之后，发现这里面包含了许多文件，详情如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587694978/UEFI%20Basic/10.png" alt="83ac51fb293227f369481775a0659fce.png"><br>就想起可以重命名该文件，说不定能直接获取fv文件之类的，就把这个文件的后缀名重命名为<code>.zip</code>并解压，解压之后获取了文件<code>gye165a.tar.gz</code>，然后再解压一次就获得我想要的FFS文件了。</p>
<h2 id="DXE-main获取过程"><a href="#DXE-main获取过程" class="headerlink" title="DXE main获取过程"></a>DXE main获取过程</h2><p>在上面的第五步之后，可以在<code>gye165a</code>文件夹下找到一个<code>FvDxe.fv</code>的文件，用UEFITool打开可以找到TEXT为DxeMain的file：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587884581/UEFI%20Basic/17.png" alt="DxeMain图"></p>
<p>展开该file，然后选中<code>PE32 image section</code>，右键将这部分section提取出来，并将这部分重命名为<code>DxeMain.bin</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587884993/UEFI%20Basic/18.png" alt="提取DxeMain图"></p>
<p>用<code>010 Editor</code>查看<code>DxeMain.bin</code>，会发现其中的PE文件头，我们现在需要做的就是把它转化为EFI文件，然后用IDA进行分析。（改后缀名失败了…..）</p>
<p>发给我的<code>Section_PE32_image_DxeMainDxe_DxeMain_body.efi</code>和我之前提取出来的<code>DxeMain.bin</code>文件进行对比，发现bin文件头中比efi文件头中多了四个字节<code>0xA4E90010</code>。<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1587967011/UEFI%20Basic/25.png" alt="bin和efi文件对比图"></p>
<p>我把<code>0xA4E90010</code>删除之后，再把原来的<code>DxeMain.bin</code>改为<code>DexMain.efi</code>，然后再用64位的IDA打开，发现能够正常打开了。接下来，只需要对DXE main进行分析就行了。</p>
<h2 id="DXE-main分析过程"><a href="#DXE-main分析过程" class="headerlink" title="DXE main分析过程"></a>DXE main分析过程</h2><h2 id="UEFI固件修改过程"><a href="#UEFI固件修改过程" class="headerlink" title="UEFI固件修改过程"></a>UEFI固件修改过程</h2><p><a target="_blank" rel="noopener" href="https://www.win-raid.com/t3061f16-Guide-How-to-extract-insert-replace-EFI-BIOS-modules-by-using-the-UEFITool.html">UEFItool教程</a></p>
<h2 id="UEFI固件刷写过程"><a href="#UEFI固件刷写过程" class="headerlink" title="UEFI固件刷写过程"></a>UEFI固件刷写过程</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96601938">刷固件教程</a></p>
<ol>
<li>找到motherboard model和bios版本，使用命令<code>wmic baseboard get product,Manufacturer</code>，在google上搜索motherboard model对应的名称根据BIOS固件版本就可以下载对应的BIOS文件了。</li>
<li>下载华硕（ASUS）的固件，它后缀名为<code>.cap</code>，把这个文件放到USB中，然后主板关机。</li>
<li>重启电脑，然后不断地按<code>Del</code>键，就能进入BIOS设置的页面，然后按下<code>F7</code>，进入<code>工具</code>中找到我们之前下载的.cap文件，然后选择刷入即可。</li>
</ol>
<p>ASUS固件（后缀名为<code>.cap</code>）直接拉到UEFITool就能够直接解析了，找到DxeCore部分，直接把这个提取出来就好了。</p>
<p>刷ASUS固件比较好用的工具有<code>AFUWINx64_v3.05.04</code>，输入的命令如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ afuwinx64 raw_rom_name.CAP /P</span><br><span class="line">$ afuwinx64 want_to_flash_name.bin /GAN</span><br></pre></td></tr></table></figure>

<p>重启之后需要将安全启动中的密钥全部删除，这样就完成了刷写的全部操作。</p>
<p>遇到的问题及解决方法</p>
<ul>
<li>用其他工具写的时候，遇到了<code>Failed to disable write protection for the BIOS space</code>的报错，可以用AFUWINx64上面的方法刷，最好是有GAN命令的。</li>
<li>电脑一直在EFI Shell的页面，关闭电源之后把USB拔出来，然后重启</li>
<li>刷完带有Shell的固件之后，重启出现<code>The system found unauthorized change on the firmware, operating system or UEFI drivers.</code>，这时候打开BIOS设置界面，进入安全启动项，清除安全密钥就能重启了。</li>
</ul>
<h1 id="资料收集"><a href="#资料收集" class="headerlink" title="资料收集"></a>资料收集</h1><h2 id="UEFI-bootkit"><a href="#UEFI-bootkit" class="headerlink" title="UEFI bootkit"></a>UEFI bootkit</h2><p><a target="_blank" rel="noopener" href="https://github.com/btbd/umap">umap</a></p>
<h2 id="UEFI分析工具"><a href="#UEFI分析工具" class="headerlink" title="UEFI分析工具"></a>UEFI分析工具</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/assafcarlsbad/efi_dxe_emulator">UEFI DXE阶段的模拟器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/us-13/8US-13-Butterworth-BIOS-Security-Code.zip">bios_diff.py</a>：用于对比BIOS固件间不同，看是否有修改。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/snare/ida-efiutils">ida-efiutils</a>：有IDA分析EFI的脚本 + EFI的库文件<code>behemoth.h</code>。IDA在加载<code>behemoth.h</code>文件之前，需要在文件中添加<code>typedef unsigned char FILLER;</code>和<code>typedef void VOID;</code>，否则会出现如下6个报错：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Error ...\UEFI_Ananlysis_Tool\ida-efiutils-master\behemoth.h,65: Syntax error near: @type VA_LIST</span><br><span class="line">Error ...\UEFI_Ananlysis_Tool\ida-efiutils-master\behemoth.h,21766: Undefined type name &#x27;VOID&#x27;</span><br><span class="line">Error ...\UEFI_Ananlysis_Tool\ida-efiutils-master\behemoth.h,21890: Syntax error near: FILLER</span><br><span class="line">Error ...\UEFI_Ananlysis_Tool\ida-efiutils-master\behemoth.h,21891: Syntax error near: &#125;</span><br><span class="line">Error ...\UEFI_Ananlysis_Tool\ida-efiutils-master\behemoth.h,21922: Syntax error near: PEI_CORE_FV_HANDLE</span><br><span class="line">Error ...\UEFI_Ananlysis_Tool\ida-efiutils-master\behemoth.h,21958: Syntax error near: &#125;</span><br><span class="line">Total 6 errors</span><br></pre></td></tr></table></figure>

<p>IDA导入头文件的方法：File-&gt;Load file-&gt; Parse C header file…-&gt;选中<code>behemoth.h</code>文件即可。<br><a target="_blank" rel="noopener" href="https://firmwaresecurity.com/2017/06/13/efi-swiss-knife-ida-plugin/">EFI Swiss Knife</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/LongSoft/FTK/releases">FTK工具</a>：刷BIOS的工具<ul>
<li>更新:下载适合你主板的<a target="_blank" rel="noopener" href="https://www.win-raid.com/t596f39-Intel-Management-Engine-Drivers-Firmware-amp-System-Tools.html">Intel ME System Tools</a>，点击查看链接有最新的，把其中的MEInfo、Flash Programming Tool和FWUpdLcl64.exe复制到FTK10的目录下，这样FTK10就能正常使用了。</li>
</ul>
</li>
</ul>
<h2 id="BIOS-LOCK修改——UEFI层面"><a href="#BIOS-LOCK修改——UEFI层面" class="headerlink" title="BIOS LOCK修改——UEFI层面"></a>BIOS LOCK修改——UEFI层面</h2><ul>
<li><p>BIOS LOCK的修改，现在有下面3种思路：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.insanelymac.com/forum/topic/285444-uefipatch-uefi-patching-utility/?do=findComment&comment=1944166">修改PchInitDxe</a>，通过“+50h]”定位固件中的寄存器，并将其中的je改成jmp即可，但是现在缺少源码的比较，所以比较难定位具体修改的位置。详细的修改情况可以参照下一段——实际修改过程。</li>
<li>使用RWEverything修改BIOS_CNTL.BIOSWE和BIOS_CNTL.BLE，这部分需要利用<a target="_blank" rel="noopener" href="https://www.kb.cert.org/vuls/id/766164/">14年一个条件竞争的CVE</a>，最终实现修改<ul>
<li>RWEverything，<code>Access-&gt; SMBIOS Structures</code>，修改BIOS_CNTL的BIOSWE（ BIOS Write Enable）位，改为1，能够获取BIOS区域写入的权限，BIOS Lock Enable (BLE)位设置为0，有可能SMI（ System Management Interrupt）会把BIOSWE位设置为0。</li>
<li>可以参考<a target="_blank" rel="noopener" href="https://medium.com/@matrosov/dangerous-update-tools-c246f7299459">这篇文章</a>，里面有相关的POC的介绍，说不定我也能自己根据POC写一个dll文件，最终实现自动化处理这个呢，不过较新的bios可能就不能实现写入了……</li>
</ul>
</li>
<li>修改ME区域（这个暂时还没有找到具体的方案），<a target="_blank" rel="noopener" href="https://www.insanelymac.com/forum/topic/285444-uefipatch-uefi-patching-utility/?do=findComment&comment=1944334">参考依据</a></li>
</ol>
</li>
<li><p>实际修改过程，直接用IDA打开PchInitDxe查看</p>
<ol>
<li><p>用<code>ALT+T</code>搜索<code>+50]</code>，勾选<code>Find all occurrences</code>，找到后面跟着<code>test</code>指令的部分，示例如下：<br><img src="https://res.cloudinary.com/dq4c0zqqy/image/upload/v1588726971/UEFI%20Basic/50_P3X7__PH5J_AJ4ZDW_CK.png" alt="PchInitDxe test示例"><br>但实际上我们不会对这个进行修改，只是一个示例而已，对照着<code>PCH_LOCKDOWN_CONFIG</code>数据结构查看，我们实际上要修改的是BiosLock的部分，也就是找到同时有<code>test</code>指令和<code>0x10</code>的语句，将其后面的<code>jz</code>或<code>je</code>语句直接改成<code>jmp</code>即可。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">UINT8  GlobalSmi      : 1; //test with 0x01</span><br><span class="line">UINT8  BiosInterface  : 1; //test with 0x02</span><br><span class="line">UINT8  GpioLockDown   : 1; //test with 0x04</span><br><span class="line">UINT8  RtcLock        : 1; //test with 0x08</span><br><span class="line">UINT8  BiosLock       : 1; //test with 0x10</span><br><span class="line">UINT8  Reserved       : 3;</span><br><span class="line">UINT8  PchBiosLockSwSmiNumber;</span><br><span class="line">&#125; PCH_LOCKDOWN_CONFIG;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 将上面搜索到的语句一个个进行查看，定位同时有`test`指令和`0x10`的语句。</span><br><span class="line">    ![PchInitDxe修改图](https://res.cloudinary.com/dq4c0zqqy/image/upload/v1588727942/UEFI%20Basic/W_SLZ_161_QK0PISZE_M7NW.png)</span><br><span class="line">3. 将`jz`修改为`jmp`，在IDA页面`Edit-&gt;Assemble`，第一个弹窗将jz修改为jmp，第二个弹窗按下`Cancel`。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="UEFI研究人员分类"><a href="#UEFI研究人员分类" class="headerlink" title="UEFI研究人员分类"></a>UEFI研究人员分类</h2><p><a target="_blank" rel="noopener" href="https://twitter.com/NikolajSchlej">UEFItool的开发者</a></p>
<h1 id="文章收集"><a href="#文章收集" class="headerlink" title="文章收集"></a>文章收集</h1><p><a target="_blank" rel="noopener" href="http://timeglider.com/timeline/5ca2daa6078caaf4">Low level PC&#x2F;server attack papers collection” timeline</a><br><a target="_blank" rel="noopener" href="https://eclypsium.com/wp-content/uploads/2019/08/EXTERNAL-Get-off-the-kernel-if-you-cant-drive-DEFCON27.pdf">Get-off-the-kernel-if-you-cant-drive</a>：通过驱动修改MSR的寄存器，最终破坏读写保护机制。<br><a target="_blank" rel="noopener" href="https://eclypsium.com/2020/01/20/assessing-enterprise-firmware-security-risk/">ASSESSING ENTERPRISE FIRMWARE SECURITY RISK IN 2020</a>：2020年企业固件安全风险分析<br><a target="_blank" rel="noopener" href="https://i.blackhat.com/USA-19/Thursday/us-19-Matrosov-Breaking-Through-Another-Side-Bypassing-Firmware-Security-Boundaries-From-Embedded-Controller.pdf">Bypassing Firmware Security Boundaries from Embedded Controller</a>:介绍绕过EC的，大致上介绍了UEFI几个修改的关键点<br><a target="_blank" rel="noopener" href="https://medium.com/@dannyodler/attacking-the-golden-ring-on-amd-mini-pc-b7bfb217b437">Attacking the Golden Ring on AMD Mini-PC</a>:绕过Windows strongest security boundary</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://medium.com/@matrosov/uefi-vulnerabilities-classification-4897596e60af">UEFI vulnerabilities classification focused on BIOS implant delivery</a><br><a target="_blank" rel="noopener" href="https://medium.com/@matrosov/dangerous-update-tools-c246f7299459">What makes OS drivers dangerous for BIOS?</a><br><a target="_blank" rel="noopener" href="https://edk2-docs.gitbooks.io/edk-ii-minimum-platform-specification/appendix_a_full_maps/a1_firmware_volume_layout.html">UEFI EKD2手册</a></p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/project/2023/08/09/BIOS%E5%86%99%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"
      title="BIOS写保护机制"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        BIOS写保护机制
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/project/2023/08/09/Xilinx-SP605%E7%94%B5%E8%B7%AF%E6%9D%BF%E6%95%85%E9%9A%9C%E8%B0%83%E8%AF%95/"
      title="Xilinx SP605电路板故障调试"
     >

    <p class="title-text">
      
        Xilinx SP605电路板故障调试
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({"enable":true,"appId":"bC8HOSKa4QB7G6TfuGWB97i4-gzGzoHsz","appKey":"aoDFuSX5vWN8Xn1ukZpJ50be","placeholder":"写下你的评论...","pageSize":10,"highlight":true,"serverURLs":null,"el":"#vcomments"});
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Edvison<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/project/js/light-dark-switch.js"></script>
</body>
</html>
